// This script expects the following environment variables to be set by the Jenkins job:

GIT_BRANCH = git_branch_name()
CHECKOUT_DIR = 'source'
CISCRIPT_DIR = "${CHECKOUT_DIR}/buildconfig/Jenkins/Conda"
pipeline {
  agent { label 'linux-64' }
  options { checkoutToSubdirectory(CHECKOUT_DIR) }
  parameters {
      choice(name: 'BUILD_DEVEL', choices: ['none', 'all', 'linux-64', 'win-64', 'osx-64'],
              description: 'Choose a platform to build & test the developer configuration.')
  }
  stages {
    stage('Store git commit') {
      steps {
        script {
          env.GIT_SHA = GIT_COMMIT
        }
        echo "Git SHA is:${env.GIT_SHA}"
      }
    }
    stage('build and test: linux-64') {
      when {
        beforeAgent true
        beforeOptions true
      }
      agent { label 'linux-64' }
      options { timestamps () }
      steps {
        checkoutSource("${GIT_SHA}")
        build_and_run_valgrind()
      }
      post {
        always {
          archive_test_logs()
          publish_test_reports()
        }
      }
    }
    stage ('Copy artifacts') {
      when {
        beforeAgent true
        beforeOptions true
      }
      agent { label 'linux-64' } // Use linux for simplicity with shell scripts
      options {
        timestamps ()
        retry(3)
      }
      steps {
        checkoutSource("${GIT_SHA}")
        // Conda first
        // sh 'rm -fr ${WORKSPACE}/conda-packages'
        copyArtifacts filter: '**/conda-bld/**/*.tar.bz2',
          fingerprintArtifacts: true,
          projectName: '${JOB_NAME}',
          selector: specific('${BUILD_NUMBER}'),
          target: 'conda-packages',
          flatten: true
      }
    }
  }
}

// ------------------- Functions -------------------

def git_branch_name() {
  name = scm.branches[0].name
  // Some jobs define a BRANCH_NAME parameter to allow customisable builds.
  // In this case the value of scm.branches[0].name will literally be
  // $BRANCH_NAME and instead we have to get it from the environment.
  if(name.contains('$BRANCH_NAME')) {
    name = env.BRANCH_NAME
  }
  else if(name.contains("*/")) {
    name = name.split("\\*/")[1]
  }
  return name
}

def checkoutSource(sha) {
  dir(CHECKOUT_DIR) {
    checkout scm: [
      $class: 'GitSCM',
      branches: [[name: sha]],
      extensions: [
        [$class: 'CheckoutOption', timeout: 20],
        [$class: 'CleanCheckout', deleteUntrackedNestedRepositories: true],
        pruneTags(true)
      ]
    ]
  }
}

def build_and_run_valgrind() {
  platform = 'linux-64'
  buildscript_path = "${CISCRIPT_DIR}/conda-buildscript"
  common_args = '--clean-build --clean-external-projects --enable-systemtests'
  cmake_preset = "${platform}-ci"
  doctests = ""
  sh "${buildscript_path} ${WORKSPACE}/${CHECKOUT_DIR} ${cmake_preset} ${common_args} ${doctests}"
}

def publish_test_reports() {
  xunit thresholds: [failed(failureThreshold: '0')],
    tools: [CTest(excludesPattern: '', pattern: "${CHECKOUT_DIR}/build/Testing/**/*.xml", stopProcessingIfError: true)]
  junit "${CHECKOUT_DIR}/build/Testing/SystemTests/scripts/TEST-*.xml"
}

def archive_test_logs(){
  archiveArtifacts artifacts: "${CHECKOUT_DIR}/build/test_logs/*.log", fingerprint: true
}

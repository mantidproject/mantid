// This script expects the following environment variables to be set by the Jenkins job:
// GITHUB_USER_NAME - The name of the user, being used with pushing/pulling from git
// GITHUB_USER_EMAIL - The email of the user, being used with pushing/pulling from git
// GITHUB_TOKEN_CREDENTIAL_ID - The name of the credentials token in Jenkins that you want to use for cloning and pushing to the mantid repo
// ANACONDA_TOKEN_CREDENTIAL_ID - The name of the credentials token in Jenkins that you want to use for publishing conda packages

// Determine default values of parameters. Some are based on the branch.
// ANACONDA_CHANNEL_DEFAULT = 'mantid'
// GITHUB_RELEASES_REPO_DEFAULT = 'mantidproject/mantid'
// The github tag is usually only specified for release candidates. If it's left blank
// a nightly tag is generated.
GITHUB_RELEASES_TAG_DEFAULT = ''
GIT_BRANCH = git_branch_name()
// Only Publish one of main or release-next by default. BRANCH_TO_PUBLISH is a global
// environment variable set in the Jenkins system configuration global properties.
PUBLISH_PACKAGES_DEFAULT = (GIT_BRANCH == "${BRANCH_TO_PUBLISH}")
// Allow the freedom to specify GitHub and Anaconda publishing separately.
PUBLISH_TO_ANACONDA_DEFAULT = PUBLISH_PACKAGES_DEFAULT
PUBLISH_TO_GITHUB_DEFAULT = PUBLISH_PACKAGES_DEFAULT
// If required, switch off the mantiddocs conda package build. This is deliberately not listed in the
// pipeline parameters because it's only switched off for ornl-next anaconda publishing.
BUILD_MANTIDDOCS_PACKAGE = true

switch(GIT_BRANCH) {
  case ['main', 'release-next']:
    PACKAGE_SUFFIX_DEFAULT = 'Nightly'
    ANACONDA_CHANNEL_LABEL_DEFAULT = 'nightly'
    PLATFORM_CHOICES = ['all']
    break
  case ['ornl-next', 'ornl-qa', 'ornl']:
    PACKAGE_SUFFIX_DEFAULT = 'Nightly'
    ANACONDA_CHANNEL_LABEL_DEFAULT = 'nightly'
    PLATFORM_CHOICES = ['linux-64']
    PUBLISH_TO_GITHUB_DEFAULT = false
    PUBLISH_TO_ANACONDA_DEFAULT = true
    ANACONDA_CHANNEL_DEFAULT = 'mantid-ornl'
    BUILD_MANTIDDOCS_PACKAGE = false
    break
  default:
    PACKAGE_SUFFIX_DEFAULT = 'Unstable'
    ANACONDA_CHANNEL_LABEL_DEFAULT = 'unstable'
    PLATFORM_CHOICES = ['none', 'all', 'linux-64', 'win-64', 'osx-64']
    break
}

// conda-build can't copy a local source if the conda-bld directory is
// also part of the source. Checkout to a subdirectory to avoid this.
CHECKOUT_DIR = 'source'
CISCRIPT_DIR = "${CHECKOUT_DIR}/buildconfig/Jenkins/Conda"
pipeline {
  agent none
  options { checkoutToSubdirectory(CHECKOUT_DIR) }
  // parameters {
      // Check these match the PLATFORM matrix values below (without all).
      // choice(name: 'BUILD_DEVEL', choices: PLATFORM_CHOICES,
      //         description: 'Choose a platform to build & test the developer configuration.')
      // choice(name: 'BUILD_PACKAGE', choices: PLATFORM_CHOICES,
      //         description: 'Choose a platform to build just this standalone package')
      // string(name: 'PACKAGE_SUFFIX', defaultValue: PACKAGE_SUFFIX_DEFAULT,
      //        description: 'A string to append to the standalone package name')
      // booleanParam(name: 'PUBLISH_TO_ANACONDA', defaultValue: PUBLISH_TO_ANACONDA_DEFAULT,
      //              description: 'If true, publish the packages to the specified Anaconda channel')
      // booleanParam(name: 'PUBLISH_TO_GITHUB', defaultValue: PUBLISH_TO_GITHUB_DEFAULT,
      //              description: 'If true, publish the packages to GitHub')
      // string(name: 'ANACONDA_CHANNEL', defaultValue: ANACONDA_CHANNEL_DEFAULT,
      //        description: 'The Anaconda channel to accept the package')
      // string(name: 'ANACONDA_CHANNEL_LABEL', defaultValue: ANACONDA_CHANNEL_LABEL_DEFAULT,
      //        description: 'The label attached to package in the Anaconda channel')
      // string(name: 'GITHUB_RELEASES_REPO', defaultValue: GITHUB_RELEASES_REPO_DEFAULT,
      //        description: 'The repository to house the release')
      // string(name: 'GITHUB_RELEASES_TAG', defaultValue: GITHUB_RELEASES_TAG_DEFAULT,
      //        description: 'The name of the tag for the release. Use this only for release candidate builds.')
  // }
  // environment {

  //   // GIT_AUTHOR_NAME = "${GITHUB_USER_NAME}"
  //   // GIT_AUTHOR_EMAIL = "${GITHUB_USER_EMAIL}"
  //   // GIT_COMMITTER_NAME = "${GITHUB_USER_NAME}"
  //   // GIT_COMMITTER_EMAIL = "${GITHUB_USER_EMAIL}"
  // }
  stages {
    // // Fail the pipeline early if any parameters are incorrect.
    // stage('Check parameters') {
    //   agent { label 'linux-64' }
    //   steps {
    //     script {
    //       if(env.PUBLISH_TO_ANACONDA == 'true') {
    //         if(!env.ANACONDA_CHANNEL_LABEL.trim()) {
    //           error("You must specify an Anaconda label to publish packages.")
    //         }
    //         if(!env.ANACONDA_CHANNEL.trim()) {
    //           error("You must specify an Anaconda channel to publish packages.")
    //         }
    //       }
    //     }
    //   }
    // }
    // Store the git commit hash in an environment variable so that we can use
    // the same commit for all stages of the pipeline. This is performed by using
    // the following step at the start of each subsequent stage:
    //   checkout scm: [$class: 'GitSCM', branches: [[name: "${GIT_SHA}"]], extensions: [[pruneTags: true]]]
    stage('Store git commit') {
      agent { label 'linux-64' }
      steps {
        script {
          env.GIT_SHA = GIT_COMMIT
        }
        echo "Git SHA is:${env.GIT_SHA}"
      }
    }
    // Generate the git tag only once to avoid issues where tags are not up to date on
    // certain agents. In particular, this can be a problem when the branch being built
    // is on a fork.
    // stage('Generate git tag') {
    //   agent { label 'linux-64' }
    //   steps {
    //     checkoutSource("${GIT_SHA}")
    //     script {
    //       env.GIT_TAG = generate_git_tag()
    //     }
    //     echo "${env.GIT_TAG}"
    //   }
    // }

    // Verify developer environment build/test while also building conda packages
    // in parallel. Running both steps in parallel reduces the overall pipeline
    // time, however if either part breaks then no publishing occurs.
    stage('Build and test') {
      stage('build and test: linux-64') {
        when {
          beforeAgent true
          beforeOptions true
          //   anyOf {
          //     expression { env.BUILD_DEVEL == 'all' }
          //     expression { env.BUILD_DEVEL == 'linux-64' }
          // }
        }
        agent { label 'linux-64' }
        options { timestamps () }
        steps {
          checkoutSource("${GIT_SHA}")
          build_and_run_valgrind()
        }
        post {
          always {
            archive_test_logs()
            publish_test_reports()
          }
        }
      }
    }
    stage ('Copy artifacts') {
      when {
        beforeAgent true
        beforeOptions true
        // expression { env.PUBLISH_TO_ANACONDA == 'false' }
      }
      agent { label 'linux-64' } // Use linux for simplicity with shell scripts
      options {
        timestamps ()
        retry(3)
      }
      // environment {
      //   ANACONDA_TOKEN = credentials("${ANACONDA_TOKEN_CREDENTIAL_ID}")
      // }
      steps {
        checkoutSource("${GIT_SHA}")
        // Conda first
        // sh 'rm -fr ${WORKSPACE}/conda-packages'
        copyArtifacts filter: '**/conda-bld/**/*.tar.bz2',
          fingerprintArtifacts: true,
          projectName: '${JOB_NAME}',
          selector: specific('${BUILD_NUMBER}'),
          target: 'conda-packages',
          flatten: true
        // Single quotes are required for token variables to avoid them leaking
        // sh "${CISCRIPT_DIR}/publish-to-anaconda ${WORKSPACE}" + ' ${ANACONDA_TOKEN} ' +\
        //   "${ANACONDA_CHANNEL} ${ANACONDA_CHANNEL_LABEL} ${WORKSPACE}/conda-packages/*.tar.bz2"
      }
    }
  }
}

// ------------------- Functions -------------------

def git_branch_name() {
  name = scm.branches[0].name
  // Some jobs define a BRANCH_NAME parameter to allow customisable builds.
  // In this case the value of scm.branches[0].name will literally be
  // $BRANCH_NAME and instead we have to get it from the environment.
  if(name.contains('$BRANCH_NAME')) {
    name = env.BRANCH_NAME
  }
  else if(name.contains("*/")) {
    name = name.split("\\*/")[1]
  }
  return name
}

// def toUnixStylePath(path) {
//   if(!path.startsWith("C:")) {
//     path = "C:" + path
//   }
//   return path.replaceAll("\\\\", "/")
// }

def checkoutSource(sha) {
  dir(CHECKOUT_DIR) {
    checkout scm: [
      $class: 'GitSCM',
      branches: [[name: sha]],
      extensions: [
        [$class: 'CheckoutOption', timeout: 20],
        [$class: 'CleanCheckout', deleteUntrackedNestedRepositories: true],
        pruneTags(true)
      ]
    ]
  }
}

def build_and_run_valgrind() {
  platform = 'linux-64'
  buildscript_path = "${CISCRIPT_DIR}/conda-buildscript"
  common_args = '--clean-build --clean-external-projects --enable-systemtests'
  cmake_preset = "${platform}-ci"
  doctests = ""
  sh "${buildscript_path} ${WORKSPACE}/${CHECKOUT_DIR} ${cmake_preset} ${common_args} ${doctests}"
}

def publish_test_reports() {
  xunit thresholds: [failed(failureThreshold: '0')],
    tools: [CTest(excludesPattern: '', pattern: "${CHECKOUT_DIR}/build/Testing/**/*.xml", stopProcessingIfError: true)]
  junit "${CHECKOUT_DIR}/build/Testing/SystemTests/scripts/TEST-*.xml"
}

// def generate_git_tag() {
//   git_tag = ""
//   if(GITHUB_RELEASES_TAG.trim() != '') {
//     git_tag = "${GITHUB_RELEASES_TAG}"
//   }
//   else {
//     versionscript_path = "${CISCRIPT_DIR}/generate-version-number"
//     if(isUnix()) {
//       git_tag = sh(
//         script: "${versionscript_path}", returnStdout: true
//       ).trim()
//     } else {
//       workspace_unix_style = toUnixStylePath("${WORKSPACE}")
//       // @ suppresses the inclusion of the command itself in the output
//       // https://www.jenkins.io/doc/pipeline/steps/workflow-durable-task-step/#bat-windows-batch-script
//       git_tag = bat(script: "@\"${WIN_BASH}\" -ex -c \"${versionscript_path}\"", returnStdout: true).trim()
//     }
//   }
//   return git_tag
// }

def archive_test_logs(){
  archiveArtifacts artifacts: "${CHECKOUT_DIR}/build/test_logs/*.log", fingerprint: true
}

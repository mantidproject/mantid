#!/usr/bin/env python
# Mantid Repository : https://github.com/mantidproject/mantid
#
# Copyright &copy; 2019 ISIS Rutherford Appleton Laboratory UKRI,
#     NScD Oak Ridge National Laboratory, European Spallation Source
#     & Institut Laue - Langevin
# SPDX - License - Identifier: GPL - 3.0 +
"""
Wraps a call to the sip code generation executable to strip any throw specifications
from the generated code as these have been removed from C++17.
"""
from __future__ import (absolute_import, division, print_function, unicode_literals)

# system imports
import argparse
import logging
import os
import re
import subprocess
import sys

LOG_LEVEL = logging.INFO
EXTENSION = '.cpp'
GENERATED_FILENAME_TEMPLATE = 'sip{modulename:s}part0{extension:s}'
THROW_SPEC_RE = re.compile(r'throw\(.*?\)')


def main(argv):
    """
    Main entry point for the program.

    :param argv: Command-line arguments. The first
    argument is expected to be full path to the sip
    program. Any subsequent arguments are passed
    directly to sip invocation
    """
    configure_logging()
    sip_cmd_line, spec_file, output_dir = parse_arguments(argv)
    logging.debug("Processing specification: {}".format(spec_file))

    run_vanilla_sip(sip_cmd_line)
    generated_module_path = generated_filepath(output_dir, spec_file)
    if not os.path.exists(generated_module_path):
        raise RuntimeError("Unable to find sip-generated module '{}'".format(generated_module_path))
    logging.debug("Found generated module: {}".format(generated_module_path))

    sanitize_generated_module(generated_module_path)
    return 0


def configure_logging():
    """
    Configure the logging framework
    """
    logging.basicConfig(level=LOG_LEVEL)


def parse_arguments(argv):
    """
    Process command-line arguments and extract
    the output directory
    :return: A 4-tuple (sip_cmd, path to spec file, output directory, nparts)
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', dest='output_dir')
    known_args, _ = parser.parse_known_args(argv)
    sip_cmd_line = argv[1:]
    if sys.platform == 'win32':
        sip_cmd_line = list(map(lambda s: s.replace('\\', '\\\\'), sip_cmd_line))
        # the executable may need .exe appending to be run with the cmd
        # processor
        sip_exe = sip_cmd_line[0] + '.exe'
        if os.path.exists(sip_exe):
            sip_cmd_line[0] = sip_exe

    spec_file = argv[-1]

    return sip_cmd_line, spec_file, known_args.output_dir


def run_vanilla_sip(sip_cmd_line):
    """
    Run unmodified sip command to produce the initial .cpp module

    :param sip_cmd: The full sip command as passed to this program
    :raises: RuntimeError if the sip command fails
    """
    logging.debug("Running sip: {}".format(' '.join(sip_cmd_line)))
    retcode = subprocess.call(sip_cmd_line)
    if retcode != 0:
        raise RuntimeError("Error running sip.")


def generated_filepath(output_dir, spec_filename):
    """
    Compute the path of the sip-generated module file.
    :param output_dir: The directory the output has been placed in.
    :param specfile: The original specfilename
    :return: The full path to the generated file
    """
    modulename, _ = os.path.splitext(os.path.basename(spec_filename))
    return os.path.join(
        output_dir, GENERATED_FILENAME_TEMPLATE.format(modulename=modulename, extension=EXTENSION))


def sanitize_generated_module(generated_module_filepath):
    """
    Takes the module code as generated by sip and sanitizes it to be compatible
    with the current standard. It replaces the original file.

    Currently:
      - removes all throw() specifications as they are not supported in C++ 17

    :param generated_module_filepath:
    """
    with open(generated_module_filepath, 'r') as sip_module_orig:
        module_code_orig = sip_module_orig.readlines()

    sanitized_code = []
    for line_orig in module_code_orig:
        sanitized_code.append(THROW_SPEC_RE.sub('', line_orig))

    with open(generated_module_filepath, 'w') as sanitized_module:
        sanitized_module.write(''.join(sanitized_code))


if __name__ == '__main__':
    sys.exit(main(sys.argv))

// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2018 ISIS Rutherford Appleton Laboratory UKRI,
//   NScD Oak Ridge National Laboratory, European Spallation Source,
//   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
// SPDX - License - Identifier: GPL - 3.0 +
//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------

/********** Source = MantidVersion.cpp.in *****************************************************/

#include "MantidKernel/MantidVersion.h"
#include <chrono>
#include <iostream>
#include <sstream>

namespace Mantid::Kernel {

namespace {
const std::string DOI{"http://dx.doi.org/10.1016/j.nima.2014.07.029"};
const std::string VERSION_FULL{"@VERSION_MAJOR@.@VERSION_MINOR@.@VERSION_PATCH@@VERSION_TWEAK@"};
const std::string VERSION_SHORT{"@VERSION_MAJOR@.@VERSION_MINOR@"};
const std::string REVISION_SHORT{"@REVISION_SHORT@"};
const std::string REVISION_FULL{"@REVISION_FULL@"};
const std::string REVISION_DATE{"@REVISION_DATE@"};

/**
 * The input month should only be the first 3 characters of the month name
 */
std::chrono::month to_month(const std::string &month) {
  if (month == "Jan")
    return std::chrono::January;
  else if (month == "Feb")
    return std::chrono::February;
  else if (month == "Mar")
    return std::chrono::March;
  else if (month == "Apr")
    return std::chrono::April;
  else if (month == "May")
    return std::chrono::May;
  else if (month == "Jun")
    return std::chrono::June;
  else if (month == "Jul")
    return std::chrono::July;
  else if (month == "Aug")
    return std::chrono::August;
  else if (month == "Sep")
    return std::chrono::September;
  else if (month == "Oct")
    return std::chrono::October;
  else if (month == "Nov")
    return std::chrono::November;
  else if (month == "Dec")
    return std::chrono::December;
  else // should never get here
    throw std::runtime_error("Cannot convert \"" + month + "\" to a month object");
}
} // namespace

/**
 * See buildconfig/CMake/VersionNumber.cmake for more information on the meaning
 * of the version number elements
 */

std::string MantidVersion::version() { return VERSION_FULL; }

std::string MantidVersion::versionShort() { return VERSION_SHORT; }

const MantidVersion::VersionInfo MantidVersion::versionInfo() {
  return {"@VERSION_MAJOR@", "@VERSION_MINOR@", "@VERSION_PATCH@", "@VERSION_TWEAK@"};
}

std::string MantidVersion::versionForReleaseNotes(const VersionInfo &version) {
  // Convert here in those cases where patch number is of the form "20131022.1356".
  const unsigned long patchVersion = std::stoul(version.patch);
  // For major/minor/patch/rc/local releases we point users to a specific release-notes.
  // For dev and nightly versions we point to the next main release notes.
  // We assume that the next main release version number will be one minor version higher.

  std::stringstream versionLabel;

  if ((patchVersion < 100 && version.tweak.empty()) || version.tweak[0] == '+' || version.tweak.substr(0, 2) == "rc") {
    versionLabel << version.major << "." << version.minor;
    versionLabel << "." << patchVersion;
  } else {
    const unsigned long minorVersion = std::stoul(version.minor);
    versionLabel << version.major << "." << minorVersion + 1 << "." << "0";
  }

  return versionLabel.str();
}

std::string MantidVersion::releaseNotes() {
  const std::string STEM = "release/v";
  const std::string END = "/index.html";

  std::stringstream url;

  url << STEM << versionForReleaseNotes(versionInfo()) << END;

  return url.str();
}

std::string MantidVersion::revision() { return REVISION_SHORT; }

std::string MantidVersion::revisionFull() { return REVISION_FULL; }

Types::Core::DateAndTime MantidVersion::releaseDateAndTime() {
  if (REVISION_DATE == "UNKNOWN") {
    // something went wrong in VersionNumber.cmake so give the default constructor result
    Types::Core::DateAndTime release;
    return release;
  } else {
    // pull apart string into year, month, and day objects
    // WARNING if the format changes this will break
    const auto day = std::chrono::day(std::stoi(REVISION_DATE.substr(4, 2)));
    const auto month = to_month(REVISION_DATE.substr(7, 3));
    const auto year = std::chrono::year(std::stoi(REVISION_DATE.substr(11, 4)));
    std::string time = REVISION_DATE.substr(16);
    if (time.empty()) {
      time = "00:01"; // assume one minute past midnight
    } else {
      time.erase(find_if(time.begin(), time.end(), isspace));
    }

    // create a proper chrono from it
    std::chrono::year_month_day ymd(year, month, day);
    // convert to iso8601 string to get to DateAndTime
    std::stringstream isostr;
    isostr << ymd << "T" << time;

    Types::Core::DateAndTime release(isostr.str());
    return release;
  }
}

std::string MantidVersion::releaseDate() {
  const std::string GIT_DATE_FMT("%a, %e %b %Y");
  const auto release = releaseDateAndTime();
  return release.toFormattedString(GIT_DATE_FMT);
}

std::string MantidVersion::doi() {
  const std::string MAIN = "http://dx.doi.org/10.5286/Software/Mantid";
  // Cast here in those cases where patch number is of the form 20131022.1356.
  const unsigned int patchVersion = static_cast<unsigned int>(@VERSION_PATCH @);

  // For major/minor/patch releases we point users to a specific release-notes DOI, for
  // dev versions we just point to the main DOI.  A simple way to see whether or not
  // we're currently in a dev version is to check if the patch version is larger than
  // some arbitrarily low value.
  const std::string tweakVersion("@VERSION_TWEAK@");
  if (patchVersion > 100 || !tweakVersion.empty())
    return MAIN;

  std::stringstream doi;
  doi << MAIN << @VERSION_MAJOR @ << "." << @VERSION_MINOR @;

  // Keep to the convention where we write a version number like "3.0.0" as "3.0".
  if (patchVersion != 0)
    doi << "." << patchVersion;

  return doi.str();
}

std::string MantidVersion::paperCitation() { return DOI; }

} // namespace Mantid::Kernel

// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2018 ISIS Rutherford Appleton Laboratory UKRI,
//   NScD Oak Ridge National Laboratory, European Spallation Source,
//   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
// SPDX - License - Identifier: GPL - 3.0 +
#pragma once

#include <cxxtest/TestSuite.h>

#include "MantidLiveData/ADARA/ADARAParser.h"
#include <Poco/AutoPtr.h>
#include <Poco/DOM/DOMParser.h> // for parsing the XML device descriptions
#include <Poco/DOM/Document.h>
#include <memory>

// All of the sample packets that we need to run the tests are defined in the following header.
// The packets can get pretty long, which is why I didn't want them cluttering up this file.
#include "ADARAPackets.h"

class ADARAPacketTest : public CxxTest::TestSuite, ADARA::Parser {
public:
  // This pair of boilerplate methods prevent the suite being created statically
  // This means the constructor isn't called when running other tests
  static ADARAPacketTest *createSuite() { return new ADARAPacketTest(); }
  static void destroySuite(ADARAPacketTest *suite) { delete suite; }

  /*
   * The following packets are generated by the "Detector System", not the "Stream Management Service".
   * As a result, they'll never be parsed by Mantid's ADARA parser, and therefore we don't test them.
   *
   *   RawDataPkt
   *   MappedDataPkt
   *   RTDLPkt
   *   SourceListPkt
   */

  ADARAPacketTest()
      : ADARA::Parser(1024 * 1024, 1024 * 1024)
  // set the initial buffer size equal to the max packet size.  This should
  // ensure that the parser will
  // never resize its buffer.  See below for why this is important
  {
    // We know the parser's buffer is empty now, and we've ensured that the address will never change.
    // Thus, we can verify that the buffer is empty at any time in the future
    // by calling bufferFillAddress() and comparing it to this value.
    m_initialBufferAddr = bufferFillAddress();
  }

  void testPacketCast() {
    const unsigned char data[8] = {0xd4, 0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80};

    uint32_t result = packetCast<uint32_t>(data, 1, 4);
    TS_ASSERT_EQUALS(result, 0x00000248)

    // First 4 bytes should give 0x000248d4
    uint32_t result2 = packetCast<uint32_t>(data, 0, 4);
    TS_ASSERT_EQUALS(result2, 0x000248d4)

    // Test with shorter types
    uint16_t result3 = packetCast<uint16_t>(data, 1, 2);
    TS_ASSERT_EQUALS(result3, 0x0248)

    // Test with a single byte
    uint8_t result4 = packetCast<uint8_t>(data, 0, 1);
    TS_ASSERT_EQUALS(result4, 0xd4)

    // Test with offset at the end
    uint16_t result5 = packetCast<uint16_t>(data, 6, 2);
    TS_ASSERT_EQUALS(result5, 0x8000)
  }

  void testBankedEventPacketV0Parser() {
    std::shared_ptr<ADARA::BankedEventPkt> pkt =
        basicPacketTests<ADARA::BankedEventPkt>(bankedEventPacketV0, sizeof(bankedEventPacketV0), 728504567, 761741666);
    if (pkt != nullptr) {
      TS_ASSERT_EQUALS(pkt->cycle(), 0x3C)
      TS_ASSERT_EQUALS(pkt->pulseCharge(), 1549703)
      TS_ASSERT_EQUALS(pkt->pulseEnergy(), 937987556)
      TS_ASSERT_EQUALS(pkt->flags(), 0)

      const ADARA::Event *event = pkt->firstEvent();
      TS_ASSERT(event);
      if (event) {
        TS_ASSERT_EQUALS(pkt->curBankId(), 0x02)
        TS_ASSERT_EQUALS(event->tof, 0x00023BD9)
        TS_ASSERT_EQUALS(event->pixel, 0x043C)
      }

      // This packet only has one event in its first bank, so fetch the
      // next event and verify the bank id
      event = pkt->nextEvent();
      TS_ASSERT(event)
      if (event) {
        TS_ASSERT_EQUALS(pkt->curBankId(), 0x13)
      }

      // There's also only one event in it's second (and last) bank.
      // Get the next event and verify it's null
      event = pkt->nextEvent();
      TS_ASSERT(!event)
    }
  }

  void testBankedEventPacketV1Parser() {
    std::shared_ptr<ADARA::BankedEventPkt> pkt = basicPacketTests<ADARA::BankedEventPkt>(
        bankedEventPacketV1, sizeof(bankedEventPacketV1), 1117010879, 984510667);

    // Returns a uint32_t value extracted from the packet at the given start offset (4 bytes)
    auto expectedAt = [&](uint32_t start) { return packetCast<uint32_t>(bankedEventPacketV1, start, 4); };

    if (pkt != nullptr) {
      // test packet header and some of the payload
      TS_ASSERT_EQUALS(pkt->pulseCharge(), expectedAt(16))
      TS_ASSERT_EQUALS(pkt->pulseEnergy(), expectedAt(20))
      TS_ASSERT_EQUALS(pkt->cycle(), expectedAt(24))
      TS_ASSERT_EQUALS(pkt->flags(), expectedAt(28) & 0xFFFFF)
      TS_ASSERT_EQUALS(pkt->vetoFlags(), (expectedAt(28) >> 20) & 0xFFF)
      // inspect the first Source Section
      const ADARA::Event *event = pkt->firstEvent();
      TS_ASSERT(event)
      TS_ASSERT_EQUALS(pkt->getSourceCORFlag(), false)
      TS_ASSERT_EQUALS(pkt->getSourceTOFOffset(), 0x00000000)
      TS_ASSERT_EQUALS(pkt->curBankId(), expectedAt(48))
      TS_ASSERT_EQUALS(pkt->curEventCount(), expectedAt(52))
      TS_ASSERT_EQUALS(event->tof, expectedAt(56))
      TS_ASSERT_EQUALS(event->pixel, expectedAt(60))

      // Advance to the last event of the first bank. There are 18 events in the first bank
      for (uint32_t i = 1; i < pkt->curEventCount(); ++i) {
        event = pkt->nextEvent();
        TS_ASSERT_EQUALS(pkt->curBankId(), expectedAt(48)) // still in the first bank
        TS_ASSERT_EQUALS(event->tof, expectedAt(56 + i * 8))
        TS_ASSERT_EQUALS(event->pixel, expectedAt(60 + i * 8))
      }
      // Advance to the first event of the second bank
      event = pkt->nextEvent();
      TS_ASSERT(event)
      TS_ASSERT_EQUALS(pkt->curBankId(), expectedAt(200))
      TS_ASSERT_EQUALS(pkt->curEventCount(), expectedAt(204))
      TS_ASSERT_EQUALS(event->tof, expectedAt(208))
      TS_ASSERT_EQUALS(event->pixel, expectedAt(212))
    }
  }

  void testBeamMonitorPacketv0Parser() {
    std::shared_ptr<ADARA::BeamMonitorPkt> pkt =
        basicPacketTests<ADARA::BeamMonitorPkt>(beamMonitorPacketV0, sizeof(beamMonitorPacketV0), 728504567, 761741666);
    if (pkt != nullptr) {
      TS_ASSERT_EQUALS(pkt->cycle(), 0x3c);
      TS_ASSERT_EQUALS(pkt->flags(), 0);
      TS_ASSERT_EQUALS(pkt->pulseCharge(), 1549703);
      TS_ASSERT_EQUALS(pkt->pulseEnergy(), 937987556);
      // TODO: Find a different Beam Monitor Packet with actual monitor sections
      // in it
    }
  }

  void testBeamMonitorPacketv1Parser() {
    std::shared_ptr<ADARA::BeamMonitorPkt> pkt = basicPacketTests<ADARA::BeamMonitorPkt>(
        beamMonitorPacketV1, sizeof(beamMonitorPacketV1), 1117010871, 517706667);
    auto expectedAt = [&](uint32_t start) { return packetCast<uint32_t>(beamMonitorPacketV1, start, 4); };
    TS_ASSERT_EQUALS(pkt->payload_length(), 136 - 16) // 136 bytes total minus 16 bytes for the header
    TS_ASSERT_EQUALS(pkt->pulseCharge(), expectedAt(16))
    TS_ASSERT_EQUALS(pkt->pulseEnergy(), expectedAt(20))
    TS_ASSERT_EQUALS(pkt->cycle(), expectedAt(24))
    TS_ASSERT_EQUALS(pkt->flags(), ADARA::PARTIAL_DATA | ADARA::GOT_METADATA | ADARA::GOT_NEUTRONS)
    // Look into the first section
    TS_ASSERT(pkt->nextSection())
    TS_ASSERT_EQUALS(pkt->getSectionEventCount(), expectedAt(32) & 0x003FFFFF) // lower 22 bits
    TS_ASSERT_EQUALS(pkt->getSectionMonitorID(), expectedAt(32) >> 22)         // upper 10 bits
    TS_ASSERT_EQUALS(pkt->getSectionSourceID(), expectedAt(36))
    TS_ASSERT_EQUALS(pkt->getSectionTOFOffset(), expectedAt(40) & 0x7FFFFFFF)        // mask off the high bit
    TS_ASSERT_EQUALS(pkt->sectionTOFCorrected(), (expectedAt(40) & 0x80000000) != 0) // only want the high bit
    // Look into the first event of the first section
    bool risingEdge;
    uint32_t cycle;
    uint32_t tof;
    pkt->nextEvent(risingEdge, cycle, tof);
    TS_ASSERT_EQUALS(tof, expectedAt(44) & 0x001FFFFF)               // bits 20 to 0 (inclusive)
    TS_ASSERT_EQUALS(cycle, (expectedAt(44) & 0x7FE00000) >> 21)     // bits 30 to 21 (inclusive)
    TS_ASSERT_EQUALS(risingEdge, (expectedAt(44) & 0x80000000) != 0) // only want the high bit
    // There are 23 events in the first section, thus 44 + 23 * 4 = 136.
    // This packet has a total of 136 bytes, so there can't be another section.
    TS_ASSERT(!pkt->nextSection())
  }

  /*******************************************
   *   Pixel Mapping Table Alternate Packets
   *******************************************/

  void testPixelMappingAltPktParserV0() {
    std::shared_ptr<ADARA::PixelMappingAltPkt> pkt = basicPacketTests<ADARA::PixelMappingAltPkt>(
        pixelMappingAltPktV0, sizeof(pixelMappingAltPktV0), 1112961350, 706131261);
    TS_ASSERT_EQUALS(pkt->numBanks(), 1)
  }

  void testPixelMappingAltPktParserV1direct() {
    std::shared_ptr<ADARA::PixelMappingAltPkt> pkt = basicPacketTests<ADARA::PixelMappingAltPkt>(
        pixelMappingAltPktV1direct, sizeof(pixelMappingAltPktV1direct), 1112961350, 706131261);
    TS_ASSERT_EQUALS(pkt->numBanks(), 1)
  }

  void testPixelMappingAltPktParserV1shorthand() {
    std::shared_ptr<ADARA::PixelMappingAltPkt> pkt = basicPacketTests<ADARA::PixelMappingAltPkt>(
        pixelMappingAltPktV1shorthand, sizeof(pixelMappingAltPktV1shorthand), 1112961350, 706131261);
    TS_ASSERT_EQUALS(pkt->numBanks(), 1)
  }

  /************************
   *   RUN STATUS Packets
   ************************/

  void testRunStatusPacketParserV0() {
    std::shared_ptr<ADARA::RunStatusPkt> pkt =
        basicPacketTests<ADARA::RunStatusPkt>(runStatusPacketV0, sizeof(runStatusPacketV0), 728504568, 5625794);

    if (pkt != nullptr) {
      TS_ASSERT_EQUALS(pkt->runNumber(), 13247);
      TS_ASSERT_EQUALS(pkt->runStart(), 728503297);
      TS_ASSERT_EQUALS(pkt->status(), ADARA::RunStatus::STATE);

      // TODO: Find a different RunStatus packet who's status is NOT STATE, then
      // check
      // its file number
      // TS_ASSERT_EQUALS( pkt->fileNumber(), ?????);
    }
  }

  void testRunStatusPacketParserV1() {

    // helper function to call on packets having different run status types
    auto testRunStatusPacket = [&](const unsigned char *packetData, unsigned int packetSize, uint32_t expectedPulseId,
                                   uint32_t expectedId, ADARA::RunStatus::Enum expectedStatus) {
      std::shared_ptr<ADARA::RunStatusPkt> pkt =
          basicPacketTests<ADARA::RunStatusPkt>(packetData, packetSize, expectedPulseId, expectedId);

      std::function<uint32_t(uint32_t)> expectedAt = [&](uint32_t start) {
        return packetCast<uint32_t>(packetData, start, 4);
      };

      TS_ASSERT_EQUALS(pkt->runNumber(), expectedAt(16))
      TS_ASSERT_EQUALS(pkt->runStart(), expectedAt(20))
      TS_ASSERT_EQUALS(pkt->status(), expectedStatus)
      TS_ASSERT_EQUALS(pkt->fileNumber(), expectedAt(24) & 0xFFFFFF) // lower 24 bits
    };

    testRunStatusPacket(runStatusPacketV1NoRun, sizeof(runStatusPacketV1NoRun), 1117010859, 421225535,
                        ADARA::RunStatus::NO_RUN);
    testRunStatusPacket(runStatusPacketV1NewRun, sizeof(runStatusPacketV1NewRun), 1117010897, 11143026,
                        ADARA::RunStatus::NEW_RUN);
    testRunStatusPacket(runStatusPacketV1RunEOF, sizeof(runStatusPacketV1RunEOF), 1117010900, 37361961,
                        ADARA::RunStatus::RUN_EOF);
    testRunStatusPacket(runStatusPacketV1RunBOF, sizeof(runStatusPacketV1RunBOF), 1117010897, 17020018,
                        ADARA::RunStatus::RUN_BOF);
    testRunStatusPacket(runStatusPacketV1EndRun, sizeof(runStatusPacketV1EndRun), 1117041153, 518160111,
                        ADARA::RunStatus::END_RUN);
  }

  /************************
   *   Run Info Packets
   ************************/

  void testRunInfoPacketParserV0() {
    std::shared_ptr<ADARA::RunInfoPkt> pkt =
        basicPacketTests<ADARA::RunInfoPkt>(runInfoPacketV0, sizeof(runInfoPacketV0), 1117010859, 421225535);
    const std::string expected = R"(<?xml version="1.0" encoding="UTF-8"?>
<root>Power to Run Info!</root>)";
    std::string result = pkt->info();
    // remove the null terminators from the end of the string,
    size_t nullPos = result.find_first_of('\0');
    if (nullPos != std::string::npos) {
      result.resize(nullPos);
    }
    TS_ASSERT_EQUALS(result, expected)
  }

  /**********************************
   *   Translation Complete Packets
   *********************************/

  void testTranslationCompletePacketParserV0() {
    std::shared_ptr<ADARA::TransCompletePkt> pkt = basicPacketTests<ADARA::TransCompletePkt>(
        translationCompletePacketV0, sizeof(translationCompletePacketV0), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->reason().c_str(), std::string("the meaning of the Universe"))
    // DEBUG: this assertion fails
    // TS_ASSERT_EQUALS(pkt->status(), 42)
  }

  /*************************
   *   Client Hello Packets
   *************************/

  void testClientHelloPacketParserV0() {
    std::shared_ptr<ADARA::ClientHelloPkt> pkt = basicPacketTests<ADARA::ClientHelloPkt>(
        clientHelloPacketV0, sizeof(clientHelloPacketV0), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->requestedStartTime(), 42)
  }

  void testClientHelloPacketParserV1() {
    std::shared_ptr<ADARA::ClientHelloPkt> pkt = basicPacketTests<ADARA::ClientHelloPkt>(
        clientHelloPacketV1, sizeof(clientHelloPacketV1), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->requestedStartTime(), 42)
    TS_ASSERT_EQUALS(pkt->clientFlags(), ADARA::ClientHelloPkt::Flags::SEND_PAUSE_DATA)
  }

  /***********************
   *   Heartbeat Packets
   **********************/

  void testHeartbeatPacketParserV0() {
    std::shared_ptr<ADARA::HeartbeatPkt> pkt =
        basicPacketTests<ADARA::HeartbeatPkt>(heartbeatPacketV0, sizeof(heartbeatPacketV0), 1117010859, 421225535);
    TS_ASSERT(pkt)
  }

  /**********************
   *   Geometry Packets
   *********************/

  void testGeometryPacketParserV0() {
    std::shared_ptr<ADARA::GeometryPkt> pkt =
        basicPacketTests<ADARA::GeometryPkt>(geometryPacketV0, sizeof(geometryPacketV0), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->info().c_str(),
                     std::string("<?xml version='1.0' encoding='ASCII'?>\n<instrument>VACUO</instrument>"))
  }

  /***************************
   *   Beamline Info Packets
   **************************/

  void testBeamlineInfoPacketParserV0() {
    std::shared_ptr<ADARA::BeamlineInfoPkt> pkt = basicPacketTests<ADARA::BeamlineInfoPkt>(
        beamlineInfoPacketV0, sizeof(beamlineInfoPacketV0), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->id(), "42")
    TS_ASSERT_EQUALS(pkt->shortName(), "CG3")
    TS_ASSERT_EQUALS(pkt->longName(), "BIOSANS")
  }

  void testBeamlineInfoPacketParserV1() {
    std::shared_ptr<ADARA::BeamlineInfoPkt> pkt = basicPacketTests<ADARA::BeamlineInfoPkt>(
        beamlineInfoPacketV1, sizeof(beamlineInfoPacketV1), 1117010859, 421225535);
    TS_ASSERT_EQUALS(pkt->targetStationNumber(), 2)
    TS_ASSERT_EQUALS(pkt->id(), "42")
    TS_ASSERT_EQUALS(pkt->shortName(), "CG3")
    TS_ASSERT_EQUALS(pkt->longName(), "BIOSANS")
  }

  /********************************
   *   Detector Bank Sets Packets
   *******************************/

  void testDectectorBankSetPacketParserV0() {
    std::shared_ptr<ADARA::DetectorBankSetsPkt> pkt = basicPacketTests<ADARA::DetectorBankSetsPkt>(
        detectorBankSetPacketV0, sizeof(detectorBankSetPacketV0), 1117010859, 421225535);
    TS_ASSERT(pkt)
    TS_ASSERT_EQUALS(pkt->detBankSetCount(), 1)
    TS_ASSERT_EQUALS(pkt->name(0), "front row")
    TS_ASSERT_EQUALS(pkt->flags(0), 1)
    TS_ASSERT_EQUALS(pkt->bankCount(0), 3)
    TS_ASSERT_EQUALS(pkt->tofOffset(0), 420)
    TS_ASSERT_EQUALS(pkt->tofMax(0), 16667)
    TS_ASSERT_EQUALS(pkt->tofBin(0), 10)
    TS_ASSERT_EQUALS(pkt->throttle(0), 0.0)
    TS_ASSERT_EQUALS(pkt->suffix(0), "throttled")
  }

  /***********************
   *   Data Done Packets
   **********************/

  void testDataDonePacketParserV0() {
    std::shared_ptr<ADARA::DataDonePkt> pkt =
        basicPacketTests<ADARA::DataDonePkt>(dataDonePacketV0, sizeof(dataDonePacketV0), 1117010859, 421225535);
    TS_ASSERT(pkt)
  }

  /************************
   *   RTDL Packets
   ************************/

  void testRTDLPacketParserV0() {
    std::shared_ptr<ADARA::RTDLPkt> pkt =
        basicPacketTests<ADARA::RTDLPkt>(rtdlPacketV0, sizeof(rtdlPacketV0), 728504567, 761741666);

    if (pkt != nullptr) {
      TS_ASSERT_EQUALS(pkt->cycle(), 60);
      TS_ASSERT_EQUALS(pkt->vetoFlags(), 0x4);
      TS_ASSERT_EQUALS(pkt->badVeto(), false);
      TS_ASSERT_EQUALS(pkt->timingStatus(), 0x1e);
      TS_ASSERT_EQUALS(pkt->flavor(), 1);
      TS_ASSERT_EQUALS(pkt->intraPulseTime(), 166662);
      TS_ASSERT_EQUALS(pkt->tofOffset(), 63112);
      TS_ASSERT_EQUALS(pkt->pulseCharge(), 1549703);
      TS_ASSERT_EQUALS(pkt->ringPeriod(), 955259);
    }
  }

  void testRTDLPacketParserV1() {
    std::shared_ptr<ADARA::RTDLPkt> pkt =
        basicPacketTests<ADARA::RTDLPkt>(rtdlPacketV1, sizeof(rtdlPacketV1), 728504567, 761741666);
    auto expectedAt = [&](uint32_t start) { return packetCast<uint32_t>(rtdlPacketV1, start, 4); };

    uint32_t quadByte = expectedAt(16);
    TS_ASSERT_EQUALS(pkt->gotDataFlags(), true)                 // bit index 31
    TS_ASSERT_EQUALS(pkt->dataFlags(), (quadByte >> 27) & 0x1f) // bit indexes 27 to 31
    TS_ASSERT_EQUALS(pkt->flavor(), ADARA::PulseFlavor::NORMAL)
    TS_ASSERT_EQUALS(pkt->pulseCharge(), quadByte & 0x00ffffff) // bit indexes 0 to 23

    quadByte = expectedAt(20);
    TS_ASSERT_EQUALS(pkt->badVeto(), (bool)(quadByte & 0x80000000))          // bit index 31
    TS_ASSERT_EQUALS(pkt->badCycle(), (bool)(quadByte & 0x40000000))         // bit index 30
    TS_ASSERT_EQUALS(pkt->timingStatus(), (uint8_t)(quadByte >> 22))         // bit indexes 22 to 29
    TS_ASSERT_EQUALS(pkt->vetoFlags(), (uint16_t)((quadByte >> 10) & 0xfff)) // bit indexes 10 to 21
    TS_ASSERT_EQUALS(pkt->cycle(), (uint16_t)(quadByte & 0x3ff))

    TS_ASSERT_EQUALS(pkt->intraPulseTime(), expectedAt(24))
    TS_ASSERT_EQUALS(pkt->tofCorrected(), (bool)(expectedAt(28) & 0x80000000)) // bit index 31
    TS_ASSERT_EQUALS(pkt->tofOffset(), expectedAt(28) & 0x7fffffff);           // mask off the high bit
    TS_ASSERT_EQUALS(pkt->ringPeriod(), expectedAt(32) & 0xffffff);            // bit indexes 0 to 23

    TS_ASSERT_EQUALS(pkt->FNA(0), (expectedAt(36) >> 24) & 0xff)      // bit indexes 0 to 23
    TS_ASSERT_EQUALS(pkt->frameData(0), expectedAt(36) & 0xffffff);   // bit indexes 24 to 31
    TS_ASSERT_EQUALS(pkt->FNA(24), (expectedAt(132) >> 24) & 0xff)    // bit indexes 0 to 23
    TS_ASSERT_EQUALS(pkt->frameData(24), expectedAt(132) & 0xffffff); // bit indexes 24 to 31
  }

  /************************
   *   SYNC Packets
   *   (there's only version 0)
   ************************/

  // DEBUG: This test is failing
  void testSyncPacketParser() {
    std::shared_ptr<ADARA::SyncPkt> pkt =
        basicPacketTests<ADARA::SyncPkt>(syncPacket, sizeof(syncPacket), 728504568, 5617153);
    auto x = pkt->signature();
    TS_ASSERT_EQUALS(pkt->signature().c_str(), std::string("SNSADARAORNL"))
    TS_ASSERT_EQUALS(pkt->fileOffset(), 42)
    TS_ASSERT_EQUALS(pkt->comment().length(), 0) // empty comment
  }

  /******************************
   *   STREAM ANNOTATION Packets
   *   (there's only version 0)
   ********************************/

  void testAnnotationPacketParser() {

    std::shared_ptr<ADARA::AnnotationPkt> pkt = basicPacketTests<ADARA::AnnotationPkt>(
        AnnotationPacketType0, sizeof(AnnotationPacketType0), 1117010897, 8968804);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::GENERIC)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 0)
    TS_ASSERT_EQUALS(pkt->comment(), "Run 44635 Started.")

    pkt = basicPacketTests<ADARA::AnnotationPkt>(AnnotationPacketType1, sizeof(AnnotationPacketType1), 1117010982,
                                                 114515313);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::SCAN_START)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 2)
    TS_ASSERT_EQUALS(pkt->comment(), "[Run 44635] Scan #2 Started.")

    pkt = basicPacketTests<ADARA::AnnotationPkt>(AnnotationPacketType2, sizeof(AnnotationPacketType2), 1117011060,
                                                 417136782);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::SCAN_STOP)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 2)
    TS_ASSERT_EQUALS(pkt->comment(), "[Run 44635] Scan #2 Stopped.")

    pkt = basicPacketTests<ADARA::AnnotationPkt>(AnnotationPacketType3, sizeof(AnnotationPacketType3), 1117010897,
                                                 14178350);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::PAUSE)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 0)
    TS_ASSERT_EQUALS(pkt->comment(), "Run 44635 Paused.")

    pkt = basicPacketTests<ADARA::AnnotationPkt>(AnnotationPacketType4, sizeof(AnnotationPacketType4), 1117010897,
                                                 16250000);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::RESUME)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 0)
    TS_ASSERT_EQUALS(pkt->comment(), "Run 44635 Resumed.")

    pkt = basicPacketTests<ADARA::AnnotationPkt>(AnnotationPacketType5, sizeof(AnnotationPacketType5), 1117010859,
                                                 418887449);
    TS_ASSERT_EQUALS(pkt->marker_type(), ADARA::MarkerType::OVERALL_RUN_COMMENT)
    TS_ASSERT_EQUALS(pkt->scanIndex(), 0)
    TS_ASSERT_EQUALS(pkt->comment(), "(unset)")
  }

  /******************************
   *   VARIABLE VALUE Packets
   *   (there's only version 0)
   ********************************/

  void testVariableU32PacketParser() {
    std::shared_ptr<ADARA::VariableU32Pkt> pkt =
        basicPacketTests<ADARA::VariableU32Pkt>(variableU32Packet, sizeof(variableU32Packet), 728281149, 0);
    TS_ASSERT_EQUALS(pkt->devId(), 2)
    TS_ASSERT_EQUALS(pkt->varId(), 3)
    TS_ASSERT_EQUALS(pkt->status(), 0)
    TS_ASSERT_EQUALS(pkt->severity(), 0)
    TS_ASSERT_EQUALS(pkt->value(), 3)
  }

  void testVariableDoublePacketParser() {
    std::shared_ptr<ADARA::VariableDoublePkt> pkt =
        basicPacketTests<ADARA::VariableDoublePkt>(variableDoublePacket, sizeof(variableDoublePacket), 728281149, 0);
    TS_ASSERT_EQUALS(pkt->devId(), 2)
    TS_ASSERT_EQUALS(pkt->varId(), 1)
    TS_ASSERT_EQUALS(pkt->status(), 0)
    TS_ASSERT_EQUALS(pkt->severity(), 0)
    TS_ASSERT_DELTA(pkt->value(), 5.0015, 1e-8)
  }

  void testVariableStringPacketParser() {
    std::shared_ptr<ADARA::VariableStringPkt> pkt = basicPacketTests<ADARA::VariableStringPkt>(
        variableStringPacketValue1, sizeof(variableStringPacketValue1), 1116514626, 726460216);
    TS_ASSERT_EQUALS(pkt->devId(), 17)
    TS_ASSERT_EQUALS(pkt->varId(), 3)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->value(), "N/A")

    pkt = basicPacketTests<ADARA::VariableStringPkt>(variableStringPacketValue2, sizeof(variableStringPacketValue2),
                                                     1116514626, 726434341);
    TS_ASSERT_EQUALS(pkt->devId(), 17)
    TS_ASSERT_EQUALS(pkt->varId(), 2)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->value(), "No sample")

    pkt = basicPacketTests<ADARA::VariableStringPkt>(variableStringPacketValue3, sizeof(variableStringPacketValue3),
                                                     1112954908, 544477614);
    TS_ASSERT_EQUALS(pkt->devId(), 7)
    TS_ASSERT_EQUALS(pkt->varId(), 1)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->value(), "'SampleTemp', 'SampleTempSelect', 'MagneticField', 'MagneticFieldSelector', "
                                   "'sequence_id', 'sequence_number', 'sequence_total', 'SF1', 'SF2'")
  }

  // DEBUG: this test is failing
  void testVariableU32ArrayPacketParser() {
    std::shared_ptr<ADARA::VariableU32ArrayPkt> pkt = basicPacketTests<ADARA::VariableU32ArrayPkt>(
        variableU32ArrayPacket, sizeof(variableU32ArrayPacket), 728281149, 0);
    TS_ASSERT_EQUALS(pkt->devId(), 2)
    TS_ASSERT_EQUALS(pkt->varId(), 3)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->elemCount(), 4)
    TS_ASSERT_EQUALS(pkt->value(), std::vector<uint32_t>({6, 7, 8, 9}))
  }

  // DEBUG: this test is failing
  void testVariableDoubleArrayPacketParser() {
    std::shared_ptr<ADARA::VariableDoubleArrayPkt> pkt = basicPacketTests<ADARA::VariableDoubleArrayPkt>(
        variableDoubleArrayPacket, sizeof(variableDoubleArrayPacket), 728281149, 0);
    TS_ASSERT_EQUALS(pkt->devId(), 2)
    TS_ASSERT_EQUALS(pkt->varId(), 1)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->elemCount(), 2)
    for (size_t i = 0; i < pkt->elemCount(); i++)
      TS_ASSERT_DELTA(pkt->value()[i], static_cast<double>(i) + 8.0, 1.e-8)
  }

  void testMultVariableU32PacketParser() {
    std::shared_ptr<ADARA::MultVariableU32Pkt> pkt = basicPacketTests<ADARA::MultVariableU32Pkt>(
        multVariableU32Packet, sizeof(multVariableU32Packet), 1117010982, 102843667);
    TS_ASSERT_EQUALS(pkt->devId(), 1)
    TS_ASSERT_EQUALS(pkt->varId(), 11)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->numValues(), 16)
    std::vector<uint32_t> tofs = {17067500, 22171400, 22172800, 22203900, 22207000, 22237400, 22240900, 22255100,
                                  22260900, 22270700, 22278400, 22287600, 22297700, 22303500, 22314900, 22319400};
    std::vector<uint32_t> values = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    for (size_t i = 0; i < pkt->numValues(); i++) {
      TS_ASSERT_EQUALS(pkt->tofs()[i], tofs[i])
      TS_ASSERT_EQUALS(pkt->values()[i], values[i])
    }
  }

  void testMultVariableDoublePacketParser() {
    std::shared_ptr<ADARA::MultVariableDoublePkt> pkt = basicPacketTests<ADARA::MultVariableDoublePkt>(
        multVariableDoublePacket, sizeof(multVariableDoublePacket), 1117010982, 102843667);
    TS_ASSERT_EQUALS(pkt->devId(), 1)
    TS_ASSERT_EQUALS(pkt->varId(), 11)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->numValues(), 8)
    std::vector<uint32_t> tofs = {17067500, 22171400, 22172800, 22203900, 22207000, 22237400, 22240900, 22255100};
    std::vector<double> values_expected = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};
    for (size_t i = 0; i < pkt->numValues(); i++) {
      TS_ASSERT_EQUALS(pkt->tofs()[i], tofs[i])
      TS_ASSERT_DELTA(pkt->values()[i], values_expected[i], 1.e-8)
    }
  }

  void testMultVariableStringPacketParser() {
    std::shared_ptr<ADARA::MultVariableStringPkt> pkt = basicPacketTests<ADARA::MultVariableStringPkt>(
        multVariableStringPacket, sizeof(multVariableStringPacket), 1117010982, 102843667);
    TS_ASSERT_EQUALS(pkt->devId(), 1)
    TS_ASSERT_EQUALS(pkt->varId(), 11)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->numValues(), 3)
    std::vector<uint32_t> tofs = {17067500, 22171400, 22172800, 22203900, 22207000, 22237400, 22240900, 22255100};
    std::vector<std::string> values = {"one", "two", "three"};
    for (size_t i = 0; i < pkt->numValues(); i++) {
      TS_ASSERT_EQUALS(pkt->tofs()[i], tofs[i])
      TS_ASSERT_EQUALS(pkt->values()[i].c_str(), values[i])
    }
  }

  void testMultVariableU32ArrayParser() {
    std::shared_ptr<ADARA::MultVariableU32ArrayPkt> pkt = basicPacketTests<ADARA::MultVariableU32ArrayPkt>(
        multVariableU32ArrayPacket, sizeof(multVariableU32ArrayPacket), 1117010982, 102843667);
    TS_ASSERT_EQUALS(pkt->devId(), 1)
    TS_ASSERT_EQUALS(pkt->varId(), 11)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->numValues(), 3)
    std::vector<uint32_t> tofs = {17067500, 22171400, 22172800};
    std::vector<uint32_t> element_counts = {2, 1, 2};
    std::vector<std::vector<uint32_t>> values_expected = {{1, 2}, {3}, {4, 5}};
    for (size_t i = 0; i < pkt->numValues(); i++) {
      TS_ASSERT_EQUALS(pkt->tofs()[i], tofs[i])
      for (size_t j = 0; j < element_counts[i]; ++j)
        TS_ASSERT_EQUALS(pkt->values()[i][j], values_expected[i][j])
    }
  }

  void testMultVariableDoubleArrayParser() {
    std::shared_ptr<ADARA::MultVariableDoubleArrayPkt> pkt = basicPacketTests<ADARA::MultVariableDoubleArrayPkt>(
        multVariableDoubleArrayPacket, sizeof(multVariableDoubleArrayPacket), 1117010982, 102843667);
    TS_ASSERT_EQUALS(pkt->devId(), 1)
    TS_ASSERT_EQUALS(pkt->varId(), 11)
    TS_ASSERT_EQUALS(pkt->status(), ADARA::VariableStatus::OK)
    TS_ASSERT_EQUALS(pkt->severity(), ADARA::VariableSeverity::OK)
    TS_ASSERT_EQUALS(pkt->numValues(), 3)
    std::vector<uint32_t> tofs = {17067500, 22171400, 22172800};
    std::vector<uint32_t> element_counts = {2, 1, 2};
    std::vector<std::vector<double>> values_expected = {{1.0, 2.0}, {3.0}, {4.0, 5.0}};
    for (size_t i = 0; i < pkt->numValues(); i++) {
      TS_ASSERT_EQUALS(pkt->tofs()[i], tofs[i])
      for (size_t j = 0; j < element_counts[i]; ++j)
        TS_ASSERT_DELTA(pkt->values()[i][j], values_expected[i][j], 1e-8)
    }
  }

  /*******************************
   *   DEVICE DESCRIPTOR Packets
   *******************************/

  // There's only version 0 for the DeviceDescriptorPkt, so we don't need a version-specific test
  void testDeviceDescriptorPacketParser() {
    std::shared_ptr<ADARA::DeviceDescriptorPkt> pkt =
        basicPacketTests<ADARA::DeviceDescriptorPkt>(devDesPacket, sizeof(devDesPacket), 726785379, 0);
    auto expectedAt = [&](uint32_t start) { return packetCast<uint32_t>(devDesPacket, start, 4); };
    TS_ASSERT_EQUALS(pkt->devId(), expectedAt(16))
    // Basic XML validation
    Poco::XML::DOMParser parser;
    TS_ASSERT_THROWS_NOTHING(Poco::AutoPtr<Poco::XML::Document> doc =
                                 parser.parseMemory(pkt->description().c_str(), pkt->description().length()));
  }

protected:
  // The rxPacket() functions just make a copy of the packet available in the public member
  // The test class will handle everything from there.
  using ADARA::Parser::rxPacket;
#define DEFINE_RX_PACKET(PktType)                                                                                      \
  bool rxPacket(const PktType &pkt) override {                                                                         \
    m_pkt.reset(new PktType(pkt));                                                                                     \
    return false;                                                                                                      \
  }

  DEFINE_RX_PACKET(ADARA::RawDataPkt)
  DEFINE_RX_PACKET(ADARA::RTDLPkt)
  DEFINE_RX_PACKET(ADARA::SourceListPkt)
  DEFINE_RX_PACKET(ADARA::BankedEventPkt)
  DEFINE_RX_PACKET(ADARA::BeamMonitorPkt)
  DEFINE_RX_PACKET(ADARA::PixelMappingAltPkt)
  DEFINE_RX_PACKET(ADARA::RunStatusPkt)
  DEFINE_RX_PACKET(ADARA::RunInfoPkt)
  DEFINE_RX_PACKET(ADARA::TransCompletePkt)
  DEFINE_RX_PACKET(ADARA::ClientHelloPkt)
  DEFINE_RX_PACKET(ADARA::AnnotationPkt)
  DEFINE_RX_PACKET(ADARA::SyncPkt)
  DEFINE_RX_PACKET(ADARA::HeartbeatPkt)
  DEFINE_RX_PACKET(ADARA::GeometryPkt)
  DEFINE_RX_PACKET(ADARA::BeamlineInfoPkt)
  DEFINE_RX_PACKET(ADARA::DetectorBankSetsPkt)
  DEFINE_RX_PACKET(ADARA::DataDonePkt)
  DEFINE_RX_PACKET(ADARA::DeviceDescriptorPkt)
  DEFINE_RX_PACKET(ADARA::VariableU32Pkt)
  DEFINE_RX_PACKET(ADARA::VariableDoublePkt)
  DEFINE_RX_PACKET(ADARA::VariableStringPkt)
  DEFINE_RX_PACKET(ADARA::VariableU32ArrayPkt)
  DEFINE_RX_PACKET(ADARA::VariableDoubleArrayPkt)
  DEFINE_RX_PACKET(ADARA::MultVariableU32Pkt)
  DEFINE_RX_PACKET(ADARA::MultVariableDoublePkt)
  DEFINE_RX_PACKET(ADARA::MultVariableStringPkt)
  DEFINE_RX_PACKET(ADARA::MultVariableU32ArrayPkt)
  DEFINE_RX_PACKET(ADARA::MultVariableDoubleArrayPkt)

  // Call the base class rxPacket(const ADARA::Packet &pkt) which will
  // eventually result
  // in the execution of one of the rxPacket() functions defined above
  bool rxPacket(const ADARA::Packet &pkt) override { return ADARA::Parser::rxPacket(pkt); }

private:
  unsigned char *m_initialBufferAddr;
  std::shared_ptr<ADARA::Packet> m_pkt;

  // A template function that covers the basic tests all packet types have to pass.
  // Returns a shared pointer to the packet so further tests can be conducted.
  template <class T>
  std::shared_ptr<T> basicPacketTests(const unsigned char *data, unsigned len, unsigned pulseHigh, unsigned pulseLow) {
    parseOnePacket(data, len);

    // verify that we can cast the packet to the type we expect it to be
    std::shared_ptr<T> pkt = std::dynamic_pointer_cast<T>(m_pkt);
    TS_ASSERT(pkt != nullptr)

    // Make sure we have a valid packet before attempting the remaining tests
    if (pkt != nullptr) {
      TS_ASSERT_EQUALS(pkt->packet_length(), len)
      TS_ASSERT_EQUALS(pkt->payload_length(), len - sizeof(ADARA::Header))

      TS_ASSERT(pulseIdCompare(pkt->pulseId(), pulseHigh, pulseLow))
    }
    return pkt;
  }

  //
  // Helper functions for basicPacketTests()
  //

  // Calls the necessary parser functions to update m_pkt
  // Expects a single packet.  If there's more than one packet in len bytes,
  // then this function will assert
  // m_pkt is updated by the rxPacket functions which are called (eventually)
  // from bufferParse()
  void parseOnePacket(const unsigned char *data, unsigned len) {
    m_pkt.reset();
    unsigned bufferLen = bufferFillLength();
    TS_ASSERT(bufferLen > 0)
    TS_ASSERT(bufferLen > len)
    // Yes, len will always be greater than 0.  I want a specific warning if
    // dataLen is 0

    unsigned char *bufferAddr = bufferFillAddress();
    TS_ASSERT(bufferAddr != nullptr)
    TS_ASSERT(bufferAddr == m_initialBufferAddr) // verify that there's nothing in the buffer

    memcpy(bufferAddr, data, len);
    bufferBytesAppended(len);

    int packetsParsed = 0;
    std::string bufferParseLog;
    // bufferParse() wants a string where it can save log messages.
    // We don't actually use the messages for anything, though.
    TS_ASSERT_THROWS_NOTHING((packetsParsed = bufferParse(bufferParseLog, 1)))
    TS_ASSERT(packetsParsed == 1)
    TS_ASSERT(m_pkt != std::shared_ptr<ADARA::Packet>()); // verify m_pkt has been updated

    TS_ASSERT(bufferParse(bufferParseLog, 0) == 0)        // try to parse again, make sure there's nothing to parse
    TS_ASSERT(bufferFillAddress() == m_initialBufferAddr) // verify that there's nothing in the buffer
  }

  // Compare the actual pulse ID value to the formatted value that is displayed by running the adara parser
  bool pulseIdCompare(uint64_t pulseId, uint32_t high, uint32_t low) {
    uint32_t pulseIdHigh = (uint32_t)(pulseId >> 32);
    uint32_t pulseIdLow = (uint32_t)(pulseId);
    return ((pulseIdHigh == high) && (pulseIdLow == low));
  }

  /**
   * Extract and cast a value from a packet buffer
   *
   * @tparam T The type to cast the result to (uint16_t, uint32_t, etc)
   * @param packet The binary packet buffer
   * @param start Starting byte index
   * @param extent Number of bytes to read
   * @return The extracted value cast to type T
   */
  template <typename T> T packetCast(const unsigned char *packet, uint32_t start, uint32_t extent) {
    // Ensure the number of bytes is valid
    assert(extent > 0);
    assert(extent <= sizeof(T)); // Ensure we don't read more bytes than T can hold
    T result = 0;

    // Process bytes in little-endian order
    for (uint32_t i = 0; i < extent; ++i) {
      // Shift each byte to the appropriate position
      result |= static_cast<T>(packet[start + i]) << (i * 8);
    }

    return result;
  }
};

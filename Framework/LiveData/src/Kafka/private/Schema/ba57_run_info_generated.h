// clang-format off
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_BA57RUNINFO_H_
#define FLATBUFFERS_GENERATED_BA57RUNINFO_H_

#include "flatbuffers/flatbuffers.h"



struct RunStart;
struct RunStop;
struct RunInfo;

enum InfoTypes {
  InfoTypes_NONE = 0,
  InfoTypes_RunStart = 1,
  InfoTypes_RunStop = 2,
  InfoTypes_MIN = InfoTypes_NONE,
  InfoTypes_MAX = InfoTypes_RunStop
};

inline const char **EnumNamesInfoTypes() {
  static const char *names[] = { "NONE", "RunStart", "RunStop", nullptr };
  return names;
}

inline const char *EnumNameInfoTypes(InfoTypes e) { return EnumNamesInfoTypes()[static_cast<int>(e)]; }

inline bool VerifyInfoTypes(flatbuffers::Verifier &verifier, const void *union_obj, InfoTypes type);

struct RunStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_START_TIME = 4,
    VT_RUN_NUMBER = 6,
    VT_INSTRUMENT_NAME = 8,
    VT_N_PERIODS = 10
  };
  uint64_t start_time() const { return GetField<uint64_t>(VT_START_TIME, 0); }
  int32_t run_number() const { return GetField<int32_t>(VT_RUN_NUMBER, 0); }
  const flatbuffers::String *instrument_name() const { return GetPointer<const flatbuffers::String *>(VT_INSTRUMENT_NAME); }
  int32_t n_periods() const { return GetField<int32_t>(VT_N_PERIODS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_TIME) &&
           VerifyField<int32_t>(verifier, VT_RUN_NUMBER) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INSTRUMENT_NAME) &&
           verifier.Verify(instrument_name()) &&
           VerifyField<int32_t>(verifier, VT_N_PERIODS) &&
           verifier.EndTable();
  }
};

struct RunStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_time(uint64_t start_time) { fbb_.AddElement<uint64_t>(RunStart::VT_START_TIME, start_time, 0); }
  void add_run_number(int32_t run_number) { fbb_.AddElement<int32_t>(RunStart::VT_RUN_NUMBER, run_number, 0); }
  void add_instrument_name(flatbuffers::Offset<flatbuffers::String> instrument_name) { fbb_.AddOffset(RunStart::VT_INSTRUMENT_NAME, instrument_name); }
  void add_n_periods(int32_t n_periods) { fbb_.AddElement<int32_t>(RunStart::VT_N_PERIODS, n_periods, 0); }
  RunStartBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RunStartBuilder &operator=(const RunStartBuilder &);
  flatbuffers::Offset<RunStart> Finish() {
    auto o = flatbuffers::Offset<RunStart>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<RunStart> CreateRunStart(flatbuffers::FlatBufferBuilder &_fbb,
   uint64_t start_time = 0,
   int32_t run_number = 0,
   flatbuffers::Offset<flatbuffers::String> instrument_name = 0,
   int32_t n_periods = 0) {
  RunStartBuilder builder_(_fbb);
  builder_.add_start_time(start_time);
  builder_.add_n_periods(n_periods);
  builder_.add_instrument_name(instrument_name);
  builder_.add_run_number(run_number);
  return builder_.Finish();
}

struct RunStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STOP_TIME = 4
  };
  uint64_t stop_time() const { return GetField<uint64_t>(VT_STOP_TIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_STOP_TIME) &&
           verifier.EndTable();
  }
};

struct RunStopBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stop_time(uint64_t stop_time) { fbb_.AddElement<uint64_t>(RunStop::VT_STOP_TIME, stop_time, 0); }
  RunStopBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RunStopBuilder &operator=(const RunStopBuilder &);
  flatbuffers::Offset<RunStop> Finish() {
    auto o = flatbuffers::Offset<RunStop>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<RunStop> CreateRunStop(flatbuffers::FlatBufferBuilder &_fbb,
   uint64_t stop_time = 0) {
  RunStopBuilder builder_(_fbb);
  builder_.add_stop_time(stop_time);
  return builder_.Finish();
}

struct RunInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO_TYPE_TYPE = 4,
    VT_INFO_TYPE = 6
  };
  InfoTypes info_type_type() const { return static_cast<InfoTypes>(GetField<uint8_t>(VT_INFO_TYPE_TYPE, 0)); }
  const void *info_type() const { return GetPointer<const void *>(VT_INFO_TYPE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INFO_TYPE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INFO_TYPE) &&
           VerifyInfoTypes(verifier, info_type(), info_type_type()) &&
           verifier.EndTable();
  }
};

struct RunInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info_type_type(InfoTypes info_type_type) { fbb_.AddElement<uint8_t>(RunInfo::VT_INFO_TYPE_TYPE, static_cast<uint8_t>(info_type_type), 0); }
  void add_info_type(flatbuffers::Offset<void> info_type) { fbb_.AddOffset(RunInfo::VT_INFO_TYPE, info_type); }
  RunInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RunInfoBuilder &operator=(const RunInfoBuilder &);
  flatbuffers::Offset<RunInfo> Finish() {
    auto o = flatbuffers::Offset<RunInfo>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<RunInfo> CreateRunInfo(flatbuffers::FlatBufferBuilder &_fbb,
   InfoTypes info_type_type = InfoTypes_NONE,
   flatbuffers::Offset<void> info_type = 0) {
  RunInfoBuilder builder_(_fbb);
  builder_.add_info_type(info_type);
  builder_.add_info_type_type(info_type_type);
  return builder_.Finish();
}

inline bool VerifyInfoTypes(flatbuffers::Verifier &verifier, const void *union_obj, InfoTypes type) {
  switch (type) {
    case InfoTypes_NONE: return true;
    case InfoTypes_RunStart: return verifier.VerifyTable(reinterpret_cast<const RunStart *>(union_obj));
    case InfoTypes_RunStop: return verifier.VerifyTable(reinterpret_cast<const RunStop *>(union_obj));
    default: return false;
  }
}

inline const RunInfo *GetRunInfo(const void *buf) { return flatbuffers::GetRoot<RunInfo>(buf); }

inline bool VerifyRunInfoBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<RunInfo>(); }

inline const char *RunInfoIdentifier() { return "ba57"; }

inline bool RunInfoBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, RunInfoIdentifier()); }

inline void FinishRunInfoBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<RunInfo> root) { fbb.Finish(root, RunInfoIdentifier()); }


#endif  // FLATBUFFERS_GENERATED_BA57RUNINFO_H_
// clang-format on

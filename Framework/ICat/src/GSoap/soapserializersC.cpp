// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2018 ISIS Rutherford Appleton Laboratory UKRI,
//     NScD Oak Ridge National Laboratory, European Spallation Source
//     & Institut Laue - Langevin
// SPDX - License - Identifier: GPL - 3.0 +
/* soapserializersC.cpp
   Generated by gSOAP 2.8.15 from soapserializers.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push - w - 8060
#pragma option push - w - 8004
#endif

#include "MantidICat/GSoap/soapserializersH.h"

SOAP_SOURCE_STAMP(
    "@(#) soapserializersC.cpp ver 2.8.15 2013-08-19 12:46:04 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap) {
  soap->part = SOAP_IN_HEADER;
  soap->header =
      soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, nullptr);
  soap->part = SOAP_END_HEADER;
  return soap->header == nullptr;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap) {
  if (soap->version && soap->header) {
    soap->part = SOAP_IN_HEADER;
    if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header,
                                  nullptr))
      return soap->error;
    soap->part = SOAP_END_HEADER;
  }
  return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap) {
  if (soap->version && soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap) {
  if (soap->header == nullptr) {
    if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
      soap_default_SOAP_ENV__Header(soap, soap->header);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap) {
  if (soap->fault == nullptr) {
    soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
    if (soap->fault == nullptr)
      return;
    soap_default_SOAP_ENV__Fault(soap, soap->fault);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
    soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
    soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
    soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
    soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap) {
  soap_fault(soap);
  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap) {
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault",
                                    nullptr);
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap) {
  return (soap->fault = soap_get_SOAP_ENV__Fault(
              soap, nullptr, "SOAP-ENV:Fault", nullptr)) == nullptr;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
    return (const char **)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  return (const char **)&soap->fault->faultcode;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultsubcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == nullptr) {
      soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode =
          soap_new_SOAP_ENV__Code(soap, -1);
      soap_default_SOAP_ENV__Code(
          soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
    }
    return (const char **)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode
        ->SOAP_ENV__Value;
  }
  return (const char **)&soap->fault->faultcode;
}

SOAP_FMAC3 const char *SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Code &&
        soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode &&
        soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
      return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
    return nullptr;
  }
  return soap->fault->faultcode;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultstring(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2)
    return (const char **)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
  return (const char **)&soap->fault->faultstring;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultdetail(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Detail == nullptr) {
      soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
      soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }
    return (const char **)&soap->fault->SOAP_ENV__Detail->__any;
  }
  if (soap->fault->detail == nullptr) {
    soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
    soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
  }
  return (const char **)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char *SOAP_FMAC4 soap_check_faultdetail(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
    return soap->fault->SOAP_ENV__Detail->__any;
  if (soap->fault->detail)
    return soap->fault->detail->__any;
  return nullptr;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap) {
  int t;
  if (soap->version == 1) {
    for (;;) {
      if (!soap_getelement(soap, &t))
        if (soap->error || soap_ignore_element(soap))
          break;
    }
  }
  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;
  return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap *soap, int *type) {
  (void)type;
  if (soap_peek_element(soap))
    return nullptr;
#ifndef WITH_NOIDREF
  if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
    *type = soap_lookup_type(soap, soap->href);
  switch (*type) {
  case SOAP_TYPE_byte:
    return soap_in_byte(soap, nullptr, nullptr, "xsd:byte");
  case SOAP_TYPE_int:
    return soap_in_int(soap, nullptr, nullptr, "xsd:int");
  case SOAP_TYPE__QName: {
    char **s;
    s = soap_in__QName(soap, nullptr, nullptr, "xsd:QName");
    return s ? *s : nullptr;
  }
  case SOAP_TYPE_string: {
    char **s;
    s = soap_in_string(soap, nullptr, nullptr, "xsd:string");
    return s ? *s : nullptr;
  }
  default:
#endif
  {
    const char *t = soap->type;
    if (!*t)
      t = soap->tag;
    if (!soap_match_tag(soap, t, "xsd:byte")) {
      *type = SOAP_TYPE_byte;
      return soap_in_byte(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_int;
      return soap_in_int(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      char **s;
      *type = SOAP_TYPE__QName;
      s = soap_in__QName(soap, nullptr, nullptr, nullptr);
      return s ? *s : nullptr;
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      char **s;
      *type = SOAP_TYPE_string;
      s = soap_in_string(soap, nullptr, nullptr, nullptr);
      return s ? *s : nullptr;
    }
    t = soap->tag;
#ifndef WITH_NOIDREF
  }
#endif
  }
  soap->error = SOAP_TAG_MISMATCH;
  return nullptr;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap) {
  if (!soap_peek_element(soap)) {
    int t;
    DBGLOG(TEST,
           SOAP_MESSAGE(fdebug,
                        "Unexpected element '%s' in input (level=%u, %d)\n",
                        soap->tag, soap->level, soap->body));
    if (soap->mustUnderstand && !soap->other)
      return soap->error = SOAP_MUSTUNDERSTAND;
    if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) ||
        !soap_match_tag(soap, soap->tag, "SOAP-ENV:")) {
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
      return soap->error = SOAP_TAG_MISMATCH;
    }
    if (!*soap->id || !soap_getelement(soap, &t)) {
      soap->peeked = 0;
      if (soap->fignore)
        soap->error = soap->fignore(soap, soap->tag);
      else
        soap->error = SOAP_OK;
      DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(
                       fdebug, "IGNORING element '%s'\n", soap->tag));
      if (!soap->error && soap->body) {
        soap->level++;
        while (!soap_ignore_element(soap))
          ;
        if (soap->error == SOAP_NO_TAG)
          soap->error = soap_element_end_in(soap, nullptr);
      }
    }
  }
  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap) {
  int i;
  struct soap_plist *pp;
  if (soap->version == 1 && soap->encodingStyle &&
      !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;
  return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr,
                                          const char *tag, int id, int type) {
  (void)tag;
  switch (type) {
  case SOAP_TYPE_byte:
    return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
  case SOAP_TYPE_int:
    return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
  case SOAP_TYPE__QName:
    return soap_out_string(soap, tag, id, (char *const *)&ptr, "xsd:QName");
  case SOAP_TYPE_string:
    return soap_out_string(soap, tag, id, (char *const *)&ptr, "xsd:string");
  }
  return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr,
                                            int type) {
  (void)soap;
  (void)ptr;
  (void)type; /* appease -Wall -Werror */
  switch (type) {
  case SOAP_TYPE__QName:
    soap_serialize_string(soap, (char *const *)&ptr);
    break;
  case SOAP_TYPE_string:
    soap_serialize_string(soap, (char *const *)&ptr);
    break;
  }
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void *SOAP_FMAC4 soapserializers_instantiate(struct soap *soap,
                                                        int t, const char *type,
                                                        const char *arrayType,
                                                        size_t *n) {
  (void)type;
  switch (t) {
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Header:
    return (void *)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType,
                                                     n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Code:
    return (void *)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType,
                                                   n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Detail:
    return (void *)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType,
                                                     n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Reason:
    return (void *)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType,
                                                     n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Fault:
    return (void *)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType,
                                                    n);
#endif
  }
  return nullptr;
}

SOAP_FMAC3 int SOAP_FMAC4 soapserializers_fdelete(struct soap_clist *p) {
  switch (p->type) {
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Header:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Header *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Header *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Code:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Code *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Code *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Detail:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Detail *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Reason:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Reason *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Fault:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Fault *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault *)p->ptr);
    break;
#endif
  default:
    return SOAP_ERR;
  }
  return SOAP_OK;
}

SOAP_FMAC3 void *SOAP_FMAC4 soap_class_id_enter(struct soap *soap,
                                                const char *id, void *p, int t,
                                                size_t n, const char *type,
                                                const char *arrayType) {
  return soap_id_enter(soap, id, p, t, n, 0, type, arrayType,
                       soapserializers_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag,
                                        int id, const char *a,
                                        const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char *SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag,
                                         char *a, const char *type) {
  char *p;
  p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a,
                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_byte);
  if (soap_out_byte(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char *SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p,
                                          const char *tag, const char *type) {
  if ((p = soap_in_byte(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag,
                                       int id, const int *a, const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int *SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag,
                                       int *a, const char *type) {
  int *p;
  p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a,
                                       const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_int);
  if (soap_out_int(soap, tag ? tag : "int", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int *SOAP_FMAC4 soap_get_int(struct soap *soap, int *p,
                                        const char *tag, const char *type) {
  if ((p = soap_in_int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = nullptr;
  a->SOAP_ENV__Code = nullptr;
  a->SOAP_ENV__Reason = nullptr;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(
    struct soap *soap, const struct SOAP_ENV__Fault *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id,
                         const struct SOAP_ENV__Fault *a, const char *type) {
  const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault),
          type))
    return soap->error;
  if (soap_out__QName(soap, "faultcode", -1, (char *const *)&soap_tmp_faultcode,
                      ""))
    return soap->error;
  if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
    return soap->error;
  if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1,
                                       &a->SOAP_ENV__Code, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1,
                                         &a->SOAP_ENV__Reason, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1,
                                         &a->SOAP_ENV__Detail, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault *SOAP_FMAC4
soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag,
                        struct SOAP_ENV__Fault *a, const char *type) {
  size_t soap_flag_faultcode = 1;
  size_t soap_flag_faultstring = 1;
  size_t soap_flag_faultactor = 1;
  size_t soap_flag_detail = 1;
  size_t soap_flag_SOAP_ENV__Code = 1;
  size_t soap_flag_SOAP_ENV__Reason = 1;
  size_t soap_flag_SOAP_ENV__Node = 1;
  size_t soap_flag_SOAP_ENV__Role = 1;
  size_t soap_flag_SOAP_ENV__Detail = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (struct SOAP_ENV__Fault *)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault,
      sizeof(struct SOAP_ENV__Fault), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default_SOAP_ENV__Fault(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_faultcode &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "faultcode", &a->faultcode, "")) {
          soap_flag_faultcode--;
          continue;
        }
      if (soap_flag_faultstring &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultstring", &a->faultstring,
                           "xsd:string")) {
          soap_flag_faultstring--;
          continue;
        }
      if (soap_flag_faultactor &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string")) {
          soap_flag_faultactor--;
          continue;
        }
      if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "")) {
          soap_flag_detail--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code",
                                            &a->SOAP_ENV__Code, "")) {
          soap_flag_SOAP_ENV__Code--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason",
                                              &a->SOAP_ENV__Reason, "")) {
          soap_flag_SOAP_ENV__Reason--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Node &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node,
                           "xsd:string")) {
          soap_flag_SOAP_ENV__Node--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Role &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role,
                           "xsd:string")) {
          soap_flag_SOAP_ENV__Role--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail",
                                              &a->SOAP_ENV__Detail, "")) {
          soap_flag_SOAP_ENV__Detail--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Fault *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0,
        sizeof(struct SOAP_ENV__Fault), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a,
                         const char *tag, const char *type) {
  int id =
      soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
  if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault *SOAP_FMAC4
soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p,
                         const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault *SOAP_FMAC2
soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type,
                                 const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST,
         SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n",
                      n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_SOAP_ENV__Fault, n,
                                    soapserializers_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Fault);
    if (size)
      *size = sizeof(struct SOAP_ENV__Fault);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Fault);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Fault *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st,
                                                     int tt, void *p,
                                                     size_t len, const void *q,
                                                     size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n",
                            q, p));
  *(struct SOAP_ENV__Fault *)p = *(struct SOAP_ENV__Fault *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(
    struct soap *soap, const struct SOAP_ENV__Reason *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id,
                          const struct SOAP_ENV__Reason *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason),
          type))
    return soap->error;
  if (soap->lang)
    soap_set_attr(soap, "xml:lang", soap->lang, 1);
  if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason *SOAP_FMAC4
soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag,
                         struct SOAP_ENV__Reason *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Text = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (struct SOAP_ENV__Reason *)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason,
      sizeof(struct SOAP_ENV__Reason), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default_SOAP_ENV__Reason(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Text &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text,
                           "xsd:string")) {
          soap_flag_SOAP_ENV__Text--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Reason *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0,
        sizeof(struct SOAP_ENV__Reason), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a,
                          const char *tag, const char *type) {
  int id =
      soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
  if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", id, a,
                                type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason *SOAP_FMAC4
soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p,
                          const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason *SOAP_FMAC2
soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type,
                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST,
         SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n",
                      n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_SOAP_ENV__Reason,
                                    n, soapserializers_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Reason);
    if (size)
      *size = sizeof(struct SOAP_ENV__Reason);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Reason);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Reason *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st,
                                                      int tt, void *p,
                                                      size_t len, const void *q,
                                                      size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(
                   fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
  *(struct SOAP_ENV__Reason *)p = *(struct SOAP_ENV__Reason *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__any = nullptr;
  a->__type = 0;
  a->fault = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(
    struct soap *soap, const struct SOAP_ENV__Detail *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id,
                          const struct SOAP_ENV__Detail *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail),
          type))
    return soap->error;
  soap_outliteral(soap, "-any", &a->__any, nullptr);
  if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail *SOAP_FMAC4
soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag,
                         struct SOAP_ENV__Detail *a, const char *type) {
  size_t soap_flag___any = 1;
  size_t soap_flag_fault = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (struct SOAP_ENV__Detail *)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail,
      sizeof(struct SOAP_ENV__Detail), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default_SOAP_ENV__Detail(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
        if ((a->fault = soap_getelement(soap, &a->__type))) {
          soap_flag_fault = 0;
          continue;
        }
      if (soap_flag___any &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-any", &a->__any)) {
          soap_flag___any--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Detail *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0,
        sizeof(struct SOAP_ENV__Detail), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a,
                          const char *tag, const char *type) {
  int id =
      soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
  if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", id, a,
                                type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail *SOAP_FMAC4
soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p,
                          const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail *SOAP_FMAC2
soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type,
                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST,
         SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n",
                      n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_SOAP_ENV__Detail,
                                    n, soapserializers_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Detail);
    if (size)
      *size = sizeof(struct SOAP_ENV__Detail);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Detail);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Detail *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st,
                                                      int tt, void *p,
                                                      size_t len, const void *q,
                                                      size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(
                   fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
  *(struct SOAP_ENV__Detail *)p = *(struct SOAP_ENV__Detail *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(
    struct soap *soap, const struct SOAP_ENV__Code *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id,
                        const struct SOAP_ENV__Code *a, const char *type) {
  const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code),
          type))
    return soap->error;
  if (soap_out__QName(soap, "SOAP-ENV:Value", -1,
                      (char *const *)&soap_tmp_SOAP_ENV__Value, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1,
                                       &a->SOAP_ENV__Subcode, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code *SOAP_FMAC4
soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag,
                       struct SOAP_ENV__Code *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Value = 1;
  size_t soap_flag_SOAP_ENV__Subcode = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (struct SOAP_ENV__Code *)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code,
      sizeof(struct SOAP_ENV__Code), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default_SOAP_ENV__Code(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Value &&
          (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, "")) {
          soap_flag_SOAP_ENV__Value--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode",
                                            &a->SOAP_ENV__Subcode, "")) {
          soap_flag_SOAP_ENV__Subcode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Code *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0,
        sizeof(struct SOAP_ENV__Code), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a,
                        const char *tag, const char *type) {
  int id =
      soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
  if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code *SOAP_FMAC4
soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p,
                        const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code *SOAP_FMAC2
soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type,
                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST,
         SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n",
                      n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_SOAP_ENV__Code, n,
                                    soapserializers_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Code);
    if (size)
      *size = sizeof(struct SOAP_ENV__Code);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Code);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Code *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st,
                                                    int tt, void *p, size_t len,
                                                    const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n",
                            q, p));
  *(struct SOAP_ENV__Code *)p = *(struct SOAP_ENV__Code *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4
soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(
    struct soap *soap, const struct SOAP_ENV__Header *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id,
                          const struct SOAP_ENV__Header *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header),
          type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header *SOAP_FMAC4
soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag,
                         struct SOAP_ENV__Header *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (struct SOAP_ENV__Header *)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header,
      sizeof(struct SOAP_ENV__Header), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default_SOAP_ENV__Header(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Header *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0,
        sizeof(struct SOAP_ENV__Header), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a,
                          const char *tag, const char *type) {
  int id =
      soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
  if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", id, a,
                                type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header *SOAP_FMAC4
soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p,
                          const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header *SOAP_FMAC2
soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type,
                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST,
         SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n",
                      n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_SOAP_ENV__Header,
                                    n, soapserializers_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Header);
    if (size)
      *size = sizeof(struct SOAP_ENV__Header);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Header);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Header *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st,
                                                      int tt, void *p,
                                                      size_t len, const void *q,
                                                      size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(
                   fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
  *(struct SOAP_ENV__Header *)p = *(struct SOAP_ENV__Header *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(
    struct soap *soap, struct SOAP_ENV__Reason *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(
    struct soap *soap, const char *tag, int id,
    struct SOAP_ENV__Reason *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type,
                       SOAP_TYPE_SOAP_ENV__Reason);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason **SOAP_FMAC4
soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag,
                                  struct SOAP_ENV__Reason **a,
                                  const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Reason *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Reason **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_SOAP_ENV__Reason,
        sizeof(struct SOAP_ENV__Reason), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(
    struct soap *soap, struct SOAP_ENV__Reason *const *a, const char *tag,
    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag,
                      SOAP_TYPE_PointerToSOAP_ENV__Reason);
  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason",
                                         id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason **SOAP_FMAC4
soap_get_PointerToSOAP_ENV__Reason(struct soap *soap,
                                   struct SOAP_ENV__Reason **p, const char *tag,
                                   const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(
    struct soap *soap, struct SOAP_ENV__Detail *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(
    struct soap *soap, const char *tag, int id,
    struct SOAP_ENV__Detail *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type,
                       SOAP_TYPE_SOAP_ENV__Detail);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail **SOAP_FMAC4
soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag,
                                  struct SOAP_ENV__Detail **a,
                                  const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Detail *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Detail **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_SOAP_ENV__Detail,
        sizeof(struct SOAP_ENV__Detail), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(
    struct soap *soap, struct SOAP_ENV__Detail *const *a, const char *tag,
    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag,
                      SOAP_TYPE_PointerToSOAP_ENV__Detail);
  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail",
                                         id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail **SOAP_FMAC4
soap_get_PointerToSOAP_ENV__Detail(struct soap *soap,
                                   struct SOAP_ENV__Detail **p, const char *tag,
                                   const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(
    struct soap *soap, struct SOAP_ENV__Code *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(
    struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const *a,
    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type,
                       SOAP_TYPE_SOAP_ENV__Code);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code **SOAP_FMAC4
soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag,
                                struct SOAP_ENV__Code **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (struct SOAP_ENV__Code **)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Code *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (struct SOAP_ENV__Code **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_SOAP_ENV__Code,
        sizeof(struct SOAP_ENV__Code), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(
    struct soap *soap, struct SOAP_ENV__Code *const *a, const char *tag,
    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag,
                      SOAP_TYPE_PointerToSOAP_ENV__Code);
  if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", id, a,
                                       type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code **SOAP_FMAC4
soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p,
                                 const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap,
                                                 char *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag,
                                          int id, char *const *a,
                                          const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag,
                                            char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const *a,
                                          const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE__QName);
  if (soap_out__QName(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p,
                                             const char *tag,
                                             const char *type) {
  if ((p = soap_in__QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char *)nullptr;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap,
                                                 char *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag,
                                          int id, char *const *a,
                                          const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag,
                                            char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const *a,
                                          const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_string);
  if (soap_out_string(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_get_string(struct soap *soap, char **p,
                                             const char *tag,
                                             const char *type) {
  if ((p = soap_in_string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapserializersC.cpp */

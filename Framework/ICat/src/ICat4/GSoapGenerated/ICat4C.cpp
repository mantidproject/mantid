/* ICat4C.cpp
   Generated by gSOAP 2.8.15 from ICat4Service.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push - w - 8060
#pragma option push - w - 8004
#endif

#include "MantidICat/ICat4/GSoapGenerated/ICat4H.h"

namespace ICat4 {

SOAP_SOURCE_STAMP("@(#) ICat4C.cpp ver 2.8.15 2014-04-23 10:04:17 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap) {
  soap->part = SOAP_IN_HEADER;
  soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
  soap->part = SOAP_END_HEADER;
  return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap) {
  if (soap->version && soap->header) {
    soap->part = SOAP_IN_HEADER;
    if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
      return soap->error;
    soap->part = SOAP_END_HEADER;
  }
  return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap) {
  if (soap->version && soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap) {
  if (soap->header == NULL) {
    if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
      soap_default_SOAP_ENV__Header(soap, soap->header);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap) {
  if (soap->fault == NULL) {
    soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
    if (soap->fault == NULL)
      return;
    soap_default_SOAP_ENV__Fault(soap, soap->fault);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
    soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
    soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
    soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
    soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap) {
  soap_fault(soap);
  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap) {
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap) {
  return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
    return (const char **)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  return (const char **)&soap->fault->faultcode;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultsubcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL) {
      soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
    }
    return (const char **)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
  }
  return (const char **)&soap->fault->faultcode;
}

SOAP_FMAC3 const char *SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode &&
        soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
      return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
    return NULL;
  }
  return soap->fault->faultcode;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultstring(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2)
    return (const char **)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
  return (const char **)&soap->fault->faultstring;
}

SOAP_FMAC3 const char **SOAP_FMAC4 soap_faultdetail(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (soap->fault->SOAP_ENV__Detail == NULL) {
      soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
      soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }
    return (const char **)&soap->fault->SOAP_ENV__Detail->__any;
  }
  if (soap->fault->detail == NULL) {
    soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
    soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
  }
  return (const char **)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char *SOAP_FMAC4 soap_check_faultdetail(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
    return soap->fault->SOAP_ENV__Detail->__any;
  if (soap->fault->detail)
    return soap->fault->detail->__any;
  return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap) {
  int t;
  if (soap->version == 1) {
    for (;;) {
      if (!soap_getelement(soap, &t))
        if (soap->error || soap_ignore_element(soap))
          break;
    }
  }
  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;
  return soap->error;
}
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap *soap, int *type) {
  (void)type;
  if (soap_peek_element(soap))
    return nullptr;
#ifndef WITH_NOIDREF
  if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
    *type = soap_lookup_type(soap, soap->href);
  switch (*type) {
  case SOAP_TYPE_ICat4_byte:
    return soap_in_byte(soap, nullptr, nullptr, "xsd:byte");
  case SOAP_TYPE_ICat4_int:
    return soap_in_int(soap, nullptr, nullptr, "xsd:int");
  case SOAP_TYPE_ICat4_LONG64:
    return soap_in_LONG64(soap, nullptr, nullptr, "xsd:long");
  case SOAP_TYPE_ICat4_double:
    return soap_in_double(soap, nullptr, nullptr, "xsd:double");
  case SOAP_TYPE_ICat4_time:
    return soap_in_time(soap, nullptr, nullptr, "xsd:dateTime");
  case SOAP_TYPE_ICat4_ns1__accessType:
    return soap_in_ns1__accessType(soap, nullptr, nullptr, "ns1:accessType");
  case SOAP_TYPE_ICat4_ns1__relType:
    return soap_in_ns1__relType(soap, nullptr, nullptr, "ns1:relType");
  case SOAP_TYPE_ICat4_ns1__parameterValueType:
    return soap_in_ns1__parameterValueType(soap, nullptr, nullptr, "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_ns1__studyStatus:
    return soap_in_ns1__studyStatus(soap, nullptr, nullptr, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_ns1__icatExceptionType:
    return soap_in_ns1__icatExceptionType(soap, nullptr, nullptr, "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_bool:
    return soap_in_bool(soap, nullptr, nullptr, "xsd:boolean");
  case SOAP_TYPE_ICat4_ns1__accessType_:
    return soap_in_ns1__accessType_(soap, nullptr, nullptr, "ns1:accessType");
  case SOAP_TYPE_ICat4_ns1__relType_:
    return soap_in_ns1__relType_(soap, nullptr, nullptr, "ns1:relType");
  case SOAP_TYPE_ICat4_ns1__parameterValueType_:
    return soap_in_ns1__parameterValueType_(soap, nullptr, nullptr, "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_ns1__studyStatus_:
    return soap_in_ns1__studyStatus_(soap, nullptr, nullptr, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_ns1__icatExceptionType_:
    return soap_in_ns1__icatExceptionType_(soap, nullptr, nullptr, "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse:
    return soap_in_ns1__getRemainingMinutesResponse(soap, nullptr, nullptr, "ns1:getRemainingMinutesResponse");
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutes:
    return soap_in_ns1__getRemainingMinutes(soap, nullptr, nullptr, "ns1:getRemainingMinutes");
  case SOAP_TYPE_ICat4_ns1__logoutResponse:
    return soap_in_ns1__logoutResponse(soap, nullptr, nullptr, "ns1:logoutResponse");
  case SOAP_TYPE_ICat4_ns1__logout:
    return soap_in_ns1__logout(soap, nullptr, nullptr, "ns1:logout");
  case SOAP_TYPE_ICat4_ns1__searchResponse:
    return soap_in_ns1__searchResponse(soap, nullptr, nullptr, "ns1:searchResponse");
  case SOAP_TYPE_ICat4_ns1__search:
    return soap_in_ns1__search(soap, nullptr, nullptr, "ns1:search");
  case SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse:
    return soap_in_ns1__isAccessAllowedResponse(soap, nullptr, nullptr, "ns1:isAccessAllowedResponse");
  case SOAP_TYPE_ICat4_ns1__isAccessAllowed:
    return soap_in_ns1__isAccessAllowed(soap, nullptr, nullptr, "ns1:isAccessAllowed");
  case SOAP_TYPE_ICat4_ns1__deleteResponse:
    return soap_in_ns1__deleteResponse(soap, nullptr, nullptr, "ns1:deleteResponse");
  case SOAP_TYPE_ICat4_ns1__delete:
    return soap_in_ns1__delete(soap, nullptr, nullptr, "ns1:delete");
  case SOAP_TYPE_ICat4_ns1__searchTextResponse:
    return soap_in_ns1__searchTextResponse(soap, nullptr, nullptr, "ns1:searchTextResponse");
  case SOAP_TYPE_ICat4_ns1__searchText:
    return soap_in_ns1__searchText(soap, nullptr, nullptr, "ns1:searchText");
  case SOAP_TYPE_ICat4_ns1__luceneCommitResponse:
    return soap_in_ns1__luceneCommitResponse(soap, nullptr, nullptr, "ns1:luceneCommitResponse");
  case SOAP_TYPE_ICat4_ns1__luceneCommit:
    return soap_in_ns1__luceneCommit(soap, nullptr, nullptr, "ns1:luceneCommit");
  case SOAP_TYPE_ICat4_ns1__entityField:
    return soap_in_ns1__entityField(soap, nullptr, nullptr, "ns1:entityField");
  case SOAP_TYPE_ICat4_ns1__constraint:
    return soap_in_ns1__constraint(soap, nullptr, nullptr, "ns1:constraint");
  case SOAP_TYPE_ICat4_ns1__entityInfo:
    return soap_in_ns1__entityInfo(soap, nullptr, nullptr, "ns1:entityInfo");
  case SOAP_TYPE_ICat4_ns1__getEntityInfoResponse:
    return soap_in_ns1__getEntityInfoResponse(soap, nullptr, nullptr, "ns1:getEntityInfoResponse");
  case SOAP_TYPE_ICat4_ns1__getEntityInfo:
    return soap_in_ns1__getEntityInfo(soap, nullptr, nullptr, "ns1:getEntityInfo");
  case SOAP_TYPE_ICat4_ns1__dummyResponse:
    return soap_in_ns1__dummyResponse(soap, nullptr, nullptr, "ns1:dummyResponse");
  case SOAP_TYPE_ICat4_ns1__publicStep:
    return soap_in_ns1__publicStep(soap, nullptr, nullptr, "ns1:publicStep");
  case SOAP_TYPE_ICat4_ns1__log:
    return soap_in_ns1__log(soap, nullptr, nullptr, "ns1:log");
  case SOAP_TYPE_ICat4_ns1__relatedDatafile:
    return soap_in_ns1__relatedDatafile(soap, nullptr, nullptr, "ns1:relatedDatafile");
  case SOAP_TYPE_ICat4_ns1__shift:
    return soap_in_ns1__shift(soap, nullptr, nullptr, "ns1:shift");
  case SOAP_TYPE_ICat4_ns1__publication:
    return soap_in_ns1__publication(soap, nullptr, nullptr, "ns1:publication");
  case SOAP_TYPE_ICat4_ns1__keyword:
    return soap_in_ns1__keyword(soap, nullptr, nullptr, "ns1:keyword");
  case SOAP_TYPE_ICat4_ns1__sampleType:
    return soap_in_ns1__sampleType(soap, nullptr, nullptr, "ns1:sampleType");
  case SOAP_TYPE_ICat4_ns1__sample:
    return soap_in_ns1__sample(soap, nullptr, nullptr, "ns1:sample");
  case SOAP_TYPE_ICat4_ns1__sampleParameter:
    return soap_in_ns1__sampleParameter(soap, nullptr, nullptr, "ns1:sampleParameter");
  case SOAP_TYPE_ICat4_ns1__permissibleStringValue:
    return soap_in_ns1__permissibleStringValue(soap, nullptr, nullptr, "ns1:permissibleStringValue");
  case SOAP_TYPE_ICat4_ns1__investigationParameter:
    return soap_in_ns1__investigationParameter(soap, nullptr, nullptr, "ns1:investigationParameter");
  case SOAP_TYPE_ICat4_ns1__datasetParameter:
    return soap_in_ns1__datasetParameter(soap, nullptr, nullptr, "ns1:datasetParameter");
  case SOAP_TYPE_ICat4_ns1__datafileParameter:
    return soap_in_ns1__datafileParameter(soap, nullptr, nullptr, "ns1:datafileParameter");
  case SOAP_TYPE_ICat4_ns1__parameter:
    return soap_in_ns1__parameter(soap, nullptr, nullptr, "ns1:parameter");
  case SOAP_TYPE_ICat4_ns1__dataCollectionParameter:
    return soap_in_ns1__dataCollectionParameter(soap, nullptr, nullptr, "ns1:dataCollectionParameter");
  case SOAP_TYPE_ICat4_ns1__parameterType:
    return soap_in_ns1__parameterType(soap, nullptr, nullptr, "ns1:parameterType");
  case SOAP_TYPE_ICat4_ns1__investigationType:
    return soap_in_ns1__investigationType(soap, nullptr, nullptr, "ns1:investigationType");
  case SOAP_TYPE_ICat4_ns1__investigationInstrument:
    return soap_in_ns1__investigationInstrument(soap, nullptr, nullptr, "ns1:investigationInstrument");
  case SOAP_TYPE_ICat4_ns1__rule:
    return soap_in_ns1__rule(soap, nullptr, nullptr, "ns1:rule");
  case SOAP_TYPE_ICat4_ns1__grouping:
    return soap_in_ns1__grouping(soap, nullptr, nullptr, "ns1:grouping");
  case SOAP_TYPE_ICat4_ns1__userGroup:
    return soap_in_ns1__userGroup(soap, nullptr, nullptr, "ns1:userGroup");
  case SOAP_TYPE_ICat4_ns1__studyInvestigation:
    return soap_in_ns1__studyInvestigation(soap, nullptr, nullptr, "ns1:studyInvestigation");
  case SOAP_TYPE_ICat4_ns1__study:
    return soap_in_ns1__study(soap, nullptr, nullptr, "ns1:study");
  case SOAP_TYPE_ICat4_ns1__investigationUser:
    return soap_in_ns1__investigationUser(soap, nullptr, nullptr, "ns1:investigationUser");
  case SOAP_TYPE_ICat4_ns1__user:
    return soap_in_ns1__user(soap, nullptr, nullptr, "ns1:user");
  case SOAP_TYPE_ICat4_ns1__instrumentScientist:
    return soap_in_ns1__instrumentScientist(soap, nullptr, nullptr, "ns1:instrumentScientist");
  case SOAP_TYPE_ICat4_ns1__instrument:
    return soap_in_ns1__instrument(soap, nullptr, nullptr, "ns1:instrument");
  case SOAP_TYPE_ICat4_ns1__facilityCycle:
    return soap_in_ns1__facilityCycle(soap, nullptr, nullptr, "ns1:facilityCycle");
  case SOAP_TYPE_ICat4_ns1__datasetType:
    return soap_in_ns1__datasetType(soap, nullptr, nullptr, "ns1:datasetType");
  case SOAP_TYPE_ICat4_ns1__datafileFormat:
    return soap_in_ns1__datafileFormat(soap, nullptr, nullptr, "ns1:datafileFormat");
  case SOAP_TYPE_ICat4_ns1__job:
    return soap_in_ns1__job(soap, nullptr, nullptr, "ns1:job");
  case SOAP_TYPE_ICat4_ns1__application:
    return soap_in_ns1__application(soap, nullptr, nullptr, "ns1:application");
  case SOAP_TYPE_ICat4_ns1__facility:
    return soap_in_ns1__facility(soap, nullptr, nullptr, "ns1:facility");
  case SOAP_TYPE_ICat4_ns1__investigation:
    return soap_in_ns1__investigation(soap, nullptr, nullptr, "ns1:investigation");
  case SOAP_TYPE_ICat4_ns1__dataset:
    return soap_in_ns1__dataset(soap, nullptr, nullptr, "ns1:dataset");
  case SOAP_TYPE_ICat4_ns1__dataCollectionDataset:
    return soap_in_ns1__dataCollectionDataset(soap, nullptr, nullptr, "ns1:dataCollectionDataset");
  case SOAP_TYPE_ICat4_ns1__dataCollection:
    return soap_in_ns1__dataCollection(soap, nullptr, nullptr, "ns1:dataCollection");
  case SOAP_TYPE_ICat4_ns1__dataCollectionDatafile:
    return soap_in_ns1__dataCollectionDatafile(soap, nullptr, nullptr, "ns1:dataCollectionDatafile");
  case SOAP_TYPE_ICat4_ns1__datafile:
    return soap_in_ns1__datafile(soap, nullptr, nullptr, "ns1:datafile");
  case SOAP_TYPE_ICat4_ns1__dummy:
    return soap_in_ns1__dummy(soap, nullptr, nullptr, "ns1:dummy");
  case SOAP_TYPE_ICat4_ns1__loginResponse:
    return soap_in_ns1__loginResponse(soap, nullptr, nullptr, "ns1:loginResponse");
  case SOAP_TYPE_ICat4_ns1__login:
    return soap_in_ns1__login(soap, nullptr, nullptr, "ns1:login");
  case SOAP_TYPE_ICat4_ns1__refreshResponse:
    return soap_in_ns1__refreshResponse(soap, nullptr, nullptr, "ns1:refreshResponse");
  case SOAP_TYPE_ICat4_ns1__refresh:
    return soap_in_ns1__refresh(soap, nullptr, nullptr, "ns1:refresh");
  case SOAP_TYPE_ICat4_ns1__getUserNameResponse:
    return soap_in_ns1__getUserNameResponse(soap, nullptr, nullptr, "ns1:getUserNameResponse");
  case SOAP_TYPE_ICat4_ns1__getUserName:
    return soap_in_ns1__getUserName(soap, nullptr, nullptr, "ns1:getUserName");
  case SOAP_TYPE_ICat4_ns1__deleteManyResponse:
    return soap_in_ns1__deleteManyResponse(soap, nullptr, nullptr, "ns1:deleteManyResponse");
  case SOAP_TYPE_ICat4_ns1__deleteMany:
    return soap_in_ns1__deleteMany(soap, nullptr, nullptr, "ns1:deleteMany");
  case SOAP_TYPE_ICat4_ns1__updateResponse:
    return soap_in_ns1__updateResponse(soap, nullptr, nullptr, "ns1:updateResponse");
  case SOAP_TYPE_ICat4_ns1__update:
    return soap_in_ns1__update(soap, nullptr, nullptr, "ns1:update");
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse:
    return soap_in_ns1__luceneGetPopulatingResponse(soap, nullptr, nullptr, "ns1:luceneGetPopulatingResponse");
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulating:
    return soap_in_ns1__luceneGetPopulating(soap, nullptr, nullptr, "ns1:luceneGetPopulating");
  case SOAP_TYPE_ICat4_ns1__getApiVersionResponse:
    return soap_in_ns1__getApiVersionResponse(soap, nullptr, nullptr, "ns1:getApiVersionResponse");
  case SOAP_TYPE_ICat4_ns1__getApiVersion:
    return soap_in_ns1__getApiVersion(soap, nullptr, nullptr, "ns1:getApiVersion");
  case SOAP_TYPE_ICat4_ns1__getEntityNamesResponse:
    return soap_in_ns1__getEntityNamesResponse(soap, nullptr, nullptr, "ns1:getEntityNamesResponse");
  case SOAP_TYPE_ICat4_ns1__getEntityNames:
    return soap_in_ns1__getEntityNames(soap, nullptr, nullptr, "ns1:getEntityNames");
  case SOAP_TYPE_ICat4_ns1__getResponse:
    return soap_in_ns1__getResponse(soap, nullptr, nullptr, "ns1:getResponse");
  case SOAP_TYPE_ICat4_ns1__get:
    return soap_in_ns1__get(soap, nullptr, nullptr, "ns1:get");
  case SOAP_TYPE_ICat4_ns1__lucenePopulateResponse:
    return soap_in_ns1__lucenePopulateResponse(soap, nullptr, nullptr, "ns1:lucenePopulateResponse");
  case SOAP_TYPE_ICat4_ns1__lucenePopulate:
    return soap_in_ns1__lucenePopulate(soap, nullptr, nullptr, "ns1:lucenePopulate");
  case SOAP_TYPE_ICat4_ns1__luceneSearchResponse:
    return soap_in_ns1__luceneSearchResponse(soap, nullptr, nullptr, "ns1:luceneSearchResponse");
  case SOAP_TYPE_ICat4_ns1__luceneSearch:
    return soap_in_ns1__luceneSearch(soap, nullptr, nullptr, "ns1:luceneSearch");
  case SOAP_TYPE_ICat4_ns1__getPropertiesResponse:
    return soap_in_ns1__getPropertiesResponse(soap, nullptr, nullptr, "ns1:getPropertiesResponse");
  case SOAP_TYPE_ICat4_ns1__getProperties:
    return soap_in_ns1__getProperties(soap, nullptr, nullptr, "ns1:getProperties");
  case SOAP_TYPE_ICat4_ns1__createResponse:
    return soap_in_ns1__createResponse(soap, nullptr, nullptr, "ns1:createResponse");
  case SOAP_TYPE_ICat4_ns1__create:
    return soap_in_ns1__create(soap, nullptr, nullptr, "ns1:create");
  case SOAP_TYPE_ICat4_ns1__createManyResponse:
    return soap_in_ns1__createManyResponse(soap, nullptr, nullptr, "ns1:createManyResponse");
  case SOAP_TYPE_ICat4_ns1__entityBaseBean:
    return soap_in_ns1__entityBaseBean(soap, nullptr, nullptr, "ns1:entityBaseBean");
  case SOAP_TYPE_ICat4_ns1__createMany:
    return soap_in_ns1__createMany(soap, nullptr, nullptr, "ns1:createMany");
  case SOAP_TYPE_ICat4_ns1__IcatException:
    return soap_in_ns1__IcatException(soap, nullptr, nullptr, "ns1:IcatException");
  case SOAP_TYPE_ICat4_ns1__luceneClearResponse:
    return soap_in_ns1__luceneClearResponse(soap, nullptr, nullptr, "ns1:luceneClearResponse");
  case SOAP_TYPE_ICat4_ns1__luceneClear:
    return soap_in_ns1__luceneClear(soap, nullptr, nullptr, "ns1:luceneClear");
  case SOAP_TYPE_ICat4_std__string:
    return soap_in_std__string(soap, nullptr, nullptr, "xsd:string");
  case SOAP_TYPE_ICat4_xsd__string:
    return soap_in_xsd__string(soap, nullptr, nullptr, "xsd:string");
  case SOAP_TYPE_ICat4_xsd__long:
    return soap_in_xsd__long(soap, nullptr, nullptr, "xsd:long");
  case SOAP_TYPE_ICat4_xsd__int:
    return soap_in_xsd__int(soap, nullptr, nullptr, "xsd:int");
  case SOAP_TYPE_ICat4_xsd__double:
    return soap_in_xsd__double(soap, nullptr, nullptr, "xsd:double");
  case SOAP_TYPE_ICat4_xsd__dateTime:
    return soap_in_xsd__dateTime(soap, nullptr, nullptr, "xsd:dateTime");
  case SOAP_TYPE_ICat4_xsd__boolean:
    return soap_in_xsd__boolean(soap, nullptr, nullptr, "xsd:boolean");
  case SOAP_TYPE_ICat4_xsd__anyType:
    return soap_in_xsd__anyType(soap, nullptr, nullptr, "xsd:anyType");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfoResponse:
    return soap_in_PointerTons1__getEntityInfoResponse(soap, nullptr, nullptr, "ns1:getEntityInfoResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfo:
    return soap_in_PointerTons1__getEntityInfo(soap, nullptr, nullptr, "ns1:getEntityInfo");
  case SOAP_TYPE_ICat4_PointerTons1__deleteManyResponse:
    return soap_in_PointerTons1__deleteManyResponse(soap, nullptr, nullptr, "ns1:deleteManyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__deleteMany:
    return soap_in_PointerTons1__deleteMany(soap, nullptr, nullptr, "ns1:deleteMany");
  case SOAP_TYPE_ICat4_PointerTons1__createManyResponse:
    return soap_in_PointerTons1__createManyResponse(soap, nullptr, nullptr, "ns1:createManyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__createMany:
    return soap_in_PointerTons1__createMany(soap, nullptr, nullptr, "ns1:createMany");
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulatingResponse:
    return soap_in_PointerTons1__luceneGetPopulatingResponse(soap, nullptr, nullptr, "ns1:luceneGetPopulatingResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulating:
    return soap_in_PointerTons1__luceneGetPopulating(soap, nullptr, nullptr, "ns1:luceneGetPopulating");
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearchResponse:
    return soap_in_PointerTons1__luceneSearchResponse(soap, nullptr, nullptr, "ns1:luceneSearchResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearch:
    return soap_in_PointerTons1__luceneSearch(soap, nullptr, nullptr, "ns1:luceneSearch");
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommitResponse:
    return soap_in_PointerTons1__luceneCommitResponse(soap, nullptr, nullptr, "ns1:luceneCommitResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommit:
    return soap_in_PointerTons1__luceneCommit(soap, nullptr, nullptr, "ns1:luceneCommit");
  case SOAP_TYPE_ICat4_PointerTons1__luceneClearResponse:
    return soap_in_PointerTons1__luceneClearResponse(soap, nullptr, nullptr, "ns1:luceneClearResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneClear:
    return soap_in_PointerTons1__luceneClear(soap, nullptr, nullptr, "ns1:luceneClear");
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulateResponse:
    return soap_in_PointerTons1__lucenePopulateResponse(soap, nullptr, nullptr, "ns1:lucenePopulateResponse");
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulate:
    return soap_in_PointerTons1__lucenePopulate(soap, nullptr, nullptr, "ns1:lucenePopulate");
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowedResponse:
    return soap_in_PointerTons1__isAccessAllowedResponse(soap, nullptr, nullptr, "ns1:isAccessAllowedResponse");
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowed:
    return soap_in_PointerTons1__isAccessAllowed(soap, nullptr, nullptr, "ns1:isAccessAllowed");
  case SOAP_TYPE_ICat4_PointerTons1__searchTextResponse:
    return soap_in_PointerTons1__searchTextResponse(soap, nullptr, nullptr, "ns1:searchTextResponse");
  case SOAP_TYPE_ICat4_PointerTons1__searchText:
    return soap_in_PointerTons1__searchText(soap, nullptr, nullptr, "ns1:searchText");
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutesResponse:
    return soap_in_PointerTons1__getRemainingMinutesResponse(soap, nullptr, nullptr, "ns1:getRemainingMinutesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutes:
    return soap_in_PointerTons1__getRemainingMinutes(soap, nullptr, nullptr, "ns1:getRemainingMinutes");
  case SOAP_TYPE_ICat4_PointerTons1__logoutResponse:
    return soap_in_PointerTons1__logoutResponse(soap, nullptr, nullptr, "ns1:logoutResponse");
  case SOAP_TYPE_ICat4_PointerTons1__logout:
    return soap_in_PointerTons1__logout(soap, nullptr, nullptr, "ns1:logout");
  case SOAP_TYPE_ICat4_PointerTons1__dummyResponse:
    return soap_in_PointerTons1__dummyResponse(soap, nullptr, nullptr, "ns1:dummyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__dummy:
    return soap_in_PointerTons1__dummy(soap, nullptr, nullptr, "ns1:dummy");
  case SOAP_TYPE_ICat4_PointerTons1__refreshResponse:
    return soap_in_PointerTons1__refreshResponse(soap, nullptr, nullptr, "ns1:refreshResponse");
  case SOAP_TYPE_ICat4_PointerTons1__refresh:
    return soap_in_PointerTons1__refresh(soap, nullptr, nullptr, "ns1:refresh");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNamesResponse:
    return soap_in_PointerTons1__getEntityNamesResponse(soap, nullptr, nullptr, "ns1:getEntityNamesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNames:
    return soap_in_PointerTons1__getEntityNames(soap, nullptr, nullptr, "ns1:getEntityNames");
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersionResponse:
    return soap_in_PointerTons1__getApiVersionResponse(soap, nullptr, nullptr, "ns1:getApiVersionResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersion:
    return soap_in_PointerTons1__getApiVersion(soap, nullptr, nullptr, "ns1:getApiVersion");
  case SOAP_TYPE_ICat4_PointerTons1__updateResponse:
    return soap_in_PointerTons1__updateResponse(soap, nullptr, nullptr, "ns1:updateResponse");
  case SOAP_TYPE_ICat4_PointerTons1__update:
    return soap_in_PointerTons1__update(soap, nullptr, nullptr, "ns1:update");
  case SOAP_TYPE_ICat4_PointerTons1__createResponse:
    return soap_in_PointerTons1__createResponse(soap, nullptr, nullptr, "ns1:createResponse");
  case SOAP_TYPE_ICat4_PointerTons1__create:
    return soap_in_PointerTons1__create(soap, nullptr, nullptr, "ns1:create");
  case SOAP_TYPE_ICat4_PointerTons1__searchResponse:
    return soap_in_PointerTons1__searchResponse(soap, nullptr, nullptr, "ns1:searchResponse");
  case SOAP_TYPE_ICat4_PointerTons1__search:
    return soap_in_PointerTons1__search(soap, nullptr, nullptr, "ns1:search");
  case SOAP_TYPE_ICat4_PointerTons1__deleteResponse:
    return soap_in_PointerTons1__deleteResponse(soap, nullptr, nullptr, "ns1:deleteResponse");
  case SOAP_TYPE_ICat4_PointerTons1__delete:
    return soap_in_PointerTons1__delete(soap, nullptr, nullptr, "ns1:delete");
  case SOAP_TYPE_ICat4_PointerTons1__getPropertiesResponse:
    return soap_in_PointerTons1__getPropertiesResponse(soap, nullptr, nullptr, "ns1:getPropertiesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getProperties:
    return soap_in_PointerTons1__getProperties(soap, nullptr, nullptr, "ns1:getProperties");
  case SOAP_TYPE_ICat4_PointerTons1__getResponse:
    return soap_in_PointerTons1__getResponse(soap, nullptr, nullptr, "ns1:getResponse");
  case SOAP_TYPE_ICat4_PointerTons1__get:
    return soap_in_PointerTons1__get(soap, nullptr, nullptr, "ns1:get");
  case SOAP_TYPE_ICat4_PointerTons1__getUserNameResponse:
    return soap_in_PointerTons1__getUserNameResponse(soap, nullptr, nullptr, "ns1:getUserNameResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getUserName:
    return soap_in_PointerTons1__getUserName(soap, nullptr, nullptr, "ns1:getUserName");
  case SOAP_TYPE_ICat4_PointerTons1__loginResponse:
    return soap_in_PointerTons1__loginResponse(soap, nullptr, nullptr, "ns1:loginResponse");
  case SOAP_TYPE_ICat4_PointerTons1__login:
    return soap_in_PointerTons1__login(soap, nullptr, nullptr, "ns1:login");
  case SOAP_TYPE_ICat4_PointerTons1__IcatException:
    return soap_in_PointerTons1__IcatException(soap, nullptr, nullptr, "ns1:IcatException");
  case SOAP_TYPE_ICat4_PointerTons1__parameterValueType:
    return soap_in_PointerTons1__parameterValueType(soap, nullptr, nullptr, "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_PointerTons1__permissibleStringValue:
    return soap_in_PointerTons1__permissibleStringValue(soap, nullptr, nullptr, "ns1:permissibleStringValue");
  case SOAP_TYPE_ICat4_PointerTodouble:
    return soap_in_PointerTodouble(soap, nullptr, nullptr, "xsd:double");
  case SOAP_TYPE_ICat4_PointerTons1__rule:
    return soap_in_PointerTons1__rule(soap, nullptr, nullptr, "ns1:rule");
  case SOAP_TYPE_ICat4_PointerTons1__sampleType:
    return soap_in_PointerTons1__sampleType(soap, nullptr, nullptr, "ns1:sampleType");
  case SOAP_TYPE_ICat4_PointerTons1__investigationParameter:
    return soap_in_PointerTons1__investigationParameter(soap, nullptr, nullptr, "ns1:investigationParameter");
  case SOAP_TYPE_ICat4_PointerTons1__investigationInstrument:
    return soap_in_PointerTons1__investigationInstrument(soap, nullptr, nullptr, "ns1:investigationInstrument");
  case SOAP_TYPE_ICat4_PointerTons1__accessType:
    return soap_in_PointerTons1__accessType(soap, nullptr, nullptr, "ns1:accessType");
  case SOAP_TYPE_ICat4_PointerToxsd__anyType:
    return soap_in_PointerToxsd__anyType(soap, nullptr, nullptr, "xsd:anyType");
  case SOAP_TYPE_ICat4_PointerToint:
    return soap_in_PointerToint(soap, nullptr, nullptr, "xsd:int");
  case SOAP_TYPE_ICat4_PointerTons1__relType:
    return soap_in_PointerTons1__relType(soap, nullptr, nullptr, "ns1:relType");
  case SOAP_TYPE_ICat4_PointerTons1__entityField:
    return soap_in_PointerTons1__entityField(soap, nullptr, nullptr, "ns1:entityField");
  case SOAP_TYPE_ICat4_PointerTons1__constraint:
    return soap_in_PointerTons1__constraint(soap, nullptr, nullptr, "ns1:constraint");
  case SOAP_TYPE_ICat4_PointerTons1__entityInfo:
    return soap_in_PointerTons1__entityInfo(soap, nullptr, nullptr, "ns1:entityInfo");
  case SOAP_TYPE_ICat4_PointerTons1__publicStep:
    return soap_in_PointerTons1__publicStep(soap, nullptr, nullptr, "ns1:publicStep");
  case SOAP_TYPE_ICat4_PointerTons1__log:
    return soap_in_PointerTons1__log(soap, nullptr, nullptr, "ns1:log");
  case SOAP_TYPE_ICat4_PointerTons1__userGroup:
    return soap_in_PointerTons1__userGroup(soap, nullptr, nullptr, "ns1:userGroup");
  case SOAP_TYPE_ICat4_PointerTons1__grouping:
    return soap_in_PointerTons1__grouping(soap, nullptr, nullptr, "ns1:grouping");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDatafile:
    return soap_in_PointerTons1__dataCollectionDatafile(soap, nullptr, nullptr, "ns1:dataCollectionDatafile");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDataset:
    return soap_in_PointerTons1__dataCollectionDataset(soap, nullptr, nullptr, "ns1:dataCollectionDataset");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionParameter:
    return soap_in_PointerTons1__dataCollectionParameter(soap, nullptr, nullptr, "ns1:dataCollectionParameter");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollection:
    return soap_in_PointerTons1__dataCollection(soap, nullptr, nullptr, "ns1:dataCollection");
  case SOAP_TYPE_ICat4_PointerTons1__job:
    return soap_in_PointerTons1__job(soap, nullptr, nullptr, "ns1:job");
  case SOAP_TYPE_ICat4_PointerTons1__application:
    return soap_in_PointerTons1__application(soap, nullptr, nullptr, "ns1:application");
  case SOAP_TYPE_ICat4_PointerTons1__studyStatus:
    return soap_in_PointerTons1__studyStatus(soap, nullptr, nullptr, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_PointerTons1__studyInvestigation:
    return soap_in_PointerTons1__studyInvestigation(soap, nullptr, nullptr, "ns1:studyInvestigation");
  case SOAP_TYPE_ICat4_PointerTons1__study:
    return soap_in_PointerTons1__study(soap, nullptr, nullptr, "ns1:study");
  case SOAP_TYPE_ICat4_PointerTons1__shift:
    return soap_in_PointerTons1__shift(soap, nullptr, nullptr, "ns1:shift");
  case SOAP_TYPE_ICat4_PointerTons1__sampleParameter:
    return soap_in_PointerTons1__sampleParameter(soap, nullptr, nullptr, "ns1:sampleParameter");
  case SOAP_TYPE_ICat4_PointerTons1__sample:
    return soap_in_PointerTons1__sample(soap, nullptr, nullptr, "ns1:sample");
  case SOAP_TYPE_ICat4_PointerTons1__relatedDatafile:
    return soap_in_PointerTons1__relatedDatafile(soap, nullptr, nullptr, "ns1:relatedDatafile");
  case SOAP_TYPE_ICat4_PointerTons1__publication:
    return soap_in_PointerTons1__publication(soap, nullptr, nullptr, "ns1:publication");
  case SOAP_TYPE_ICat4_PointerTons1__parameterType:
    return soap_in_PointerTons1__parameterType(soap, nullptr, nullptr, "ns1:parameterType");
  case SOAP_TYPE_ICat4_PointerTons1__keyword:
    return soap_in_PointerTons1__keyword(soap, nullptr, nullptr, "ns1:keyword");
  case SOAP_TYPE_ICat4_PointerTons1__investigationUser:
    return soap_in_PointerTons1__investigationUser(soap, nullptr, nullptr, "ns1:investigationUser");
  case SOAP_TYPE_ICat4_PointerTons1__investigationType:
    return soap_in_PointerTons1__investigationType(soap, nullptr, nullptr, "ns1:investigationType");
  case SOAP_TYPE_ICat4_PointerTons1__investigation:
    return soap_in_PointerTons1__investigation(soap, nullptr, nullptr, "ns1:investigation");
  case SOAP_TYPE_ICat4_PointerTons1__instrument:
    return soap_in_PointerTons1__instrument(soap, nullptr, nullptr, "ns1:instrument");
  case SOAP_TYPE_ICat4_PointerTons1__user:
    return soap_in_PointerTons1__user(soap, nullptr, nullptr, "ns1:user");
  case SOAP_TYPE_ICat4_PointerTons1__instrumentScientist:
    return soap_in_PointerTons1__instrumentScientist(soap, nullptr, nullptr, "ns1:instrumentScientist");
  case SOAP_TYPE_ICat4_PointerTons1__facilityCycle:
    return soap_in_PointerTons1__facilityCycle(soap, nullptr, nullptr, "ns1:facilityCycle");
  case SOAP_TYPE_ICat4_PointerTons1__facility:
    return soap_in_PointerTons1__facility(soap, nullptr, nullptr, "ns1:facility");
  case SOAP_TYPE_ICat4_PointerTons1__datasetType:
    return soap_in_PointerTons1__datasetType(soap, nullptr, nullptr, "ns1:datasetType");
  case SOAP_TYPE_ICat4_PointerTons1__datasetParameter:
    return soap_in_PointerTons1__datasetParameter(soap, nullptr, nullptr, "ns1:datasetParameter");
  case SOAP_TYPE_ICat4_PointerTons1__dataset:
    return soap_in_PointerTons1__dataset(soap, nullptr, nullptr, "ns1:dataset");
  case SOAP_TYPE_ICat4_PointerTons1__datafileParameter:
    return soap_in_PointerTons1__datafileParameter(soap, nullptr, nullptr, "ns1:datafileParameter");
  case SOAP_TYPE_ICat4_PointerTons1__datafileFormat:
    return soap_in_PointerTons1__datafileFormat(soap, nullptr, nullptr, "ns1:datafileFormat");
  case SOAP_TYPE_ICat4_PointerTons1__datafile:
    return soap_in_PointerTons1__datafile(soap, nullptr, nullptr, "ns1:datafile");
  case SOAP_TYPE_ICat4_PointerToLONG64:
    return soap_in_PointerToLONG64(soap, nullptr, nullptr, "xsd:long");
  case SOAP_TYPE_ICat4_PointerTotime:
    return soap_in_PointerTotime(soap, nullptr, nullptr, "xsd:dateTime");
  case SOAP_TYPE_ICat4_PointerTons1__entityBaseBean:
    return soap_in_PointerTons1__entityBaseBean(soap, nullptr, nullptr, "ns1:entityBaseBean");
  case SOAP_TYPE_ICat4_PointerTons1__icatExceptionType:
    return soap_in_PointerTons1__icatExceptionType(soap, nullptr, nullptr, "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_PointerTostd__string:
    return soap_in_PointerTostd__string(soap, nullptr, nullptr, "xsd:string");
  case SOAP_TYPE_ICat4__QName: {
    char **s;
    s = soap_in__QName(soap, nullptr, nullptr, "xsd:QName");
    return s ? *s : nullptr;
  }
  case SOAP_TYPE_ICat4_string: {
    char **s;
    s = soap_in_string(soap, nullptr, nullptr, "xsd:string");
    return s ? *s : nullptr;
  }
  default:
#endif
  {
    const char *t = soap->type;
    if (!*t)
      t = soap->tag;
    if (!soap_match_tag(soap, t, "ns1:accessType")) {
      *type = SOAP_TYPE_ICat4_ns1__accessType_;
      return soap_in_ns1__accessType_(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:relType")) {
      *type = SOAP_TYPE_ICat4_ns1__relType_;
      return soap_in_ns1__relType_(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:parameterValueType")) {
      *type = SOAP_TYPE_ICat4_ns1__parameterValueType_;
      return soap_in_ns1__parameterValueType_(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:studyStatus")) {
      *type = SOAP_TYPE_ICat4_ns1__studyStatus_;
      return soap_in_ns1__studyStatus_(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:icatExceptionType")) {
      *type = SOAP_TYPE_ICat4_ns1__icatExceptionType_;
      return soap_in_ns1__icatExceptionType_(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getRemainingMinutesResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse;
      return soap_in_ns1__getRemainingMinutesResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getRemainingMinutes")) {
      *type = SOAP_TYPE_ICat4_ns1__getRemainingMinutes;
      return soap_in_ns1__getRemainingMinutes(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:logoutResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__logoutResponse;
      return soap_in_ns1__logoutResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:logout")) {
      *type = SOAP_TYPE_ICat4_ns1__logout;
      return soap_in_ns1__logout(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:searchResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__searchResponse;
      return soap_in_ns1__searchResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:search")) {
      *type = SOAP_TYPE_ICat4_ns1__search;
      return soap_in_ns1__search(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:isAccessAllowedResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse;
      return soap_in_ns1__isAccessAllowedResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:isAccessAllowed")) {
      *type = SOAP_TYPE_ICat4_ns1__isAccessAllowed;
      return soap_in_ns1__isAccessAllowed(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:deleteResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__deleteResponse;
      return soap_in_ns1__deleteResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:delete")) {
      *type = SOAP_TYPE_ICat4_ns1__delete;
      return soap_in_ns1__delete(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:searchTextResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__searchTextResponse;
      return soap_in_ns1__searchTextResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:searchText")) {
      *type = SOAP_TYPE_ICat4_ns1__searchText;
      return soap_in_ns1__searchText(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneCommitResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneCommitResponse;
      return soap_in_ns1__luceneCommitResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneCommit")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneCommit;
      return soap_in_ns1__luceneCommit(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:entityField")) {
      *type = SOAP_TYPE_ICat4_ns1__entityField;
      return soap_in_ns1__entityField(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:constraint")) {
      *type = SOAP_TYPE_ICat4_ns1__constraint;
      return soap_in_ns1__constraint(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:entityInfo")) {
      *type = SOAP_TYPE_ICat4_ns1__entityInfo;
      return soap_in_ns1__entityInfo(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getEntityInfoResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getEntityInfoResponse;
      return soap_in_ns1__getEntityInfoResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getEntityInfo")) {
      *type = SOAP_TYPE_ICat4_ns1__getEntityInfo;
      return soap_in_ns1__getEntityInfo(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dummyResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__dummyResponse;
      return soap_in_ns1__dummyResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:publicStep")) {
      *type = SOAP_TYPE_ICat4_ns1__publicStep;
      return soap_in_ns1__publicStep(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:log")) {
      *type = SOAP_TYPE_ICat4_ns1__log;
      return soap_in_ns1__log(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:relatedDatafile")) {
      *type = SOAP_TYPE_ICat4_ns1__relatedDatafile;
      return soap_in_ns1__relatedDatafile(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:shift")) {
      *type = SOAP_TYPE_ICat4_ns1__shift;
      return soap_in_ns1__shift(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:publication")) {
      *type = SOAP_TYPE_ICat4_ns1__publication;
      return soap_in_ns1__publication(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:keyword")) {
      *type = SOAP_TYPE_ICat4_ns1__keyword;
      return soap_in_ns1__keyword(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:sampleType")) {
      *type = SOAP_TYPE_ICat4_ns1__sampleType;
      return soap_in_ns1__sampleType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:sample")) {
      *type = SOAP_TYPE_ICat4_ns1__sample;
      return soap_in_ns1__sample(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:sampleParameter")) {
      *type = SOAP_TYPE_ICat4_ns1__sampleParameter;
      return soap_in_ns1__sampleParameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:permissibleStringValue")) {
      *type = SOAP_TYPE_ICat4_ns1__permissibleStringValue;
      return soap_in_ns1__permissibleStringValue(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:investigationParameter")) {
      *type = SOAP_TYPE_ICat4_ns1__investigationParameter;
      return soap_in_ns1__investigationParameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:datasetParameter")) {
      *type = SOAP_TYPE_ICat4_ns1__datasetParameter;
      return soap_in_ns1__datasetParameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:datafileParameter")) {
      *type = SOAP_TYPE_ICat4_ns1__datafileParameter;
      return soap_in_ns1__datafileParameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:parameter")) {
      *type = SOAP_TYPE_ICat4_ns1__parameter;
      return soap_in_ns1__parameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dataCollectionParameter")) {
      *type = SOAP_TYPE_ICat4_ns1__dataCollectionParameter;
      return soap_in_ns1__dataCollectionParameter(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:parameterType")) {
      *type = SOAP_TYPE_ICat4_ns1__parameterType;
      return soap_in_ns1__parameterType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:investigationType")) {
      *type = SOAP_TYPE_ICat4_ns1__investigationType;
      return soap_in_ns1__investigationType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:investigationInstrument")) {
      *type = SOAP_TYPE_ICat4_ns1__investigationInstrument;
      return soap_in_ns1__investigationInstrument(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:rule")) {
      *type = SOAP_TYPE_ICat4_ns1__rule;
      return soap_in_ns1__rule(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:grouping")) {
      *type = SOAP_TYPE_ICat4_ns1__grouping;
      return soap_in_ns1__grouping(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:userGroup")) {
      *type = SOAP_TYPE_ICat4_ns1__userGroup;
      return soap_in_ns1__userGroup(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:studyInvestigation")) {
      *type = SOAP_TYPE_ICat4_ns1__studyInvestigation;
      return soap_in_ns1__studyInvestigation(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:study")) {
      *type = SOAP_TYPE_ICat4_ns1__study;
      return soap_in_ns1__study(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:investigationUser")) {
      *type = SOAP_TYPE_ICat4_ns1__investigationUser;
      return soap_in_ns1__investigationUser(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:user")) {
      *type = SOAP_TYPE_ICat4_ns1__user;
      return soap_in_ns1__user(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:instrumentScientist")) {
      *type = SOAP_TYPE_ICat4_ns1__instrumentScientist;
      return soap_in_ns1__instrumentScientist(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:instrument")) {
      *type = SOAP_TYPE_ICat4_ns1__instrument;
      return soap_in_ns1__instrument(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:facilityCycle")) {
      *type = SOAP_TYPE_ICat4_ns1__facilityCycle;
      return soap_in_ns1__facilityCycle(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:datasetType")) {
      *type = SOAP_TYPE_ICat4_ns1__datasetType;
      return soap_in_ns1__datasetType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:datafileFormat")) {
      *type = SOAP_TYPE_ICat4_ns1__datafileFormat;
      return soap_in_ns1__datafileFormat(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:job")) {
      *type = SOAP_TYPE_ICat4_ns1__job;
      return soap_in_ns1__job(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:application")) {
      *type = SOAP_TYPE_ICat4_ns1__application;
      return soap_in_ns1__application(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:facility")) {
      *type = SOAP_TYPE_ICat4_ns1__facility;
      return soap_in_ns1__facility(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:investigation")) {
      *type = SOAP_TYPE_ICat4_ns1__investigation;
      return soap_in_ns1__investigation(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dataset")) {
      *type = SOAP_TYPE_ICat4_ns1__dataset;
      return soap_in_ns1__dataset(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dataCollectionDataset")) {
      *type = SOAP_TYPE_ICat4_ns1__dataCollectionDataset;
      return soap_in_ns1__dataCollectionDataset(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dataCollection")) {
      *type = SOAP_TYPE_ICat4_ns1__dataCollection;
      return soap_in_ns1__dataCollection(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dataCollectionDatafile")) {
      *type = SOAP_TYPE_ICat4_ns1__dataCollectionDatafile;
      return soap_in_ns1__dataCollectionDatafile(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:datafile")) {
      *type = SOAP_TYPE_ICat4_ns1__datafile;
      return soap_in_ns1__datafile(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:dummy")) {
      *type = SOAP_TYPE_ICat4_ns1__dummy;
      return soap_in_ns1__dummy(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:loginResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__loginResponse;
      return soap_in_ns1__loginResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:login")) {
      *type = SOAP_TYPE_ICat4_ns1__login;
      return soap_in_ns1__login(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:refreshResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__refreshResponse;
      return soap_in_ns1__refreshResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:refresh")) {
      *type = SOAP_TYPE_ICat4_ns1__refresh;
      return soap_in_ns1__refresh(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getUserNameResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getUserNameResponse;
      return soap_in_ns1__getUserNameResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getUserName")) {
      *type = SOAP_TYPE_ICat4_ns1__getUserName;
      return soap_in_ns1__getUserName(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:deleteManyResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__deleteManyResponse;
      return soap_in_ns1__deleteManyResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:deleteMany")) {
      *type = SOAP_TYPE_ICat4_ns1__deleteMany;
      return soap_in_ns1__deleteMany(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:updateResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__updateResponse;
      return soap_in_ns1__updateResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:update")) {
      *type = SOAP_TYPE_ICat4_ns1__update;
      return soap_in_ns1__update(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneGetPopulatingResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse;
      return soap_in_ns1__luceneGetPopulatingResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneGetPopulating")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneGetPopulating;
      return soap_in_ns1__luceneGetPopulating(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getApiVersionResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getApiVersionResponse;
      return soap_in_ns1__getApiVersionResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getApiVersion")) {
      *type = SOAP_TYPE_ICat4_ns1__getApiVersion;
      return soap_in_ns1__getApiVersion(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getEntityNamesResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getEntityNamesResponse;
      return soap_in_ns1__getEntityNamesResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getEntityNames")) {
      *type = SOAP_TYPE_ICat4_ns1__getEntityNames;
      return soap_in_ns1__getEntityNames(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getResponse;
      return soap_in_ns1__getResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:get")) {
      *type = SOAP_TYPE_ICat4_ns1__get;
      return soap_in_ns1__get(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:lucenePopulateResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__lucenePopulateResponse;
      return soap_in_ns1__lucenePopulateResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:lucenePopulate")) {
      *type = SOAP_TYPE_ICat4_ns1__lucenePopulate;
      return soap_in_ns1__lucenePopulate(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneSearchResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneSearchResponse;
      return soap_in_ns1__luceneSearchResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneSearch")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneSearch;
      return soap_in_ns1__luceneSearch(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getPropertiesResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__getPropertiesResponse;
      return soap_in_ns1__getPropertiesResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:getProperties")) {
      *type = SOAP_TYPE_ICat4_ns1__getProperties;
      return soap_in_ns1__getProperties(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:createResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__createResponse;
      return soap_in_ns1__createResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:create")) {
      *type = SOAP_TYPE_ICat4_ns1__create;
      return soap_in_ns1__create(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:createManyResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__createManyResponse;
      return soap_in_ns1__createManyResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:entityBaseBean")) {
      *type = SOAP_TYPE_ICat4_ns1__entityBaseBean;
      return soap_in_ns1__entityBaseBean(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:createMany")) {
      *type = SOAP_TYPE_ICat4_ns1__createMany;
      return soap_in_ns1__createMany(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:IcatException")) {
      *type = SOAP_TYPE_ICat4_ns1__IcatException;
      return soap_in_ns1__IcatException(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneClearResponse")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneClearResponse;
      return soap_in_ns1__luceneClearResponse(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:luceneClear")) {
      *type = SOAP_TYPE_ICat4_ns1__luceneClear;
      return soap_in_ns1__luceneClear(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      *type = SOAP_TYPE_ICat4_std__string;
      return soap_in_std__string(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      *type = SOAP_TYPE_ICat4_xsd__string;
      return soap_in_xsd__string(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:long")) {
      *type = SOAP_TYPE_ICat4_xsd__long;
      return soap_in_xsd__long(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_ICat4_xsd__int;
      return soap_in_xsd__int(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:double")) {
      *type = SOAP_TYPE_ICat4_xsd__double;
      return soap_in_xsd__double(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:dateTime")) {
      *type = SOAP_TYPE_ICat4_xsd__dateTime;
      return soap_in_xsd__dateTime(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:boolean")) {
      *type = SOAP_TYPE_ICat4_xsd__boolean;
      return soap_in_xsd__boolean(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:anyType")) {
      *type = SOAP_TYPE_ICat4_xsd__anyType;
      return soap_in_xsd__anyType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:byte")) {
      *type = SOAP_TYPE_ICat4_byte;
      return soap_in_byte(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_ICat4_int;
      return soap_in_int(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:long")) {
      *type = SOAP_TYPE_ICat4_LONG64;
      return soap_in_LONG64(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:double")) {
      *type = SOAP_TYPE_ICat4_double;
      return soap_in_double(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:dateTime")) {
      *type = SOAP_TYPE_ICat4_time;
      return soap_in_time(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:accessType")) {
      *type = SOAP_TYPE_ICat4_ns1__accessType;
      return soap_in_ns1__accessType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:relType")) {
      *type = SOAP_TYPE_ICat4_ns1__relType;
      return soap_in_ns1__relType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:parameterValueType")) {
      *type = SOAP_TYPE_ICat4_ns1__parameterValueType;
      return soap_in_ns1__parameterValueType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:studyStatus")) {
      *type = SOAP_TYPE_ICat4_ns1__studyStatus;
      return soap_in_ns1__studyStatus(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:icatExceptionType")) {
      *type = SOAP_TYPE_ICat4_ns1__icatExceptionType;
      return soap_in_ns1__icatExceptionType(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:boolean")) {
      *type = SOAP_TYPE_ICat4_bool;
      return soap_in_bool(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      char **s;
      *type = SOAP_TYPE_ICat4__QName;
      s = soap_in__QName(soap, nullptr, nullptr, nullptr);
      return s ? *s : nullptr;
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      char **s;
      *type = SOAP_TYPE_ICat4_string;
      s = soap_in_string(soap, nullptr, nullptr, nullptr);
      return s ? *s : nullptr;
    }
    t = soap->tag;
    if (!soap_match_tag(soap, t, "ns1:login-credentials-entry")) {
      *type = SOAP_TYPE_ICat4__ns1__login_credentials_entry;
      return soap_in__ns1__login_credentials_entry(soap, nullptr, nullptr, nullptr);
    }
    if (!soap_match_tag(soap, t, "ns1:login-credentials")) {
      *type = SOAP_TYPE_ICat4__ns1__login_credentials;
      return soap_in__ns1__login_credentials(soap, nullptr, nullptr, nullptr);
    }
#ifndef WITH_NOIDREF
  }
#endif
  }
  soap->error = SOAP_TAG_MISMATCH;
  return nullptr;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap) {
  if (!soap_peek_element(soap)) {
    int t;
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level,
                              soap->body));
    if (soap->mustUnderstand && !soap->other)
      return soap->error = SOAP_MUSTUNDERSTAND;
    if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) ||
        !soap_match_tag(soap, soap->tag, "SOAP-ENV:")) {
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
      return soap->error = SOAP_TAG_MISMATCH;
    }
    if (!*soap->id || !soap_getelement(soap, &t)) {
      soap->peeked = 0;
      if (soap->fignore)
        soap->error = soap->fignore(soap, soap->tag);
      else
        soap->error = SOAP_OK;
      DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
      if (!soap->error && soap->body) {
        soap->level++;
        while (!soap_ignore_element(soap))
          ;
        if (soap->error == SOAP_NO_TAG)
          soap->error = soap_element_end_in(soap, nullptr);
      }
    }
  }
  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap) {
  int i;
  struct soap_plist *pp;
  if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;
  return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type) {
  (void)tag;
  switch (type) {
  case SOAP_TYPE_ICat4_byte:
    return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
  case SOAP_TYPE_ICat4_int:
    return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
  case SOAP_TYPE_ICat4_LONG64:
    return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
  case SOAP_TYPE_ICat4_double:
    return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
  case SOAP_TYPE_ICat4_time:
    return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
  case SOAP_TYPE_ICat4_ns1__accessType:
    return soap_out_ns1__accessType(soap, tag, id, (const enum ns1__accessType *)ptr, "ns1:accessType");
  case SOAP_TYPE_ICat4_ns1__relType:
    return soap_out_ns1__relType(soap, tag, id, (const enum ns1__relType *)ptr, "ns1:relType");
  case SOAP_TYPE_ICat4_ns1__parameterValueType:
    return soap_out_ns1__parameterValueType(soap, tag, id, (const enum ns1__parameterValueType *)ptr,
                                            "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_ns1__studyStatus:
    return soap_out_ns1__studyStatus(soap, tag, id, (const enum ns1__studyStatus *)ptr, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_ns1__icatExceptionType:
    return soap_out_ns1__icatExceptionType(soap, tag, id, (const enum ns1__icatExceptionType *)ptr,
                                           "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_bool:
    return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
  case SOAP_TYPE_ICat4__ns1__login_credentials_entry:
    return ((_ns1__login_credentials_entry *)ptr)->soap_out(soap, "ns1:login-credentials-entry", id, nullptr);
  case SOAP_TYPE_ICat4__ns1__login_credentials:
    return ((_ns1__login_credentials *)ptr)->soap_out(soap, "ns1:login-credentials", id, nullptr);
  case SOAP_TYPE_ICat4_ns1__accessType_:
    return ((ns1__accessType_ *)ptr)->soap_out(soap, tag, id, "ns1:accessType");
  case SOAP_TYPE_ICat4_ns1__relType_:
    return ((ns1__relType_ *)ptr)->soap_out(soap, tag, id, "ns1:relType");
  case SOAP_TYPE_ICat4_ns1__parameterValueType_:
    return ((ns1__parameterValueType_ *)ptr)->soap_out(soap, tag, id, "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_ns1__studyStatus_:
    return ((ns1__studyStatus_ *)ptr)->soap_out(soap, tag, id, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_ns1__icatExceptionType_:
    return ((ns1__icatExceptionType_ *)ptr)->soap_out(soap, tag, id, "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse:
    return ((ns1__getRemainingMinutesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getRemainingMinutesResponse");
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutes:
    return ((ns1__getRemainingMinutes *)ptr)->soap_out(soap, tag, id, "ns1:getRemainingMinutes");
  case SOAP_TYPE_ICat4_ns1__logoutResponse:
    return ((ns1__logoutResponse *)ptr)->soap_out(soap, tag, id, "ns1:logoutResponse");
  case SOAP_TYPE_ICat4_ns1__logout:
    return ((ns1__logout *)ptr)->soap_out(soap, tag, id, "ns1:logout");
  case SOAP_TYPE_ICat4_ns1__searchResponse:
    return ((ns1__searchResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchResponse");
  case SOAP_TYPE_ICat4_ns1__search:
    return ((ns1__search *)ptr)->soap_out(soap, tag, id, "ns1:search");
  case SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse:
    return ((ns1__isAccessAllowedResponse *)ptr)->soap_out(soap, tag, id, "ns1:isAccessAllowedResponse");
  case SOAP_TYPE_ICat4_ns1__isAccessAllowed:
    return ((ns1__isAccessAllowed *)ptr)->soap_out(soap, tag, id, "ns1:isAccessAllowed");
  case SOAP_TYPE_ICat4_ns1__deleteResponse:
    return ((ns1__deleteResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteResponse");
  case SOAP_TYPE_ICat4_ns1__delete:
    return ((ns1__delete *)ptr)->soap_out(soap, tag, id, "ns1:delete");
  case SOAP_TYPE_ICat4_ns1__searchTextResponse:
    return ((ns1__searchTextResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchTextResponse");
  case SOAP_TYPE_ICat4_ns1__searchText:
    return ((ns1__searchText *)ptr)->soap_out(soap, tag, id, "ns1:searchText");
  case SOAP_TYPE_ICat4_ns1__luceneCommitResponse:
    return ((ns1__luceneCommitResponse *)ptr)->soap_out(soap, tag, id, "ns1:luceneCommitResponse");
  case SOAP_TYPE_ICat4_ns1__luceneCommit:
    return ((ns1__luceneCommit *)ptr)->soap_out(soap, tag, id, "ns1:luceneCommit");
  case SOAP_TYPE_ICat4_ns1__entityField:
    return ((ns1__entityField *)ptr)->soap_out(soap, tag, id, "ns1:entityField");
  case SOAP_TYPE_ICat4_ns1__constraint:
    return ((ns1__constraint *)ptr)->soap_out(soap, tag, id, "ns1:constraint");
  case SOAP_TYPE_ICat4_ns1__entityInfo:
    return ((ns1__entityInfo *)ptr)->soap_out(soap, tag, id, "ns1:entityInfo");
  case SOAP_TYPE_ICat4_ns1__getEntityInfoResponse:
    return ((ns1__getEntityInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:getEntityInfoResponse");
  case SOAP_TYPE_ICat4_ns1__getEntityInfo:
    return ((ns1__getEntityInfo *)ptr)->soap_out(soap, tag, id, "ns1:getEntityInfo");
  case SOAP_TYPE_ICat4_ns1__dummyResponse:
    return ((ns1__dummyResponse *)ptr)->soap_out(soap, tag, id, "ns1:dummyResponse");
  case SOAP_TYPE_ICat4_ns1__publicStep:
    return ((ns1__publicStep *)ptr)->soap_out(soap, tag, id, "ns1:publicStep");
  case SOAP_TYPE_ICat4_ns1__log:
    return ((ns1__log *)ptr)->soap_out(soap, tag, id, "ns1:log");
  case SOAP_TYPE_ICat4_ns1__relatedDatafile:
    return ((ns1__relatedDatafile *)ptr)->soap_out(soap, tag, id, "ns1:relatedDatafile");
  case SOAP_TYPE_ICat4_ns1__shift:
    return ((ns1__shift *)ptr)->soap_out(soap, tag, id, "ns1:shift");
  case SOAP_TYPE_ICat4_ns1__publication:
    return ((ns1__publication *)ptr)->soap_out(soap, tag, id, "ns1:publication");
  case SOAP_TYPE_ICat4_ns1__keyword:
    return ((ns1__keyword *)ptr)->soap_out(soap, tag, id, "ns1:keyword");
  case SOAP_TYPE_ICat4_ns1__sampleType:
    return ((ns1__sampleType *)ptr)->soap_out(soap, tag, id, "ns1:sampleType");
  case SOAP_TYPE_ICat4_ns1__sample:
    return ((ns1__sample *)ptr)->soap_out(soap, tag, id, "ns1:sample");
  case SOAP_TYPE_ICat4_ns1__sampleParameter:
    return ((ns1__sampleParameter *)ptr)->soap_out(soap, tag, id, "ns1:sampleParameter");
  case SOAP_TYPE_ICat4_ns1__permissibleStringValue:
    return ((ns1__permissibleStringValue *)ptr)->soap_out(soap, tag, id, "ns1:permissibleStringValue");
  case SOAP_TYPE_ICat4_ns1__investigationParameter:
    return ((ns1__investigationParameter *)ptr)->soap_out(soap, tag, id, "ns1:investigationParameter");
  case SOAP_TYPE_ICat4_ns1__datasetParameter:
    return ((ns1__datasetParameter *)ptr)->soap_out(soap, tag, id, "ns1:datasetParameter");
  case SOAP_TYPE_ICat4_ns1__datafileParameter:
    return ((ns1__datafileParameter *)ptr)->soap_out(soap, tag, id, "ns1:datafileParameter");
  case SOAP_TYPE_ICat4_ns1__parameter:
    return ((ns1__parameter *)ptr)->soap_out(soap, tag, id, "ns1:parameter");
  case SOAP_TYPE_ICat4_ns1__dataCollectionParameter:
    return ((ns1__dataCollectionParameter *)ptr)->soap_out(soap, tag, id, "ns1:dataCollectionParameter");
  case SOAP_TYPE_ICat4_ns1__parameterType:
    return ((ns1__parameterType *)ptr)->soap_out(soap, tag, id, "ns1:parameterType");
  case SOAP_TYPE_ICat4_ns1__investigationType:
    return ((ns1__investigationType *)ptr)->soap_out(soap, tag, id, "ns1:investigationType");
  case SOAP_TYPE_ICat4_ns1__investigationInstrument:
    return ((ns1__investigationInstrument *)ptr)->soap_out(soap, tag, id, "ns1:investigationInstrument");
  case SOAP_TYPE_ICat4_ns1__rule:
    return ((ns1__rule *)ptr)->soap_out(soap, tag, id, "ns1:rule");
  case SOAP_TYPE_ICat4_ns1__grouping:
    return ((ns1__grouping *)ptr)->soap_out(soap, tag, id, "ns1:grouping");
  case SOAP_TYPE_ICat4_ns1__userGroup:
    return ((ns1__userGroup *)ptr)->soap_out(soap, tag, id, "ns1:userGroup");
  case SOAP_TYPE_ICat4_ns1__studyInvestigation:
    return ((ns1__studyInvestigation *)ptr)->soap_out(soap, tag, id, "ns1:studyInvestigation");
  case SOAP_TYPE_ICat4_ns1__study:
    return ((ns1__study *)ptr)->soap_out(soap, tag, id, "ns1:study");
  case SOAP_TYPE_ICat4_ns1__investigationUser:
    return ((ns1__investigationUser *)ptr)->soap_out(soap, tag, id, "ns1:investigationUser");
  case SOAP_TYPE_ICat4_ns1__user:
    return ((ns1__user *)ptr)->soap_out(soap, tag, id, "ns1:user");
  case SOAP_TYPE_ICat4_ns1__instrumentScientist:
    return ((ns1__instrumentScientist *)ptr)->soap_out(soap, tag, id, "ns1:instrumentScientist");
  case SOAP_TYPE_ICat4_ns1__instrument:
    return ((ns1__instrument *)ptr)->soap_out(soap, tag, id, "ns1:instrument");
  case SOAP_TYPE_ICat4_ns1__facilityCycle:
    return ((ns1__facilityCycle *)ptr)->soap_out(soap, tag, id, "ns1:facilityCycle");
  case SOAP_TYPE_ICat4_ns1__datasetType:
    return ((ns1__datasetType *)ptr)->soap_out(soap, tag, id, "ns1:datasetType");
  case SOAP_TYPE_ICat4_ns1__datafileFormat:
    return ((ns1__datafileFormat *)ptr)->soap_out(soap, tag, id, "ns1:datafileFormat");
  case SOAP_TYPE_ICat4_ns1__job:
    return ((ns1__job *)ptr)->soap_out(soap, tag, id, "ns1:job");
  case SOAP_TYPE_ICat4_ns1__application:
    return ((ns1__application *)ptr)->soap_out(soap, tag, id, "ns1:application");
  case SOAP_TYPE_ICat4_ns1__facility:
    return ((ns1__facility *)ptr)->soap_out(soap, tag, id, "ns1:facility");
  case SOAP_TYPE_ICat4_ns1__investigation:
    return ((ns1__investigation *)ptr)->soap_out(soap, tag, id, "ns1:investigation");
  case SOAP_TYPE_ICat4_ns1__dataset:
    return ((ns1__dataset *)ptr)->soap_out(soap, tag, id, "ns1:dataset");
  case SOAP_TYPE_ICat4_ns1__dataCollectionDataset:
    return ((ns1__dataCollectionDataset *)ptr)->soap_out(soap, tag, id, "ns1:dataCollectionDataset");
  case SOAP_TYPE_ICat4_ns1__dataCollection:
    return ((ns1__dataCollection *)ptr)->soap_out(soap, tag, id, "ns1:dataCollection");
  case SOAP_TYPE_ICat4_ns1__dataCollectionDatafile:
    return ((ns1__dataCollectionDatafile *)ptr)->soap_out(soap, tag, id, "ns1:dataCollectionDatafile");
  case SOAP_TYPE_ICat4_ns1__datafile:
    return ((ns1__datafile *)ptr)->soap_out(soap, tag, id, "ns1:datafile");
  case SOAP_TYPE_ICat4_ns1__dummy:
    return ((ns1__dummy *)ptr)->soap_out(soap, tag, id, "ns1:dummy");
  case SOAP_TYPE_ICat4_ns1__loginResponse:
    return ((ns1__loginResponse *)ptr)->soap_out(soap, tag, id, "ns1:loginResponse");
  case SOAP_TYPE_ICat4_ns1__login:
    return ((ns1__login *)ptr)->soap_out(soap, tag, id, "ns1:login");
  case SOAP_TYPE_ICat4_ns1__refreshResponse:
    return ((ns1__refreshResponse *)ptr)->soap_out(soap, tag, id, "ns1:refreshResponse");
  case SOAP_TYPE_ICat4_ns1__refresh:
    return ((ns1__refresh *)ptr)->soap_out(soap, tag, id, "ns1:refresh");
  case SOAP_TYPE_ICat4_ns1__getUserNameResponse:
    return ((ns1__getUserNameResponse *)ptr)->soap_out(soap, tag, id, "ns1:getUserNameResponse");
  case SOAP_TYPE_ICat4_ns1__getUserName:
    return ((ns1__getUserName *)ptr)->soap_out(soap, tag, id, "ns1:getUserName");
  case SOAP_TYPE_ICat4_ns1__deleteManyResponse:
    return ((ns1__deleteManyResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteManyResponse");
  case SOAP_TYPE_ICat4_ns1__deleteMany:
    return ((ns1__deleteMany *)ptr)->soap_out(soap, tag, id, "ns1:deleteMany");
  case SOAP_TYPE_ICat4_ns1__updateResponse:
    return ((ns1__updateResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateResponse");
  case SOAP_TYPE_ICat4_ns1__update:
    return ((ns1__update *)ptr)->soap_out(soap, tag, id, "ns1:update");
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse:
    return ((ns1__luceneGetPopulatingResponse *)ptr)->soap_out(soap, tag, id, "ns1:luceneGetPopulatingResponse");
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulating:
    return ((ns1__luceneGetPopulating *)ptr)->soap_out(soap, tag, id, "ns1:luceneGetPopulating");
  case SOAP_TYPE_ICat4_ns1__getApiVersionResponse:
    return ((ns1__getApiVersionResponse *)ptr)->soap_out(soap, tag, id, "ns1:getApiVersionResponse");
  case SOAP_TYPE_ICat4_ns1__getApiVersion:
    return ((ns1__getApiVersion *)ptr)->soap_out(soap, tag, id, "ns1:getApiVersion");
  case SOAP_TYPE_ICat4_ns1__getEntityNamesResponse:
    return ((ns1__getEntityNamesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getEntityNamesResponse");
  case SOAP_TYPE_ICat4_ns1__getEntityNames:
    return ((ns1__getEntityNames *)ptr)->soap_out(soap, tag, id, "ns1:getEntityNames");
  case SOAP_TYPE_ICat4_ns1__getResponse:
    return ((ns1__getResponse *)ptr)->soap_out(soap, tag, id, "ns1:getResponse");
  case SOAP_TYPE_ICat4_ns1__get:
    return ((ns1__get *)ptr)->soap_out(soap, tag, id, "ns1:get");
  case SOAP_TYPE_ICat4_ns1__lucenePopulateResponse:
    return ((ns1__lucenePopulateResponse *)ptr)->soap_out(soap, tag, id, "ns1:lucenePopulateResponse");
  case SOAP_TYPE_ICat4_ns1__lucenePopulate:
    return ((ns1__lucenePopulate *)ptr)->soap_out(soap, tag, id, "ns1:lucenePopulate");
  case SOAP_TYPE_ICat4_ns1__luceneSearchResponse:
    return ((ns1__luceneSearchResponse *)ptr)->soap_out(soap, tag, id, "ns1:luceneSearchResponse");
  case SOAP_TYPE_ICat4_ns1__luceneSearch:
    return ((ns1__luceneSearch *)ptr)->soap_out(soap, tag, id, "ns1:luceneSearch");
  case SOAP_TYPE_ICat4_ns1__getPropertiesResponse:
    return ((ns1__getPropertiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPropertiesResponse");
  case SOAP_TYPE_ICat4_ns1__getProperties:
    return ((ns1__getProperties *)ptr)->soap_out(soap, tag, id, "ns1:getProperties");
  case SOAP_TYPE_ICat4_ns1__createResponse:
    return ((ns1__createResponse *)ptr)->soap_out(soap, tag, id, "ns1:createResponse");
  case SOAP_TYPE_ICat4_ns1__create:
    return ((ns1__create *)ptr)->soap_out(soap, tag, id, "ns1:create");
  case SOAP_TYPE_ICat4_ns1__createManyResponse:
    return ((ns1__createManyResponse *)ptr)->soap_out(soap, tag, id, "ns1:createManyResponse");
  case SOAP_TYPE_ICat4_ns1__entityBaseBean:
    return ((ns1__entityBaseBean *)ptr)->soap_out(soap, tag, id, "ns1:entityBaseBean");
  case SOAP_TYPE_ICat4_ns1__createMany:
    return ((ns1__createMany *)ptr)->soap_out(soap, tag, id, "ns1:createMany");
  case SOAP_TYPE_ICat4_ns1__IcatException:
    return ((ns1__IcatException *)ptr)->soap_out(soap, tag, id, "ns1:IcatException");
  case SOAP_TYPE_ICat4_ns1__luceneClearResponse:
    return ((ns1__luceneClearResponse *)ptr)->soap_out(soap, tag, id, "ns1:luceneClearResponse");
  case SOAP_TYPE_ICat4_ns1__luceneClear:
    return ((ns1__luceneClear *)ptr)->soap_out(soap, tag, id, "ns1:luceneClear");
  case SOAP_TYPE_ICat4_std__string:
    return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
  case SOAP_TYPE_ICat4_xsd__string:
    return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
  case SOAP_TYPE_ICat4_xsd__long:
    return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
  case SOAP_TYPE_ICat4_xsd__int:
    return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
  case SOAP_TYPE_ICat4_xsd__double:
    return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
  case SOAP_TYPE_ICat4_xsd__dateTime:
    return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
  case SOAP_TYPE_ICat4_xsd__boolean:
    return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
  case SOAP_TYPE_ICat4_xsd__anyType:
    return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfoResponse:
    return soap_out_PointerTons1__getEntityInfoResponse(soap, tag, id, (ns1__getEntityInfoResponse *const *)ptr,
                                                        "ns1:getEntityInfoResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfo:
    return soap_out_PointerTons1__getEntityInfo(soap, tag, id, (ns1__getEntityInfo *const *)ptr, "ns1:getEntityInfo");
  case SOAP_TYPE_ICat4_PointerTons1__deleteManyResponse:
    return soap_out_PointerTons1__deleteManyResponse(soap, tag, id, (ns1__deleteManyResponse *const *)ptr,
                                                     "ns1:deleteManyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__deleteMany:
    return soap_out_PointerTons1__deleteMany(soap, tag, id, (ns1__deleteMany *const *)ptr, "ns1:deleteMany");
  case SOAP_TYPE_ICat4_PointerTons1__createManyResponse:
    return soap_out_PointerTons1__createManyResponse(soap, tag, id, (ns1__createManyResponse *const *)ptr,
                                                     "ns1:createManyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__createMany:
    return soap_out_PointerTons1__createMany(soap, tag, id, (ns1__createMany *const *)ptr, "ns1:createMany");
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulatingResponse:
    return soap_out_PointerTons1__luceneGetPopulatingResponse(
        soap, tag, id, (ns1__luceneGetPopulatingResponse *const *)ptr, "ns1:luceneGetPopulatingResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulating:
    return soap_out_PointerTons1__luceneGetPopulating(soap, tag, id, (ns1__luceneGetPopulating *const *)ptr,
                                                      "ns1:luceneGetPopulating");
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearchResponse:
    return soap_out_PointerTons1__luceneSearchResponse(soap, tag, id, (ns1__luceneSearchResponse *const *)ptr,
                                                       "ns1:luceneSearchResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearch:
    return soap_out_PointerTons1__luceneSearch(soap, tag, id, (ns1__luceneSearch *const *)ptr, "ns1:luceneSearch");
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommitResponse:
    return soap_out_PointerTons1__luceneCommitResponse(soap, tag, id, (ns1__luceneCommitResponse *const *)ptr,
                                                       "ns1:luceneCommitResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommit:
    return soap_out_PointerTons1__luceneCommit(soap, tag, id, (ns1__luceneCommit *const *)ptr, "ns1:luceneCommit");
  case SOAP_TYPE_ICat4_PointerTons1__luceneClearResponse:
    return soap_out_PointerTons1__luceneClearResponse(soap, tag, id, (ns1__luceneClearResponse *const *)ptr,
                                                      "ns1:luceneClearResponse");
  case SOAP_TYPE_ICat4_PointerTons1__luceneClear:
    return soap_out_PointerTons1__luceneClear(soap, tag, id, (ns1__luceneClear *const *)ptr, "ns1:luceneClear");
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulateResponse:
    return soap_out_PointerTons1__lucenePopulateResponse(soap, tag, id, (ns1__lucenePopulateResponse *const *)ptr,
                                                         "ns1:lucenePopulateResponse");
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulate:
    return soap_out_PointerTons1__lucenePopulate(soap, tag, id, (ns1__lucenePopulate *const *)ptr,
                                                 "ns1:lucenePopulate");
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowedResponse:
    return soap_out_PointerTons1__isAccessAllowedResponse(soap, tag, id, (ns1__isAccessAllowedResponse *const *)ptr,
                                                          "ns1:isAccessAllowedResponse");
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowed:
    return soap_out_PointerTons1__isAccessAllowed(soap, tag, id, (ns1__isAccessAllowed *const *)ptr,
                                                  "ns1:isAccessAllowed");
  case SOAP_TYPE_ICat4_PointerTons1__searchTextResponse:
    return soap_out_PointerTons1__searchTextResponse(soap, tag, id, (ns1__searchTextResponse *const *)ptr,
                                                     "ns1:searchTextResponse");
  case SOAP_TYPE_ICat4_PointerTons1__searchText:
    return soap_out_PointerTons1__searchText(soap, tag, id, (ns1__searchText *const *)ptr, "ns1:searchText");
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutesResponse:
    return soap_out_PointerTons1__getRemainingMinutesResponse(
        soap, tag, id, (ns1__getRemainingMinutesResponse *const *)ptr, "ns1:getRemainingMinutesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutes:
    return soap_out_PointerTons1__getRemainingMinutes(soap, tag, id, (ns1__getRemainingMinutes *const *)ptr,
                                                      "ns1:getRemainingMinutes");
  case SOAP_TYPE_ICat4_PointerTons1__logoutResponse:
    return soap_out_PointerTons1__logoutResponse(soap, tag, id, (ns1__logoutResponse *const *)ptr,
                                                 "ns1:logoutResponse");
  case SOAP_TYPE_ICat4_PointerTons1__logout:
    return soap_out_PointerTons1__logout(soap, tag, id, (ns1__logout *const *)ptr, "ns1:logout");
  case SOAP_TYPE_ICat4_PointerTons1__dummyResponse:
    return soap_out_PointerTons1__dummyResponse(soap, tag, id, (ns1__dummyResponse *const *)ptr, "ns1:dummyResponse");
  case SOAP_TYPE_ICat4_PointerTons1__dummy:
    return soap_out_PointerTons1__dummy(soap, tag, id, (ns1__dummy *const *)ptr, "ns1:dummy");
  case SOAP_TYPE_ICat4_PointerTons1__refreshResponse:
    return soap_out_PointerTons1__refreshResponse(soap, tag, id, (ns1__refreshResponse *const *)ptr,
                                                  "ns1:refreshResponse");
  case SOAP_TYPE_ICat4_PointerTons1__refresh:
    return soap_out_PointerTons1__refresh(soap, tag, id, (ns1__refresh *const *)ptr, "ns1:refresh");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNamesResponse:
    return soap_out_PointerTons1__getEntityNamesResponse(soap, tag, id, (ns1__getEntityNamesResponse *const *)ptr,
                                                         "ns1:getEntityNamesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNames:
    return soap_out_PointerTons1__getEntityNames(soap, tag, id, (ns1__getEntityNames *const *)ptr,
                                                 "ns1:getEntityNames");
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersionResponse:
    return soap_out_PointerTons1__getApiVersionResponse(soap, tag, id, (ns1__getApiVersionResponse *const *)ptr,
                                                        "ns1:getApiVersionResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersion:
    return soap_out_PointerTons1__getApiVersion(soap, tag, id, (ns1__getApiVersion *const *)ptr, "ns1:getApiVersion");
  case SOAP_TYPE_ICat4_PointerTons1__updateResponse:
    return soap_out_PointerTons1__updateResponse(soap, tag, id, (ns1__updateResponse *const *)ptr,
                                                 "ns1:updateResponse");
  case SOAP_TYPE_ICat4_PointerTons1__update:
    return soap_out_PointerTons1__update(soap, tag, id, (ns1__update *const *)ptr, "ns1:update");
  case SOAP_TYPE_ICat4_PointerTons1__createResponse:
    return soap_out_PointerTons1__createResponse(soap, tag, id, (ns1__createResponse *const *)ptr,
                                                 "ns1:createResponse");
  case SOAP_TYPE_ICat4_PointerTons1__create:
    return soap_out_PointerTons1__create(soap, tag, id, (ns1__create *const *)ptr, "ns1:create");
  case SOAP_TYPE_ICat4_PointerTons1__searchResponse:
    return soap_out_PointerTons1__searchResponse(soap, tag, id, (ns1__searchResponse *const *)ptr,
                                                 "ns1:searchResponse");
  case SOAP_TYPE_ICat4_PointerTons1__search:
    return soap_out_PointerTons1__search(soap, tag, id, (ns1__search *const *)ptr, "ns1:search");
  case SOAP_TYPE_ICat4_PointerTons1__deleteResponse:
    return soap_out_PointerTons1__deleteResponse(soap, tag, id, (ns1__deleteResponse *const *)ptr,
                                                 "ns1:deleteResponse");
  case SOAP_TYPE_ICat4_PointerTons1__delete:
    return soap_out_PointerTons1__delete(soap, tag, id, (ns1__delete *const *)ptr, "ns1:delete");
  case SOAP_TYPE_ICat4_PointerTons1__getPropertiesResponse:
    return soap_out_PointerTons1__getPropertiesResponse(soap, tag, id, (ns1__getPropertiesResponse *const *)ptr,
                                                        "ns1:getPropertiesResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getProperties:
    return soap_out_PointerTons1__getProperties(soap, tag, id, (ns1__getProperties *const *)ptr, "ns1:getProperties");
  case SOAP_TYPE_ICat4_PointerTons1__getResponse:
    return soap_out_PointerTons1__getResponse(soap, tag, id, (ns1__getResponse *const *)ptr, "ns1:getResponse");
  case SOAP_TYPE_ICat4_PointerTons1__get:
    return soap_out_PointerTons1__get(soap, tag, id, (ns1__get *const *)ptr, "ns1:get");
  case SOAP_TYPE_ICat4_PointerTons1__getUserNameResponse:
    return soap_out_PointerTons1__getUserNameResponse(soap, tag, id, (ns1__getUserNameResponse *const *)ptr,
                                                      "ns1:getUserNameResponse");
  case SOAP_TYPE_ICat4_PointerTons1__getUserName:
    return soap_out_PointerTons1__getUserName(soap, tag, id, (ns1__getUserName *const *)ptr, "ns1:getUserName");
  case SOAP_TYPE_ICat4_PointerTons1__loginResponse:
    return soap_out_PointerTons1__loginResponse(soap, tag, id, (ns1__loginResponse *const *)ptr, "ns1:loginResponse");
  case SOAP_TYPE_ICat4_PointerTons1__login:
    return soap_out_PointerTons1__login(soap, tag, id, (ns1__login *const *)ptr, "ns1:login");
  case SOAP_TYPE_ICat4_PointerTons1__IcatException:
    return soap_out_PointerTons1__IcatException(soap, tag, id, (ns1__IcatException *const *)ptr, "ns1:IcatException");
  case SOAP_TYPE_ICat4_PointerTons1__parameterValueType:
    return soap_out_PointerTons1__parameterValueType(soap, tag, id, (enum ns1__parameterValueType *const *)ptr,
                                                     "ns1:parameterValueType");
  case SOAP_TYPE_ICat4_PointerTons1__permissibleStringValue:
    return soap_out_PointerTons1__permissibleStringValue(soap, tag, id, (ns1__permissibleStringValue *const *)ptr,
                                                         "ns1:permissibleStringValue");
  case SOAP_TYPE_ICat4_PointerTodouble:
    return soap_out_PointerTodouble(soap, tag, id, (double *const *)ptr, "xsd:double");
  case SOAP_TYPE_ICat4_PointerTons1__rule:
    return soap_out_PointerTons1__rule(soap, tag, id, (ns1__rule *const *)ptr, "ns1:rule");
  case SOAP_TYPE_ICat4_PointerTons1__sampleType:
    return soap_out_PointerTons1__sampleType(soap, tag, id, (ns1__sampleType *const *)ptr, "ns1:sampleType");
  case SOAP_TYPE_ICat4_PointerTons1__investigationParameter:
    return soap_out_PointerTons1__investigationParameter(soap, tag, id, (ns1__investigationParameter *const *)ptr,
                                                         "ns1:investigationParameter");
  case SOAP_TYPE_ICat4_PointerTons1__investigationInstrument:
    return soap_out_PointerTons1__investigationInstrument(soap, tag, id, (ns1__investigationInstrument *const *)ptr,
                                                          "ns1:investigationInstrument");
  case SOAP_TYPE_ICat4_PointerTons1__accessType:
    return soap_out_PointerTons1__accessType(soap, tag, id, (enum ns1__accessType *const *)ptr, "ns1:accessType");
  case SOAP_TYPE_ICat4_PointerToxsd__anyType:
    return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const *)ptr, "xsd:anyType");
  case SOAP_TYPE_ICat4_PointerToint:
    return soap_out_PointerToint(soap, tag, id, (int *const *)ptr, "xsd:int");
  case SOAP_TYPE_ICat4_PointerTons1__relType:
    return soap_out_PointerTons1__relType(soap, tag, id, (enum ns1__relType *const *)ptr, "ns1:relType");
  case SOAP_TYPE_ICat4_PointerTons1__entityField:
    return soap_out_PointerTons1__entityField(soap, tag, id, (ns1__entityField *const *)ptr, "ns1:entityField");
  case SOAP_TYPE_ICat4_PointerTons1__constraint:
    return soap_out_PointerTons1__constraint(soap, tag, id, (ns1__constraint *const *)ptr, "ns1:constraint");
  case SOAP_TYPE_ICat4_PointerTons1__entityInfo:
    return soap_out_PointerTons1__entityInfo(soap, tag, id, (ns1__entityInfo *const *)ptr, "ns1:entityInfo");
  case SOAP_TYPE_ICat4_PointerTons1__publicStep:
    return soap_out_PointerTons1__publicStep(soap, tag, id, (ns1__publicStep *const *)ptr, "ns1:publicStep");
  case SOAP_TYPE_ICat4_PointerTons1__log:
    return soap_out_PointerTons1__log(soap, tag, id, (ns1__log *const *)ptr, "ns1:log");
  case SOAP_TYPE_ICat4_PointerTons1__userGroup:
    return soap_out_PointerTons1__userGroup(soap, tag, id, (ns1__userGroup *const *)ptr, "ns1:userGroup");
  case SOAP_TYPE_ICat4_PointerTons1__grouping:
    return soap_out_PointerTons1__grouping(soap, tag, id, (ns1__grouping *const *)ptr, "ns1:grouping");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDatafile:
    return soap_out_PointerTons1__dataCollectionDatafile(soap, tag, id, (ns1__dataCollectionDatafile *const *)ptr,
                                                         "ns1:dataCollectionDatafile");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDataset:
    return soap_out_PointerTons1__dataCollectionDataset(soap, tag, id, (ns1__dataCollectionDataset *const *)ptr,
                                                        "ns1:dataCollectionDataset");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionParameter:
    return soap_out_PointerTons1__dataCollectionParameter(soap, tag, id, (ns1__dataCollectionParameter *const *)ptr,
                                                          "ns1:dataCollectionParameter");
  case SOAP_TYPE_ICat4_PointerTons1__dataCollection:
    return soap_out_PointerTons1__dataCollection(soap, tag, id, (ns1__dataCollection *const *)ptr,
                                                 "ns1:dataCollection");
  case SOAP_TYPE_ICat4_PointerTons1__job:
    return soap_out_PointerTons1__job(soap, tag, id, (ns1__job *const *)ptr, "ns1:job");
  case SOAP_TYPE_ICat4_PointerTons1__application:
    return soap_out_PointerTons1__application(soap, tag, id, (ns1__application *const *)ptr, "ns1:application");
  case SOAP_TYPE_ICat4_PointerTons1__studyStatus:
    return soap_out_PointerTons1__studyStatus(soap, tag, id, (enum ns1__studyStatus *const *)ptr, "ns1:studyStatus");
  case SOAP_TYPE_ICat4_PointerTons1__studyInvestigation:
    return soap_out_PointerTons1__studyInvestigation(soap, tag, id, (ns1__studyInvestigation *const *)ptr,
                                                     "ns1:studyInvestigation");
  case SOAP_TYPE_ICat4_PointerTons1__study:
    return soap_out_PointerTons1__study(soap, tag, id, (ns1__study *const *)ptr, "ns1:study");
  case SOAP_TYPE_ICat4_PointerTons1__shift:
    return soap_out_PointerTons1__shift(soap, tag, id, (ns1__shift *const *)ptr, "ns1:shift");
  case SOAP_TYPE_ICat4_PointerTons1__sampleParameter:
    return soap_out_PointerTons1__sampleParameter(soap, tag, id, (ns1__sampleParameter *const *)ptr,
                                                  "ns1:sampleParameter");
  case SOAP_TYPE_ICat4_PointerTons1__sample:
    return soap_out_PointerTons1__sample(soap, tag, id, (ns1__sample *const *)ptr, "ns1:sample");
  case SOAP_TYPE_ICat4_PointerTons1__relatedDatafile:
    return soap_out_PointerTons1__relatedDatafile(soap, tag, id, (ns1__relatedDatafile *const *)ptr,
                                                  "ns1:relatedDatafile");
  case SOAP_TYPE_ICat4_PointerTons1__publication:
    return soap_out_PointerTons1__publication(soap, tag, id, (ns1__publication *const *)ptr, "ns1:publication");
  case SOAP_TYPE_ICat4_PointerTons1__parameterType:
    return soap_out_PointerTons1__parameterType(soap, tag, id, (ns1__parameterType *const *)ptr, "ns1:parameterType");
  case SOAP_TYPE_ICat4_PointerTons1__keyword:
    return soap_out_PointerTons1__keyword(soap, tag, id, (ns1__keyword *const *)ptr, "ns1:keyword");
  case SOAP_TYPE_ICat4_PointerTons1__investigationUser:
    return soap_out_PointerTons1__investigationUser(soap, tag, id, (ns1__investigationUser *const *)ptr,
                                                    "ns1:investigationUser");
  case SOAP_TYPE_ICat4_PointerTons1__investigationType:
    return soap_out_PointerTons1__investigationType(soap, tag, id, (ns1__investigationType *const *)ptr,
                                                    "ns1:investigationType");
  case SOAP_TYPE_ICat4_PointerTons1__investigation:
    return soap_out_PointerTons1__investigation(soap, tag, id, (ns1__investigation *const *)ptr, "ns1:investigation");
  case SOAP_TYPE_ICat4_PointerTons1__instrument:
    return soap_out_PointerTons1__instrument(soap, tag, id, (ns1__instrument *const *)ptr, "ns1:instrument");
  case SOAP_TYPE_ICat4_PointerTons1__user:
    return soap_out_PointerTons1__user(soap, tag, id, (ns1__user *const *)ptr, "ns1:user");
  case SOAP_TYPE_ICat4_PointerTons1__instrumentScientist:
    return soap_out_PointerTons1__instrumentScientist(soap, tag, id, (ns1__instrumentScientist *const *)ptr,
                                                      "ns1:instrumentScientist");
  case SOAP_TYPE_ICat4_PointerTons1__facilityCycle:
    return soap_out_PointerTons1__facilityCycle(soap, tag, id, (ns1__facilityCycle *const *)ptr, "ns1:facilityCycle");
  case SOAP_TYPE_ICat4_PointerTons1__facility:
    return soap_out_PointerTons1__facility(soap, tag, id, (ns1__facility *const *)ptr, "ns1:facility");
  case SOAP_TYPE_ICat4_PointerTons1__datasetType:
    return soap_out_PointerTons1__datasetType(soap, tag, id, (ns1__datasetType *const *)ptr, "ns1:datasetType");
  case SOAP_TYPE_ICat4_PointerTons1__datasetParameter:
    return soap_out_PointerTons1__datasetParameter(soap, tag, id, (ns1__datasetParameter *const *)ptr,
                                                   "ns1:datasetParameter");
  case SOAP_TYPE_ICat4_PointerTons1__dataset:
    return soap_out_PointerTons1__dataset(soap, tag, id, (ns1__dataset *const *)ptr, "ns1:dataset");
  case SOAP_TYPE_ICat4_PointerTons1__datafileParameter:
    return soap_out_PointerTons1__datafileParameter(soap, tag, id, (ns1__datafileParameter *const *)ptr,
                                                    "ns1:datafileParameter");
  case SOAP_TYPE_ICat4_PointerTons1__datafileFormat:
    return soap_out_PointerTons1__datafileFormat(soap, tag, id, (ns1__datafileFormat *const *)ptr,
                                                 "ns1:datafileFormat");
  case SOAP_TYPE_ICat4_PointerTons1__datafile:
    return soap_out_PointerTons1__datafile(soap, tag, id, (ns1__datafile *const *)ptr, "ns1:datafile");
  case SOAP_TYPE_ICat4_PointerToLONG64:
    return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const *)ptr, "xsd:long");
  case SOAP_TYPE_ICat4_PointerTotime:
    return soap_out_PointerTotime(soap, tag, id, (time_t *const *)ptr, "xsd:dateTime");
  case SOAP_TYPE_ICat4_PointerTons1__entityBaseBean:
    return soap_out_PointerTons1__entityBaseBean(soap, tag, id, (ns1__entityBaseBean *const *)ptr,
                                                 "ns1:entityBaseBean");
  case SOAP_TYPE_ICat4_PointerTons1__icatExceptionType:
    return soap_out_PointerTons1__icatExceptionType(soap, tag, id, (enum ns1__icatExceptionType *const *)ptr,
                                                    "ns1:icatExceptionType");
  case SOAP_TYPE_ICat4_PointerTostd__string:
    return soap_out_PointerTostd__string(soap, tag, id, (std::string *const *)ptr, "xsd:string");
  case SOAP_TYPE_ICat4__QName:
    return soap_out_string(soap, tag, id, (char *const *)&ptr, "xsd:QName");
  case SOAP_TYPE_ICat4_string:
    return soap_out_string(soap, tag, id, (char *const *)&ptr, "xsd:string");
  }
  return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type) {
  (void)soap;
  (void)ptr;
  (void)type; /* appease -Wall -Werror */
  switch (type) {
  case SOAP_TYPE_ICat4__ns1__login_credentials_entry:
    ((_ns1__login_credentials_entry *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4__ns1__login_credentials:
    ((_ns1__login_credentials *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__accessType_:
    ((ns1__accessType_ *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__relType_:
    ((ns1__relType_ *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__parameterValueType_:
    ((ns1__parameterValueType_ *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__studyStatus_:
    ((ns1__studyStatus_ *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__icatExceptionType_:
    ((ns1__icatExceptionType_ *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse:
    ((ns1__getRemainingMinutesResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutes:
    ((ns1__getRemainingMinutes *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__logoutResponse:
    ((ns1__logoutResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__logout:
    ((ns1__logout *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__searchResponse:
    ((ns1__searchResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__search:
    ((ns1__search *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse:
    ((ns1__isAccessAllowedResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__isAccessAllowed:
    ((ns1__isAccessAllowed *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteResponse:
    ((ns1__deleteResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__delete:
    ((ns1__delete *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__searchTextResponse:
    ((ns1__searchTextResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__searchText:
    ((ns1__searchText *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneCommitResponse:
    ((ns1__luceneCommitResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneCommit:
    ((ns1__luceneCommit *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__entityField:
    ((ns1__entityField *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__constraint:
    ((ns1__constraint *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__entityInfo:
    ((ns1__entityInfo *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityInfoResponse:
    ((ns1__getEntityInfoResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityInfo:
    ((ns1__getEntityInfo *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dummyResponse:
    ((ns1__dummyResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__publicStep:
    ((ns1__publicStep *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__log:
    ((ns1__log *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__relatedDatafile:
    ((ns1__relatedDatafile *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__shift:
    ((ns1__shift *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__publication:
    ((ns1__publication *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__keyword:
    ((ns1__keyword *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__sampleType:
    ((ns1__sampleType *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__sample:
    ((ns1__sample *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__sampleParameter:
    ((ns1__sampleParameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__permissibleStringValue:
    ((ns1__permissibleStringValue *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationParameter:
    ((ns1__investigationParameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__datasetParameter:
    ((ns1__datasetParameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__datafileParameter:
    ((ns1__datafileParameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__parameter:
    ((ns1__parameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionParameter:
    ((ns1__dataCollectionParameter *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__parameterType:
    ((ns1__parameterType *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationType:
    ((ns1__investigationType *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationInstrument:
    ((ns1__investigationInstrument *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__rule:
    ((ns1__rule *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__grouping:
    ((ns1__grouping *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__userGroup:
    ((ns1__userGroup *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__studyInvestigation:
    ((ns1__studyInvestigation *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__study:
    ((ns1__study *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationUser:
    ((ns1__investigationUser *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__user:
    ((ns1__user *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__instrumentScientist:
    ((ns1__instrumentScientist *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__instrument:
    ((ns1__instrument *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__facilityCycle:
    ((ns1__facilityCycle *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__datasetType:
    ((ns1__datasetType *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__datafileFormat:
    ((ns1__datafileFormat *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__job:
    ((ns1__job *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__application:
    ((ns1__application *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__facility:
    ((ns1__facility *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__investigation:
    ((ns1__investigation *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dataset:
    ((ns1__dataset *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionDataset:
    ((ns1__dataCollectionDataset *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollection:
    ((ns1__dataCollection *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionDatafile:
    ((ns1__dataCollectionDatafile *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__datafile:
    ((ns1__datafile *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__dummy:
    ((ns1__dummy *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__loginResponse:
    ((ns1__loginResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__login:
    ((ns1__login *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__refreshResponse:
    ((ns1__refreshResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__refresh:
    ((ns1__refresh *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getUserNameResponse:
    ((ns1__getUserNameResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getUserName:
    ((ns1__getUserName *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteManyResponse:
    ((ns1__deleteManyResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteMany:
    ((ns1__deleteMany *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__updateResponse:
    ((ns1__updateResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__update:
    ((ns1__update *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse:
    ((ns1__luceneGetPopulatingResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulating:
    ((ns1__luceneGetPopulating *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getApiVersionResponse:
    ((ns1__getApiVersionResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getApiVersion:
    ((ns1__getApiVersion *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityNamesResponse:
    ((ns1__getEntityNamesResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityNames:
    ((ns1__getEntityNames *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getResponse:
    ((ns1__getResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__get:
    ((ns1__get *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__lucenePopulateResponse:
    ((ns1__lucenePopulateResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__lucenePopulate:
    ((ns1__lucenePopulate *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneSearchResponse:
    ((ns1__luceneSearchResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneSearch:
    ((ns1__luceneSearch *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getPropertiesResponse:
    ((ns1__getPropertiesResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__getProperties:
    ((ns1__getProperties *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__createResponse:
    ((ns1__createResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__create:
    ((ns1__create *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__createManyResponse:
    ((ns1__createManyResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__entityBaseBean:
    ((ns1__entityBaseBean *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__createMany:
    ((ns1__createMany *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__IcatException:
    ((ns1__IcatException *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneClearResponse:
    ((ns1__luceneClearResponse *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneClear:
    ((ns1__luceneClear *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_std__string:
    soap_serialize_std__string(soap, (const std::string *)ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__string:
    ((xsd__string *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__long:
    ((xsd__long *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__int:
    ((xsd__int *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__double:
    ((xsd__double *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__dateTime:
    ((xsd__dateTime *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__boolean:
    ((xsd__boolean *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4_xsd__anyType:
    ((xsd__anyType *)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_ICat4___ns1__getEntityInfo:
    soap_serialize___ns1__getEntityInfo(soap, (const struct __ns1__getEntityInfo *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteMany:
    soap_serialize___ns1__deleteMany(soap, (const struct __ns1__deleteMany *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteManyResponse:
    soap_serialize___ns1__deleteManyResponse(soap, (const struct __ns1__deleteManyResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__createMany:
    soap_serialize___ns1__createMany(soap, (const struct __ns1__createMany *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneGetPopulating:
    soap_serialize___ns1__luceneGetPopulating(soap, (const struct __ns1__luceneGetPopulating *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneSearch:
    soap_serialize___ns1__luceneSearch(soap, (const struct __ns1__luceneSearch *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneCommit:
    soap_serialize___ns1__luceneCommit(soap, (const struct __ns1__luceneCommit *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneCommitResponse:
    soap_serialize___ns1__luceneCommitResponse(soap, (const struct __ns1__luceneCommitResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneClear:
    soap_serialize___ns1__luceneClear(soap, (const struct __ns1__luceneClear *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneClearResponse:
    soap_serialize___ns1__luceneClearResponse(soap, (const struct __ns1__luceneClearResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__lucenePopulate:
    soap_serialize___ns1__lucenePopulate(soap, (const struct __ns1__lucenePopulate *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__lucenePopulateResponse:
    soap_serialize___ns1__lucenePopulateResponse(soap, (const struct __ns1__lucenePopulateResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__isAccessAllowed:
    soap_serialize___ns1__isAccessAllowed(soap, (const struct __ns1__isAccessAllowed *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__searchText:
    soap_serialize___ns1__searchText(soap, (const struct __ns1__searchText *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getRemainingMinutes:
    soap_serialize___ns1__getRemainingMinutes(soap, (const struct __ns1__getRemainingMinutes *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__logout:
    soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__logoutResponse:
    soap_serialize___ns1__logoutResponse(soap, (const struct __ns1__logoutResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__dummy:
    soap_serialize___ns1__dummy(soap, (const struct __ns1__dummy *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__dummyResponse:
    soap_serialize___ns1__dummyResponse(soap, (const struct __ns1__dummyResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__refresh:
    soap_serialize___ns1__refresh(soap, (const struct __ns1__refresh *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__refreshResponse:
    soap_serialize___ns1__refreshResponse(soap, (const struct __ns1__refreshResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getEntityNames:
    soap_serialize___ns1__getEntityNames(soap, (const struct __ns1__getEntityNames *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getApiVersion:
    soap_serialize___ns1__getApiVersion(soap, (const struct __ns1__getApiVersion *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__update:
    soap_serialize___ns1__update(soap, (const struct __ns1__update *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__updateResponse:
    soap_serialize___ns1__updateResponse(soap, (const struct __ns1__updateResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__create:
    soap_serialize___ns1__create(soap, (const struct __ns1__create *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__search:
    soap_serialize___ns1__search(soap, (const struct __ns1__search *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__delete:
    soap_serialize___ns1__delete(soap, (const struct __ns1__delete *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteResponse:
    soap_serialize___ns1__deleteResponse(soap, (const struct __ns1__deleteResponse *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getProperties:
    soap_serialize___ns1__getProperties(soap, (const struct __ns1__getProperties *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__get:
    soap_serialize___ns1__get(soap, (const struct __ns1__get *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getUserName:
    soap_serialize___ns1__getUserName(soap, (const struct __ns1__getUserName *)ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__login:
    soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfoResponse:
    soap_serialize_PointerTons1__getEntityInfoResponse(soap, (ns1__getEntityInfoResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getEntityInfo:
    soap_serialize_PointerTons1__getEntityInfo(soap, (ns1__getEntityInfo *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__deleteManyResponse:
    soap_serialize_PointerTons1__deleteManyResponse(soap, (ns1__deleteManyResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__deleteMany:
    soap_serialize_PointerTons1__deleteMany(soap, (ns1__deleteMany *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__createManyResponse:
    soap_serialize_PointerTons1__createManyResponse(soap, (ns1__createManyResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__createMany:
    soap_serialize_PointerTons1__createMany(soap, (ns1__createMany *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulatingResponse:
    soap_serialize_PointerTons1__luceneGetPopulatingResponse(soap, (ns1__luceneGetPopulatingResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulating:
    soap_serialize_PointerTons1__luceneGetPopulating(soap, (ns1__luceneGetPopulating *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearchResponse:
    soap_serialize_PointerTons1__luceneSearchResponse(soap, (ns1__luceneSearchResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneSearch:
    soap_serialize_PointerTons1__luceneSearch(soap, (ns1__luceneSearch *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommitResponse:
    soap_serialize_PointerTons1__luceneCommitResponse(soap, (ns1__luceneCommitResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneCommit:
    soap_serialize_PointerTons1__luceneCommit(soap, (ns1__luceneCommit *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneClearResponse:
    soap_serialize_PointerTons1__luceneClearResponse(soap, (ns1__luceneClearResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__luceneClear:
    soap_serialize_PointerTons1__luceneClear(soap, (ns1__luceneClear *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulateResponse:
    soap_serialize_PointerTons1__lucenePopulateResponse(soap, (ns1__lucenePopulateResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__lucenePopulate:
    soap_serialize_PointerTons1__lucenePopulate(soap, (ns1__lucenePopulate *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowedResponse:
    soap_serialize_PointerTons1__isAccessAllowedResponse(soap, (ns1__isAccessAllowedResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__isAccessAllowed:
    soap_serialize_PointerTons1__isAccessAllowed(soap, (ns1__isAccessAllowed *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__searchTextResponse:
    soap_serialize_PointerTons1__searchTextResponse(soap, (ns1__searchTextResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__searchText:
    soap_serialize_PointerTons1__searchText(soap, (ns1__searchText *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutesResponse:
    soap_serialize_PointerTons1__getRemainingMinutesResponse(soap, (ns1__getRemainingMinutesResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutes:
    soap_serialize_PointerTons1__getRemainingMinutes(soap, (ns1__getRemainingMinutes *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__logoutResponse:
    soap_serialize_PointerTons1__logoutResponse(soap, (ns1__logoutResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__logout:
    soap_serialize_PointerTons1__logout(soap, (ns1__logout *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dummyResponse:
    soap_serialize_PointerTons1__dummyResponse(soap, (ns1__dummyResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dummy:
    soap_serialize_PointerTons1__dummy(soap, (ns1__dummy *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__refreshResponse:
    soap_serialize_PointerTons1__refreshResponse(soap, (ns1__refreshResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__refresh:
    soap_serialize_PointerTons1__refresh(soap, (ns1__refresh *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNamesResponse:
    soap_serialize_PointerTons1__getEntityNamesResponse(soap, (ns1__getEntityNamesResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getEntityNames:
    soap_serialize_PointerTons1__getEntityNames(soap, (ns1__getEntityNames *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersionResponse:
    soap_serialize_PointerTons1__getApiVersionResponse(soap, (ns1__getApiVersionResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getApiVersion:
    soap_serialize_PointerTons1__getApiVersion(soap, (ns1__getApiVersion *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__updateResponse:
    soap_serialize_PointerTons1__updateResponse(soap, (ns1__updateResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__update:
    soap_serialize_PointerTons1__update(soap, (ns1__update *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__createResponse:
    soap_serialize_PointerTons1__createResponse(soap, (ns1__createResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__create:
    soap_serialize_PointerTons1__create(soap, (ns1__create *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__searchResponse:
    soap_serialize_PointerTons1__searchResponse(soap, (ns1__searchResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__search:
    soap_serialize_PointerTons1__search(soap, (ns1__search *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__deleteResponse:
    soap_serialize_PointerTons1__deleteResponse(soap, (ns1__deleteResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__delete:
    soap_serialize_PointerTons1__delete(soap, (ns1__delete *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getPropertiesResponse:
    soap_serialize_PointerTons1__getPropertiesResponse(soap, (ns1__getPropertiesResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getProperties:
    soap_serialize_PointerTons1__getProperties(soap, (ns1__getProperties *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getResponse:
    soap_serialize_PointerTons1__getResponse(soap, (ns1__getResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__get:
    soap_serialize_PointerTons1__get(soap, (ns1__get *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getUserNameResponse:
    soap_serialize_PointerTons1__getUserNameResponse(soap, (ns1__getUserNameResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__getUserName:
    soap_serialize_PointerTons1__getUserName(soap, (ns1__getUserName *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__loginResponse:
    soap_serialize_PointerTons1__loginResponse(soap, (ns1__loginResponse *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__login:
    soap_serialize_PointerTons1__login(soap, (ns1__login *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__IcatException:
    soap_serialize_PointerTons1__IcatException(soap, (ns1__IcatException *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__parameterValueType:
    soap_serialize_PointerTons1__parameterValueType(soap, (enum ns1__parameterValueType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__permissibleStringValue:
    soap_serialize_PointerTons1__permissibleStringValue(soap, (ns1__permissibleStringValue *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTodouble:
    soap_serialize_PointerTodouble(soap, (double *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__rule:
    soap_serialize_PointerTons1__rule(soap, (ns1__rule *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__sampleType:
    soap_serialize_PointerTons1__sampleType(soap, (ns1__sampleType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__investigationParameter:
    soap_serialize_PointerTons1__investigationParameter(soap, (ns1__investigationParameter *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__investigationInstrument:
    soap_serialize_PointerTons1__investigationInstrument(soap, (ns1__investigationInstrument *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__accessType:
    soap_serialize_PointerTons1__accessType(soap, (enum ns1__accessType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerToxsd__anyType:
    soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerToint:
    soap_serialize_PointerToint(soap, (int *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__relType:
    soap_serialize_PointerTons1__relType(soap, (enum ns1__relType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__entityField:
    soap_serialize_PointerTons1__entityField(soap, (ns1__entityField *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__constraint:
    soap_serialize_PointerTons1__constraint(soap, (ns1__constraint *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__entityInfo:
    soap_serialize_PointerTons1__entityInfo(soap, (ns1__entityInfo *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__publicStep:
    soap_serialize_PointerTons1__publicStep(soap, (ns1__publicStep *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__log:
    soap_serialize_PointerTons1__log(soap, (ns1__log *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__userGroup:
    soap_serialize_PointerTons1__userGroup(soap, (ns1__userGroup *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__grouping:
    soap_serialize_PointerTons1__grouping(soap, (ns1__grouping *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDatafile:
    soap_serialize_PointerTons1__dataCollectionDatafile(soap, (ns1__dataCollectionDatafile *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionDataset:
    soap_serialize_PointerTons1__dataCollectionDataset(soap, (ns1__dataCollectionDataset *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dataCollectionParameter:
    soap_serialize_PointerTons1__dataCollectionParameter(soap, (ns1__dataCollectionParameter *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dataCollection:
    soap_serialize_PointerTons1__dataCollection(soap, (ns1__dataCollection *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__job:
    soap_serialize_PointerTons1__job(soap, (ns1__job *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__application:
    soap_serialize_PointerTons1__application(soap, (ns1__application *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__studyStatus:
    soap_serialize_PointerTons1__studyStatus(soap, (enum ns1__studyStatus *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__studyInvestigation:
    soap_serialize_PointerTons1__studyInvestigation(soap, (ns1__studyInvestigation *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__study:
    soap_serialize_PointerTons1__study(soap, (ns1__study *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__shift:
    soap_serialize_PointerTons1__shift(soap, (ns1__shift *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__sampleParameter:
    soap_serialize_PointerTons1__sampleParameter(soap, (ns1__sampleParameter *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__sample:
    soap_serialize_PointerTons1__sample(soap, (ns1__sample *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__relatedDatafile:
    soap_serialize_PointerTons1__relatedDatafile(soap, (ns1__relatedDatafile *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__publication:
    soap_serialize_PointerTons1__publication(soap, (ns1__publication *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__parameterType:
    soap_serialize_PointerTons1__parameterType(soap, (ns1__parameterType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__keyword:
    soap_serialize_PointerTons1__keyword(soap, (ns1__keyword *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__investigationUser:
    soap_serialize_PointerTons1__investigationUser(soap, (ns1__investigationUser *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__investigationType:
    soap_serialize_PointerTons1__investigationType(soap, (ns1__investigationType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__investigation:
    soap_serialize_PointerTons1__investigation(soap, (ns1__investigation *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__instrument:
    soap_serialize_PointerTons1__instrument(soap, (ns1__instrument *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__user:
    soap_serialize_PointerTons1__user(soap, (ns1__user *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__instrumentScientist:
    soap_serialize_PointerTons1__instrumentScientist(soap, (ns1__instrumentScientist *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__facilityCycle:
    soap_serialize_PointerTons1__facilityCycle(soap, (ns1__facilityCycle *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__facility:
    soap_serialize_PointerTons1__facility(soap, (ns1__facility *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__datasetType:
    soap_serialize_PointerTons1__datasetType(soap, (ns1__datasetType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__datasetParameter:
    soap_serialize_PointerTons1__datasetParameter(soap, (ns1__datasetParameter *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__dataset:
    soap_serialize_PointerTons1__dataset(soap, (ns1__dataset *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__datafileParameter:
    soap_serialize_PointerTons1__datafileParameter(soap, (ns1__datafileParameter *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__datafileFormat:
    soap_serialize_PointerTons1__datafileFormat(soap, (ns1__datafileFormat *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__datafile:
    soap_serialize_PointerTons1__datafile(soap, (ns1__datafile *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerToLONG64:
    soap_serialize_PointerToLONG64(soap, (LONG64 *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTotime:
    soap_serialize_PointerTotime(soap, (time_t *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__entityBaseBean:
    soap_serialize_PointerTons1__entityBaseBean(soap, (ns1__entityBaseBean *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTons1__icatExceptionType:
    soap_serialize_PointerTons1__icatExceptionType(soap, (enum ns1__icatExceptionType *const *)ptr);
    break;
  case SOAP_TYPE_ICat4_PointerTostd__string:
    soap_serialize_PointerTostd__string(soap, (std::string *const *)ptr);
    break;
  case SOAP_TYPE_ICat4__QName:
    soap_serialize_string(soap, (char *const *)&ptr);
    break;
  case SOAP_TYPE_ICat4_string:
    soap_serialize_string(soap, (char *const *)&ptr);
    break;
  }
}
#endif

SOAP_FMAC3 void *SOAP_FMAC4 ICat4_instantiate(struct soap *soap, int t, const char *type, const char *arrayType,
                                              size_t *n) {
  (void)type;
  switch (t) {
  case SOAP_TYPE_ICat4_xsd__anyType:
    return (void *)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__boolean:
    return (void *)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__dateTime:
    return (void *)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__double:
    return (void *)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__int:
    return (void *)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__long:
    return (void *)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__string:
    return (void *)soap_instantiate_std__string(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_xsd__string:
    return (void *)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__icatExceptionType_:
    return (void *)soap_instantiate_ns1__icatExceptionType_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__studyStatus_:
    return (void *)soap_instantiate_ns1__studyStatus_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__parameterValueType_:
    return (void *)soap_instantiate_ns1__parameterValueType_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__relType_:
    return (void *)soap_instantiate_ns1__relType_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__accessType_:
    return (void *)soap_instantiate_ns1__accessType_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneClear:
    return (void *)soap_instantiate_ns1__luceneClear(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneClearResponse:
    return (void *)soap_instantiate_ns1__luceneClearResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__IcatException:
    return (void *)soap_instantiate_ns1__IcatException(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__createMany:
    return (void *)soap_instantiate_ns1__createMany(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__entityBaseBean:
    return (void *)soap_instantiate_ns1__entityBaseBean(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__createManyResponse:
    return (void *)soap_instantiate_ns1__createManyResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__create:
    return (void *)soap_instantiate_ns1__create(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__createResponse:
    return (void *)soap_instantiate_ns1__createResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getProperties:
    return (void *)soap_instantiate_ns1__getProperties(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getPropertiesResponse:
    return (void *)soap_instantiate_ns1__getPropertiesResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneSearch:
    return (void *)soap_instantiate_ns1__luceneSearch(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneSearchResponse:
    return (void *)soap_instantiate_ns1__luceneSearchResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__lucenePopulate:
    return (void *)soap_instantiate_ns1__lucenePopulate(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__lucenePopulateResponse:
    return (void *)soap_instantiate_ns1__lucenePopulateResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__get:
    return (void *)soap_instantiate_ns1__get(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getResponse:
    return (void *)soap_instantiate_ns1__getResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getEntityNames:
    return (void *)soap_instantiate_ns1__getEntityNames(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getEntityNamesResponse:
    return (void *)soap_instantiate_ns1__getEntityNamesResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getApiVersion:
    return (void *)soap_instantiate_ns1__getApiVersion(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getApiVersionResponse:
    return (void *)soap_instantiate_ns1__getApiVersionResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulating:
    return (void *)soap_instantiate_ns1__luceneGetPopulating(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse:
    return (void *)soap_instantiate_ns1__luceneGetPopulatingResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__update:
    return (void *)soap_instantiate_ns1__update(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__updateResponse:
    return (void *)soap_instantiate_ns1__updateResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__deleteMany:
    return (void *)soap_instantiate_ns1__deleteMany(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__deleteManyResponse:
    return (void *)soap_instantiate_ns1__deleteManyResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getUserName:
    return (void *)soap_instantiate_ns1__getUserName(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getUserNameResponse:
    return (void *)soap_instantiate_ns1__getUserNameResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__refresh:
    return (void *)soap_instantiate_ns1__refresh(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__refreshResponse:
    return (void *)soap_instantiate_ns1__refreshResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4__ns1__login_credentials_entry:
    return (void *)soap_instantiate__ns1__login_credentials_entry(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4__ns1__login_credentials:
    return (void *)soap_instantiate__ns1__login_credentials(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__login:
    return (void *)soap_instantiate_ns1__login(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__loginResponse:
    return (void *)soap_instantiate_ns1__loginResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dummy:
    return (void *)soap_instantiate_ns1__dummy(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dummyResponse:
    return (void *)soap_instantiate_ns1__dummyResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getEntityInfo:
    return (void *)soap_instantiate_ns1__getEntityInfo(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getEntityInfoResponse:
    return (void *)soap_instantiate_ns1__getEntityInfoResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__entityInfo:
    return (void *)soap_instantiate_ns1__entityInfo(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__constraint:
    return (void *)soap_instantiate_ns1__constraint(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__entityField:
    return (void *)soap_instantiate_ns1__entityField(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneCommit:
    return (void *)soap_instantiate_ns1__luceneCommit(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__luceneCommitResponse:
    return (void *)soap_instantiate_ns1__luceneCommitResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__searchText:
    return (void *)soap_instantiate_ns1__searchText(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__searchTextResponse:
    return (void *)soap_instantiate_ns1__searchTextResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__delete:
    return (void *)soap_instantiate_ns1__delete(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__deleteResponse:
    return (void *)soap_instantiate_ns1__deleteResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__isAccessAllowed:
    return (void *)soap_instantiate_ns1__isAccessAllowed(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse:
    return (void *)soap_instantiate_ns1__isAccessAllowedResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__search:
    return (void *)soap_instantiate_ns1__search(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__searchResponse:
    return (void *)soap_instantiate_ns1__searchResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__logout:
    return (void *)soap_instantiate_ns1__logout(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__logoutResponse:
    return (void *)soap_instantiate_ns1__logoutResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutes:
    return (void *)soap_instantiate_ns1__getRemainingMinutes(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse:
    return (void *)soap_instantiate_ns1__getRemainingMinutesResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__datafile:
    return (void *)soap_instantiate_ns1__datafile(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dataCollectionDatafile:
    return (void *)soap_instantiate_ns1__dataCollectionDatafile(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dataCollection:
    return (void *)soap_instantiate_ns1__dataCollection(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dataCollectionDataset:
    return (void *)soap_instantiate_ns1__dataCollectionDataset(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dataset:
    return (void *)soap_instantiate_ns1__dataset(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__investigation:
    return (void *)soap_instantiate_ns1__investigation(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__facility:
    return (void *)soap_instantiate_ns1__facility(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__application:
    return (void *)soap_instantiate_ns1__application(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__job:
    return (void *)soap_instantiate_ns1__job(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__datafileFormat:
    return (void *)soap_instantiate_ns1__datafileFormat(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__datasetType:
    return (void *)soap_instantiate_ns1__datasetType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__facilityCycle:
    return (void *)soap_instantiate_ns1__facilityCycle(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__instrument:
    return (void *)soap_instantiate_ns1__instrument(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__instrumentScientist:
    return (void *)soap_instantiate_ns1__instrumentScientist(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__user:
    return (void *)soap_instantiate_ns1__user(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__investigationUser:
    return (void *)soap_instantiate_ns1__investigationUser(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__study:
    return (void *)soap_instantiate_ns1__study(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__studyInvestigation:
    return (void *)soap_instantiate_ns1__studyInvestigation(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__userGroup:
    return (void *)soap_instantiate_ns1__userGroup(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__grouping:
    return (void *)soap_instantiate_ns1__grouping(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__rule:
    return (void *)soap_instantiate_ns1__rule(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__investigationInstrument:
    return (void *)soap_instantiate_ns1__investigationInstrument(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__investigationType:
    return (void *)soap_instantiate_ns1__investigationType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__parameterType:
    return (void *)soap_instantiate_ns1__parameterType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__parameter:
    return (void *)soap_instantiate_ns1__parameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__permissibleStringValue:
    return (void *)soap_instantiate_ns1__permissibleStringValue(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__sample:
    return (void *)soap_instantiate_ns1__sample(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__sampleType:
    return (void *)soap_instantiate_ns1__sampleType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__keyword:
    return (void *)soap_instantiate_ns1__keyword(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__publication:
    return (void *)soap_instantiate_ns1__publication(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__shift:
    return (void *)soap_instantiate_ns1__shift(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__relatedDatafile:
    return (void *)soap_instantiate_ns1__relatedDatafile(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__log:
    return (void *)soap_instantiate_ns1__log(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__publicStep:
    return (void *)soap_instantiate_ns1__publicStep(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__dataCollectionParameter:
    return (void *)soap_instantiate_ns1__dataCollectionParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__datafileParameter:
    return (void *)soap_instantiate_ns1__datafileParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__datasetParameter:
    return (void *)soap_instantiate_ns1__datasetParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__investigationParameter:
    return (void *)soap_instantiate_ns1__investigationParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_ns1__sampleParameter:
    return (void *)soap_instantiate_ns1__sampleParameter(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Detail:
    return (void *)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
  case SOAP_TYPE_ICat4___ns1__login:
    return (void *)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getUserName:
    return (void *)soap_instantiate___ns1__getUserName(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__get:
    return (void *)soap_instantiate___ns1__get(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getProperties:
    return (void *)soap_instantiate___ns1__getProperties(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__deleteResponse:
    return (void *)soap_instantiate___ns1__deleteResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__delete:
    return (void *)soap_instantiate___ns1__delete(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__search:
    return (void *)soap_instantiate___ns1__search(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__create:
    return (void *)soap_instantiate___ns1__create(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__updateResponse:
    return (void *)soap_instantiate___ns1__updateResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__update:
    return (void *)soap_instantiate___ns1__update(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getApiVersion:
    return (void *)soap_instantiate___ns1__getApiVersion(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getEntityNames:
    return (void *)soap_instantiate___ns1__getEntityNames(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__refreshResponse:
    return (void *)soap_instantiate___ns1__refreshResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__refresh:
    return (void *)soap_instantiate___ns1__refresh(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__dummyResponse:
    return (void *)soap_instantiate___ns1__dummyResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__dummy:
    return (void *)soap_instantiate___ns1__dummy(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__logoutResponse:
    return (void *)soap_instantiate___ns1__logoutResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__logout:
    return (void *)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getRemainingMinutes:
    return (void *)soap_instantiate___ns1__getRemainingMinutes(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__searchText:
    return (void *)soap_instantiate___ns1__searchText(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__isAccessAllowed:
    return (void *)soap_instantiate___ns1__isAccessAllowed(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__lucenePopulateResponse:
    return (void *)soap_instantiate___ns1__lucenePopulateResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__lucenePopulate:
    return (void *)soap_instantiate___ns1__lucenePopulate(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneClearResponse:
    return (void *)soap_instantiate___ns1__luceneClearResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneClear:
    return (void *)soap_instantiate___ns1__luceneClear(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneCommitResponse:
    return (void *)soap_instantiate___ns1__luceneCommitResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneCommit:
    return (void *)soap_instantiate___ns1__luceneCommit(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneSearch:
    return (void *)soap_instantiate___ns1__luceneSearch(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__luceneGetPopulating:
    return (void *)soap_instantiate___ns1__luceneGetPopulating(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__createMany:
    return (void *)soap_instantiate___ns1__createMany(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__deleteManyResponse:
    return (void *)soap_instantiate___ns1__deleteManyResponse(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__deleteMany:
    return (void *)soap_instantiate___ns1__deleteMany(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4___ns1__getEntityInfo:
    return (void *)soap_instantiate___ns1__getEntityInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Header:
    return (void *)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Code:
    return (void *)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Reason:
    return (void *)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Fault:
    return (void *)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleParameter:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__sampleParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__permissibleStringValue:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__permissibleStringValue(soap, -1, type, arrayType,
                                                                                              n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__rule:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__rule(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__userGroup:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__userGroup(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__study:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__study(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrumentScientist:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, -1, type, arrayType,
                                                                                           n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleType:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__sampleType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__parameterType:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__parameterType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigation:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__investigation(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationType:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__investigationType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrument:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__instrument(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__facilityCycle:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__facilityCycle(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetType:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__datasetType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileFormat:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__datafileFormat(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__application:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__application(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__studyInvestigation:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__shift:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__shift(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sample:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__sample(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__publication:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__publication(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationParameter:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__investigationParameter(soap, -1, type, arrayType,
                                                                                              n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__keyword:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__keyword(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationUser:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__investigationUser(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationInstrument:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__investigationInstrument(soap, -1, type,
                                                                                               arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataset:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__dataset(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetParameter:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__datasetParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafile:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__datafile(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionParameter:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionParameter(soap, -1, type,
                                                                                               arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__job:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__job(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDataset:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap, -1, type, arrayType,
                                                                                             n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileParameter:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__datafileParameter(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__relatedDatafile:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDatafile:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(soap, -1, type, arrayType,
                                                                                              n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerToxsd__anyType:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityField:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__entityField(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__constraint:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__constraint(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry:
    return (void *)soap_instantiate_std__vectorTemplateOf_ns1__login_credentials_entry(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfstd__string:
    return (void *)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfLONG64:
    return (void *)soap_instantiate_std__vectorTemplateOfLONG64(soap, -1, type, arrayType, n);
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityBaseBean:
    return (void *)soap_instantiate_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, -1, type, arrayType, n);
  }
  return nullptr;
}

SOAP_FMAC3 int SOAP_FMAC4 ICat4_fdelete(struct soap_clist *p) {
  switch (p->type) {
  case SOAP_TYPE_ICat4_xsd__anyType:
    if (p->size < 0)
      SOAP_DELETE((xsd__anyType *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__anyType *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__boolean:
    if (p->size < 0)
      SOAP_DELETE((xsd__boolean *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__boolean *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__dateTime:
    if (p->size < 0)
      SOAP_DELETE((xsd__dateTime *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__dateTime *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__double:
    if (p->size < 0)
      SOAP_DELETE((xsd__double *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__double *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__int:
    if (p->size < 0)
      SOAP_DELETE((xsd__int *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__int *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__long:
    if (p->size < 0)
      SOAP_DELETE((xsd__long *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__long *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__string:
    if (p->size < 0)
      SOAP_DELETE((std::string *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::string *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_xsd__string:
    if (p->size < 0)
      SOAP_DELETE((xsd__string *)p->ptr);
    else
      SOAP_DELETE_ARRAY((xsd__string *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__icatExceptionType_:
    if (p->size < 0)
      SOAP_DELETE((ns1__icatExceptionType_ *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__icatExceptionType_ *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__studyStatus_:
    if (p->size < 0)
      SOAP_DELETE((ns1__studyStatus_ *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__studyStatus_ *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__parameterValueType_:
    if (p->size < 0)
      SOAP_DELETE((ns1__parameterValueType_ *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__parameterValueType_ *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__relType_:
    if (p->size < 0)
      SOAP_DELETE((ns1__relType_ *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__relType_ *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__accessType_:
    if (p->size < 0)
      SOAP_DELETE((ns1__accessType_ *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__accessType_ *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneClear:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneClear *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneClear *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneClearResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneClearResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneClearResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__IcatException:
    if (p->size < 0)
      SOAP_DELETE((ns1__IcatException *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__IcatException *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__createMany:
    if (p->size < 0)
      SOAP_DELETE((ns1__createMany *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__createMany *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__entityBaseBean:
    if (p->size < 0)
      SOAP_DELETE((ns1__entityBaseBean *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__entityBaseBean *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__createManyResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__createManyResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__createManyResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__create:
    if (p->size < 0)
      SOAP_DELETE((ns1__create *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__create *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__createResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__createResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__createResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getProperties:
    if (p->size < 0)
      SOAP_DELETE((ns1__getProperties *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getProperties *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getPropertiesResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getPropertiesResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getPropertiesResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneSearch:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneSearch *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneSearch *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneSearchResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneSearchResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneSearchResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__lucenePopulate:
    if (p->size < 0)
      SOAP_DELETE((ns1__lucenePopulate *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__lucenePopulate *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__lucenePopulateResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__lucenePopulateResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__lucenePopulateResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__get:
    if (p->size < 0)
      SOAP_DELETE((ns1__get *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__get *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityNames:
    if (p->size < 0)
      SOAP_DELETE((ns1__getEntityNames *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getEntityNames *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityNamesResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getEntityNamesResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getEntityNamesResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getApiVersion:
    if (p->size < 0)
      SOAP_DELETE((ns1__getApiVersion *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getApiVersion *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getApiVersionResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getApiVersionResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getApiVersionResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulating:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneGetPopulating *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneGetPopulating *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneGetPopulatingResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneGetPopulatingResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__update:
    if (p->size < 0)
      SOAP_DELETE((ns1__update *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__update *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__updateResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__updateResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__updateResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteMany:
    if (p->size < 0)
      SOAP_DELETE((ns1__deleteMany *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__deleteMany *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteManyResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__deleteManyResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__deleteManyResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getUserName:
    if (p->size < 0)
      SOAP_DELETE((ns1__getUserName *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getUserName *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getUserNameResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getUserNameResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getUserNameResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__refresh:
    if (p->size < 0)
      SOAP_DELETE((ns1__refresh *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__refresh *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__refreshResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__refreshResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__refreshResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4__ns1__login_credentials_entry:
    if (p->size < 0)
      SOAP_DELETE((_ns1__login_credentials_entry *)p->ptr);
    else
      SOAP_DELETE_ARRAY((_ns1__login_credentials_entry *)p->ptr);
    break;
  case SOAP_TYPE_ICat4__ns1__login_credentials:
    if (p->size < 0)
      SOAP_DELETE((_ns1__login_credentials *)p->ptr);
    else
      SOAP_DELETE_ARRAY((_ns1__login_credentials *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__login:
    if (p->size < 0)
      SOAP_DELETE((ns1__login *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__login *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__loginResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__loginResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__loginResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dummy:
    if (p->size < 0)
      SOAP_DELETE((ns1__dummy *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dummy *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dummyResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__dummyResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dummyResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityInfo:
    if (p->size < 0)
      SOAP_DELETE((ns1__getEntityInfo *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getEntityInfo *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getEntityInfoResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getEntityInfoResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getEntityInfoResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__entityInfo:
    if (p->size < 0)
      SOAP_DELETE((ns1__entityInfo *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__entityInfo *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__constraint:
    if (p->size < 0)
      SOAP_DELETE((ns1__constraint *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__constraint *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__entityField:
    if (p->size < 0)
      SOAP_DELETE((ns1__entityField *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__entityField *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneCommit:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneCommit *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneCommit *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__luceneCommitResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__luceneCommitResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__luceneCommitResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__searchText:
    if (p->size < 0)
      SOAP_DELETE((ns1__searchText *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__searchText *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__searchTextResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__searchTextResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__searchTextResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__delete:
    if (p->size < 0)
      SOAP_DELETE((ns1__delete *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__delete *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__deleteResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__deleteResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__deleteResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__isAccessAllowed:
    if (p->size < 0)
      SOAP_DELETE((ns1__isAccessAllowed *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__isAccessAllowed *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__isAccessAllowedResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__isAccessAllowedResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__search:
    if (p->size < 0)
      SOAP_DELETE((ns1__search *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__search *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__searchResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__searchResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__searchResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__logout:
    if (p->size < 0)
      SOAP_DELETE((ns1__logout *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__logout *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__logoutResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__logoutResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__logoutResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutes:
    if (p->size < 0)
      SOAP_DELETE((ns1__getRemainingMinutes *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getRemainingMinutes *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse:
    if (p->size < 0)
      SOAP_DELETE((ns1__getRemainingMinutesResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__getRemainingMinutesResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__datafile:
    if (p->size < 0)
      SOAP_DELETE((ns1__datafile *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__datafile *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionDatafile:
    if (p->size < 0)
      SOAP_DELETE((ns1__dataCollectionDatafile *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dataCollectionDatafile *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollection:
    if (p->size < 0)
      SOAP_DELETE((ns1__dataCollection *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dataCollection *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionDataset:
    if (p->size < 0)
      SOAP_DELETE((ns1__dataCollectionDataset *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dataCollectionDataset *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dataset:
    if (p->size < 0)
      SOAP_DELETE((ns1__dataset *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dataset *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__investigation:
    if (p->size < 0)
      SOAP_DELETE((ns1__investigation *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__investigation *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__facility:
    if (p->size < 0)
      SOAP_DELETE((ns1__facility *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__facility *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__application:
    if (p->size < 0)
      SOAP_DELETE((ns1__application *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__application *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__job:
    if (p->size < 0)
      SOAP_DELETE((ns1__job *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__job *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__datafileFormat:
    if (p->size < 0)
      SOAP_DELETE((ns1__datafileFormat *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__datafileFormat *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__datasetType:
    if (p->size < 0)
      SOAP_DELETE((ns1__datasetType *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__datasetType *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__facilityCycle:
    if (p->size < 0)
      SOAP_DELETE((ns1__facilityCycle *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__facilityCycle *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__instrument:
    if (p->size < 0)
      SOAP_DELETE((ns1__instrument *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__instrument *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__instrumentScientist:
    if (p->size < 0)
      SOAP_DELETE((ns1__instrumentScientist *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__instrumentScientist *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__user:
    if (p->size < 0)
      SOAP_DELETE((ns1__user *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__user *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationUser:
    if (p->size < 0)
      SOAP_DELETE((ns1__investigationUser *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__investigationUser *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__study:
    if (p->size < 0)
      SOAP_DELETE((ns1__study *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__study *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__studyInvestigation:
    if (p->size < 0)
      SOAP_DELETE((ns1__studyInvestigation *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__studyInvestigation *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__userGroup:
    if (p->size < 0)
      SOAP_DELETE((ns1__userGroup *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__userGroup *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__grouping:
    if (p->size < 0)
      SOAP_DELETE((ns1__grouping *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__grouping *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__rule:
    if (p->size < 0)
      SOAP_DELETE((ns1__rule *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__rule *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationInstrument:
    if (p->size < 0)
      SOAP_DELETE((ns1__investigationInstrument *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__investigationInstrument *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationType:
    if (p->size < 0)
      SOAP_DELETE((ns1__investigationType *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__investigationType *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__parameterType:
    if (p->size < 0)
      SOAP_DELETE((ns1__parameterType *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__parameterType *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__parameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__parameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__parameter *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__permissibleStringValue:
    if (p->size < 0)
      SOAP_DELETE((ns1__permissibleStringValue *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__permissibleStringValue *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__sample:
    if (p->size < 0)
      SOAP_DELETE((ns1__sample *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__sample *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__sampleType:
    if (p->size < 0)
      SOAP_DELETE((ns1__sampleType *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__sampleType *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__keyword:
    if (p->size < 0)
      SOAP_DELETE((ns1__keyword *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__keyword *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__publication:
    if (p->size < 0)
      SOAP_DELETE((ns1__publication *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__publication *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__shift:
    if (p->size < 0)
      SOAP_DELETE((ns1__shift *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__shift *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__relatedDatafile:
    if (p->size < 0)
      SOAP_DELETE((ns1__relatedDatafile *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__relatedDatafile *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__log:
    if (p->size < 0)
      SOAP_DELETE((ns1__log *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__log *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__publicStep:
    if (p->size < 0)
      SOAP_DELETE((ns1__publicStep *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__publicStep *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__dataCollectionParameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__dataCollectionParameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__dataCollectionParameter *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__datafileParameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__datafileParameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__datafileParameter *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__datasetParameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__datasetParameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__datasetParameter *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__investigationParameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__investigationParameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__investigationParameter *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_ns1__sampleParameter:
    if (p->size < 0)
      SOAP_DELETE((ns1__sampleParameter *)p->ptr);
    else
      SOAP_DELETE_ARRAY((ns1__sampleParameter *)p->ptr);
    break;
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Detail:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Detail *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail *)p->ptr);
    break;
#endif
  case SOAP_TYPE_ICat4___ns1__login:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__login *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__login *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getUserName:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getUserName *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getUserName *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__get:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__get *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__get *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getProperties:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getProperties *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getProperties *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__deleteResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__deleteResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__delete:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__delete *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__delete *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__search:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__search *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__search *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__create:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__create *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__create *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__updateResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__updateResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__updateResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__update:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__update *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__update *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getApiVersion:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getApiVersion *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getApiVersion *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getEntityNames:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getEntityNames *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getEntityNames *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__refreshResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__refreshResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__refreshResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__refresh:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__refresh *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__refresh *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__dummyResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__dummyResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__dummyResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__dummy:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__dummy *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__dummy *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__logoutResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__logoutResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__logoutResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__logout:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__logout *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__logout *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getRemainingMinutes:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getRemainingMinutes *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getRemainingMinutes *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__searchText:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__searchText *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__searchText *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__isAccessAllowed:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__isAccessAllowed *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__isAccessAllowed *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__lucenePopulateResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__lucenePopulateResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__lucenePopulateResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__lucenePopulate:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__lucenePopulate *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__lucenePopulate *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneClearResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneClearResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneClearResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneClear:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneClear *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneClear *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneCommitResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneCommitResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneCommitResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneCommit:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneCommit *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneCommit *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneSearch:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneSearch *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneSearch *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__luceneGetPopulating:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__luceneGetPopulating *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__luceneGetPopulating *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__createMany:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__createMany *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__createMany *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteManyResponse:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__deleteManyResponse *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__deleteManyResponse *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__deleteMany:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__deleteMany *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__deleteMany *)p->ptr);
    break;
  case SOAP_TYPE_ICat4___ns1__getEntityInfo:
    if (p->size < 0)
      SOAP_DELETE((struct __ns1__getEntityInfo *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct __ns1__getEntityInfo *)p->ptr);
    break;
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Header:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Header *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Header *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Code:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Code *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Code *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Reason:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Reason *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason *)p->ptr);
    break;
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_ICat4_SOAP_ENV__Fault:
    if (p->size < 0)
      SOAP_DELETE((struct SOAP_ENV__Fault *)p->ptr);
    else
      SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault *)p->ptr);
    break;
#endif
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleParameter:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__sampleParameter *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__sampleParameter *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__permissibleStringValue:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__permissibleStringValue *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__permissibleStringValue *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__rule:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__rule *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__rule *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__userGroup:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__userGroup *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__userGroup *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__study:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__study *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__study *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrumentScientist:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__instrumentScientist *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__instrumentScientist *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleType:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__sampleType *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__sampleType *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__parameterType:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__parameterType *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__parameterType *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigation:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__investigation *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__investigation *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationType:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__investigationType *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__investigationType *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrument:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__instrument *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__instrument *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__facilityCycle:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__facilityCycle *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__facilityCycle *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetType:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__datasetType *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__datasetType *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileFormat:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__datafileFormat *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__datafileFormat *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__application:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__application *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__application *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__studyInvestigation:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__studyInvestigation *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__studyInvestigation *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__shift:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__shift *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__shift *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sample:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__sample *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__sample *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__publication:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__publication *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__publication *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationParameter:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__investigationParameter *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__investigationParameter *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__keyword:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__keyword *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__keyword *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationUser:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__investigationUser *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__investigationUser *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationInstrument:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__investigationInstrument *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__investigationInstrument *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataset:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__dataset *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__dataset *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetParameter:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__datasetParameter *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__datasetParameter *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafile:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__datafile *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__datafile *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionParameter:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__dataCollectionParameter *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__dataCollectionParameter *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__job:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__job *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__job *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDataset:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__dataCollectionDataset *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__dataCollectionDataset *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileParameter:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__datafileParameter *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__datafileParameter *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__relatedDatafile:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__relatedDatafile *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__relatedDatafile *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDatafile:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__dataCollectionDatafile *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__dataCollectionDatafile *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerToxsd__anyType:
    if (p->size < 0)
      SOAP_DELETE((std::vector<xsd__anyType *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<xsd__anyType *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityField:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__entityField *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__entityField *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__constraint:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__constraint *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__constraint *> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry:
    if (p->size < 0)
      SOAP_DELETE((std::vector<_ns1__login_credentials_entry> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<_ns1__login_credentials_entry> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfstd__string:
    if (p->size < 0)
      SOAP_DELETE((std::vector<std::string> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<std::string> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfLONG64:
    if (p->size < 0)
      SOAP_DELETE((std::vector<LONG64> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<LONG64> *)p->ptr);
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityBaseBean:
    if (p->size < 0)
      SOAP_DELETE((std::vector<ns1__entityBaseBean *> *)p->ptr);
    else
      SOAP_DELETE_ARRAY((std::vector<ns1__entityBaseBean *> *)p->ptr);
    break;
  default:
    return SOAP_ERR;
  }
  return SOAP_OK;
}

SOAP_FMAC3 void *SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n,
                                                const char *type, const char *arrayType) {
  return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, ICat4_instantiate);
}

SOAP_FMAC3 void *SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st,
                                                      int tt, size_t n, unsigned int k) {
  return soap_id_forward(soap, href, p, len, st, tt, n, k, ICat4_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 ICat4_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable : 4065)
#endif
{
  (void)soap;
  (void)st;
  (void)p;
  (void)len;
  (void)q;
  (void)n; /* appease -Wall -Werror */
  switch (tt) {
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleParameter:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__sampleParameter *> *)p)[len] = *(ns1__sampleParameter **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__permissibleStringValue:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__permissibleStringValue *> *)p)[len] = *(ns1__permissibleStringValue **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__rule:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__rule *> *)p)[len] = *(ns1__rule **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__userGroup:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__userGroup *> *)p)[len] = *(ns1__userGroup **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__study:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__study *> *)p)[len] = *(ns1__study **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrumentScientist:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__instrumentScientist *> *)p)[len] = *(ns1__instrumentScientist **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleType:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__sampleType *> *)p)[len] = *(ns1__sampleType **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__parameterType:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__parameterType *> *)p)[len] = *(ns1__parameterType **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigation:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__investigation *> *)p)[len] = *(ns1__investigation **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationType:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__investigationType *> *)p)[len] = *(ns1__investigationType **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrument:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__instrument *> *)p)[len] = *(ns1__instrument **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__facilityCycle:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__facilityCycle *> *)p)[len] = *(ns1__facilityCycle **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetType:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__datasetType *> *)p)[len] = *(ns1__datasetType **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileFormat:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__datafileFormat *> *)p)[len] = *(ns1__datafileFormat **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__application:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__application *> *)p)[len] = *(ns1__application **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__studyInvestigation:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__studyInvestigation *> *)p)[len] = *(ns1__studyInvestigation **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__shift:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__shift *> *)p)[len] = *(ns1__shift **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sample:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__sample *> *)p)[len] = *(ns1__sample **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__publication:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__publication *> *)p)[len] = *(ns1__publication **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationParameter:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__investigationParameter *> *)p)[len] = *(ns1__investigationParameter **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__keyword:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__keyword *> *)p)[len] = *(ns1__keyword **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationUser:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__investigationUser *> *)p)[len] = *(ns1__investigationUser **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationInstrument:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__investigationInstrument *> *)p)[len] = *(ns1__investigationInstrument **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataset:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__dataset *> *)p)[len] = *(ns1__dataset **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetParameter:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__datasetParameter *> *)p)[len] = *(ns1__datasetParameter **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafile:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__datafile *> *)p)[len] = *(ns1__datafile **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionParameter:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__dataCollectionParameter *> *)p)[len] = *(ns1__dataCollectionParameter **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__job:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__job *> *)p)[len] = *(ns1__job **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDataset:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__dataCollectionDataset *> *)p)[len] = *(ns1__dataCollectionDataset **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileParameter:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__datafileParameter *> *)p)[len] = *(ns1__datafileParameter **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__relatedDatafile:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__relatedDatafile *> *)p)[len] = *(ns1__relatedDatafile **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDatafile:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__dataCollectionDatafile *> *)p)[len] = *(ns1__dataCollectionDatafile **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerToxsd__anyType:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<xsd__anyType *> *)p)[len] = *(xsd__anyType **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityField:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__entityField *> *)p)[len] = *(ns1__entityField **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__constraint:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__constraint *> *)p)[len] = *(ns1__constraint **)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<_ns1__login_credentials_entry> *)p)[len] = *(_ns1__login_credentials_entry *)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfstd__string:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<std::string> *)p)[len] = *(std::string *)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfLONG64:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<LONG64> *)p)[len] = *(LONG64 *)q;
    break;
  case SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityBaseBean:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                              "Container ICat4_container_insert type=%d in "
                              "%d location=%p object=%p len=%lu\n",
                              st, tt, p, q, (unsigned long)len));
    (*(std::vector<ns1__entityBaseBean *> *)p)[len] = *(ns1__entityBaseBean **)q;
    break;
  default:
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
  }
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_ICat4_byte);
}

SOAP_FMAC3 char *SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type) {
  char *p;
  p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_ICat4_byte);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_byte);
  if (soap_out_byte(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char *SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type) {
  if ((p = soap_in_byte(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ICat4_int);
}

SOAP_FMAC3 int *SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type) {
  int *p;
  p = soap_inint(soap, tag, a, type, SOAP_TYPE_ICat4_int);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_int);
  if (soap_out_int(soap, tag ? tag : "int", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int *SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type) {
  if ((p = soap_in_int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
  *a = SOAP_DEFAULT_LONG64;
#else
  *a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a,
                                          const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ICat4_LONG64);
}

SOAP_FMAC3 LONG64 *SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type) {
  LONG64 *p;
  p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ICat4_LONG64);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_LONG64);
  if (soap_out_LONG64(soap, tag ? tag : "long", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 *SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type) {
  if ((p = soap_in_LONG64(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
  *a = SOAP_DEFAULT_double;
#else
  *a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a,
                                          const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_ICat4_double);
}

SOAP_FMAC3 double *SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type) {
  double *p;
  p = soap_indouble(soap, tag, a, type, SOAP_TYPE_ICat4_double);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_double);
  if (soap_out_double(soap, tag ? tag : "double", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 double *SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type) {
  if ((p = soap_in_double(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
  *a = SOAP_DEFAULT_time;
#else
  *a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type) {
  (void)soap;
  (void)type;
  (void)tag;
  (void)id;
  return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ICat4_time);
}

SOAP_FMAC3 time_t *SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type) {
  time_t *p;
  p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ICat4_time);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_time);
  if (soap_out_time(soap, tag ? tag : "dateTime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 time_t *SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type) {
  if ((p = soap_in_time(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__accessType(struct soap *soap, enum ns1__accessType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__accessType
  *a = SOAP_DEFAULT_ns1__accessType;
#else
  *a = (enum ns1__accessType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__accessType[] = {{(long)ns1__accessType__READ, "READ"},
                                                                  {(long)ns1__accessType__UPDATE, "UPDATE"},
                                                                  {(long)ns1__accessType__DELETE, "DELETE"},
                                                                  {(long)ns1__accessType__CREATE, "CREATE"},
                                                                  {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_ns1__accessType2s(struct soap *soap, enum ns1__accessType n) {
  const char *s = soap_code_str(soap_codes_ns1__accessType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__accessType(struct soap *soap, const char *tag, int id,
                                                   const enum ns1__accessType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__accessType), type) ||
      soap_send(soap, soap_ns1__accessType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__accessType(struct soap *soap, const char *s, enum ns1__accessType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns1__accessType, s);
  if (map)
    *a = (enum ns1__accessType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns1__accessType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns1__accessType *SOAP_FMAC4 soap_in_ns1__accessType(struct soap *soap, const char *tag,
                                                                    enum ns1__accessType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (enum ns1__accessType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__accessType,
                                            sizeof(enum ns1__accessType), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns1__accessType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (enum ns1__accessType *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__accessType, 0,
                                                sizeof(enum ns1__accessType), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__accessType(struct soap *soap, const enum ns1__accessType *a, const char *tag,
                                                   const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__accessType);
  if (soap_out_ns1__accessType(soap, tag ? tag : "ns1:accessType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__accessType *SOAP_FMAC4 soap_get_ns1__accessType(struct soap *soap, enum ns1__accessType *p,
                                                                     const char *tag, const char *type) {
  if ((p = soap_in_ns1__accessType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__relType(struct soap *soap, enum ns1__relType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__relType
  *a = SOAP_DEFAULT_ns1__relType;
#else
  *a = (enum ns1__relType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__relType[] = {{(long)ns1__relType__ATTRIBUTE, "ATTRIBUTE"},
                                                               {(long)ns1__relType__MANY, "MANY"},
                                                               {(long)ns1__relType__ONE, "ONE"},
                                                               {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_ns1__relType2s(struct soap *soap, enum ns1__relType n) {
  const char *s = soap_code_str(soap_codes_ns1__relType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relType(struct soap *soap, const char *tag, int id, const enum ns1__relType *a,
                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__relType), type) ||
      soap_send(soap, soap_ns1__relType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__relType(struct soap *soap, const char *s, enum ns1__relType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns1__relType, s);
  if (map)
    *a = (enum ns1__relType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns1__relType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns1__relType *SOAP_FMAC4 soap_in_ns1__relType(struct soap *soap, const char *tag, enum ns1__relType *a,
                                                              const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (enum ns1__relType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__relType, sizeof(enum ns1__relType), 0,
                                         nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns1__relType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (enum ns1__relType *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__relType, 0,
                                             sizeof(enum ns1__relType), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__relType(struct soap *soap, const enum ns1__relType *a, const char *tag,
                                                const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__relType);
  if (soap_out_ns1__relType(soap, tag ? tag : "ns1:relType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__relType *SOAP_FMAC4 soap_get_ns1__relType(struct soap *soap, enum ns1__relType *p, const char *tag,
                                                               const char *type) {
  if ((p = soap_in_ns1__relType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__parameterValueType(struct soap *soap, enum ns1__parameterValueType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__parameterValueType
  *a = SOAP_DEFAULT_ns1__parameterValueType;
#else
  *a = (enum ns1__parameterValueType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__parameterValueType[] = {
    {(long)ns1__parameterValueType__DATE_USCOREAND_USCORETIME, "DATE_AND_TIME"},
    {(long)ns1__parameterValueType__NUMERIC, "NUMERIC"},
    {(long)ns1__parameterValueType__STRING, "STRING"},
    {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_ns1__parameterValueType2s(struct soap *soap, enum ns1__parameterValueType n) {
  const char *s = soap_code_str(soap_codes_ns1__parameterValueType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameterValueType(struct soap *soap, const char *tag, int id,
                                                           const enum ns1__parameterValueType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__parameterValueType), type) ||
      soap_send(soap, soap_ns1__parameterValueType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__parameterValueType(struct soap *soap, const char *s,
                                                           enum ns1__parameterValueType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns1__parameterValueType, s);
  if (map)
    *a = (enum ns1__parameterValueType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns1__parameterValueType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns1__parameterValueType *SOAP_FMAC4 soap_in_ns1__parameterValueType(struct soap *soap, const char *tag,
                                                                                    enum ns1__parameterValueType *a,
                                                                                    const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (enum ns1__parameterValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__parameterValueType,
                                                    sizeof(enum ns1__parameterValueType), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns1__parameterValueType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (enum ns1__parameterValueType *)soap_id_forward(soap, soap->href, (void *)a, 0,
                                                        SOAP_TYPE_ICat4_ns1__parameterValueType, 0,
                                                        sizeof(enum ns1__parameterValueType), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__parameterValueType(struct soap *soap, const enum ns1__parameterValueType *a,
                                                           const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__parameterValueType);
  if (soap_out_ns1__parameterValueType(soap, tag ? tag : "ns1:parameterValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__parameterValueType *SOAP_FMAC4 soap_get_ns1__parameterValueType(struct soap *soap,
                                                                                     enum ns1__parameterValueType *p,
                                                                                     const char *tag,
                                                                                     const char *type) {
  if ((p = soap_in_ns1__parameterValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__studyStatus(struct soap *soap, enum ns1__studyStatus *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__studyStatus
  *a = SOAP_DEFAULT_ns1__studyStatus;
#else
  *a = (enum ns1__studyStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__studyStatus[] = {
    {(long)ns1__studyStatus__NEW, "NEW"},
    {(long)ns1__studyStatus__IN_USCOREPROGRESS, "IN_PROGRESS"},
    {(long)ns1__studyStatus__COMPLETE, "COMPLETE"},
    {(long)ns1__studyStatus__CANCELLED, "CANCELLED"},
    {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_ns1__studyStatus2s(struct soap *soap, enum ns1__studyStatus n) {
  const char *s = soap_code_str(soap_codes_ns1__studyStatus, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__studyStatus(struct soap *soap, const char *tag, int id,
                                                    const enum ns1__studyStatus *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__studyStatus), type) ||
      soap_send(soap, soap_ns1__studyStatus2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__studyStatus(struct soap *soap, const char *s, enum ns1__studyStatus *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns1__studyStatus, s);
  if (map)
    *a = (enum ns1__studyStatus)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns1__studyStatus)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns1__studyStatus *SOAP_FMAC4 soap_in_ns1__studyStatus(struct soap *soap, const char *tag,
                                                                      enum ns1__studyStatus *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (enum ns1__studyStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__studyStatus,
                                             sizeof(enum ns1__studyStatus), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns1__studyStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (enum ns1__studyStatus *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__studyStatus, 0,
                                                 sizeof(enum ns1__studyStatus), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__studyStatus(struct soap *soap, const enum ns1__studyStatus *a, const char *tag,
                                                    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__studyStatus);
  if (soap_out_ns1__studyStatus(soap, tag ? tag : "ns1:studyStatus", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__studyStatus *SOAP_FMAC4 soap_get_ns1__studyStatus(struct soap *soap, enum ns1__studyStatus *p,
                                                                       const char *tag, const char *type) {
  if ((p = soap_in_ns1__studyStatus(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__icatExceptionType(struct soap *soap, enum ns1__icatExceptionType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__icatExceptionType
  *a = SOAP_DEFAULT_ns1__icatExceptionType;
#else
  *a = (enum ns1__icatExceptionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__icatExceptionType[] = {
    {(long)ns1__icatExceptionType__BAD_USCOREPARAMETER, "BAD_PARAMETER"},
    {(long)ns1__icatExceptionType__INTERNAL, "INTERNAL"},
    {(long)ns1__icatExceptionType__INSUFFICIENT_USCOREPRIVILEGES, "INSUFFICIENT_PRIVILEGES"},
    {(long)ns1__icatExceptionType__NO_USCORESUCH_USCOREOBJECT_USCOREFOUND, "NO_SUCH_OBJECT_FOUND"},
    {(long)ns1__icatExceptionType__OBJECT_USCOREALREADY_USCOREEXISTS, "OBJECT_ALREADY_EXISTS"},
    {(long)ns1__icatExceptionType__SESSION, "SESSION"},
    {(long)ns1__icatExceptionType__VALIDATION, "VALIDATION"},
    {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_ns1__icatExceptionType2s(struct soap *soap, enum ns1__icatExceptionType n) {
  const char *s = soap_code_str(soap_codes_ns1__icatExceptionType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__icatExceptionType(struct soap *soap, const char *tag, int id,
                                                          const enum ns1__icatExceptionType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__icatExceptionType), type) ||
      soap_send(soap, soap_ns1__icatExceptionType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__icatExceptionType(struct soap *soap, const char *s,
                                                          enum ns1__icatExceptionType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns1__icatExceptionType, s);
  if (map)
    *a = (enum ns1__icatExceptionType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns1__icatExceptionType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns1__icatExceptionType *SOAP_FMAC4 soap_in_ns1__icatExceptionType(struct soap *soap, const char *tag,
                                                                                  enum ns1__icatExceptionType *a,
                                                                                  const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return nullptr;
  a = (enum ns1__icatExceptionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__icatExceptionType,
                                                   sizeof(enum ns1__icatExceptionType), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns1__icatExceptionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (enum ns1__icatExceptionType *)soap_id_forward(soap, soap->href, (void *)a, 0,
                                                       SOAP_TYPE_ICat4_ns1__icatExceptionType, 0,
                                                       sizeof(enum ns1__icatExceptionType), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__icatExceptionType(struct soap *soap, const enum ns1__icatExceptionType *a,
                                                          const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__icatExceptionType);
  if (soap_out_ns1__icatExceptionType(soap, tag ? tag : "ns1:icatExceptionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__icatExceptionType *SOAP_FMAC4 soap_get_ns1__icatExceptionType(struct soap *soap,
                                                                                   enum ns1__icatExceptionType *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in_ns1__icatExceptionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
  *a = SOAP_DEFAULT_bool;
#else
  *a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] = {{(long)false, "false"}, {(long)true, "true"}, {0, nullptr}};

SOAP_FMAC3S const char *SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n) {
  (void)soap; /* appease -Wall -Werror */
  return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_bool), type) ||
      soap_send(soap, soap_bool2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_bool, s);
  if (map)
    *a = (bool)(map->code != 0);
  else {
    long n;
    if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
      return soap->error = SOAP_TYPE;
    *a = (bool)(n != 0);
  }
  return SOAP_OK;
}

SOAP_FMAC3 bool *SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean")) {
    soap->error = SOAP_TYPE;
    return nullptr;
  }
  a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_bool, sizeof(bool), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (bool *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_bool, 0, sizeof(bool), 0, nullptr);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_bool);
  if (soap_out_bool(soap, tag ? tag : "boolean", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 bool *SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type) {
  if ((p = soap_in_bool(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

void _ns1__login_credentials_entry::soap_default(struct soap *soap) {
  (void)soap; /* appease -Wall -Werror */
  this->_ns1__login_credentials_entry::key = nullptr;
  this->_ns1__login_credentials_entry::value = nullptr;
}

void _ns1__login_credentials_entry::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->_ns1__login_credentials_entry::key);
  soap_serialize_PointerTostd__string(soap, &this->_ns1__login_credentials_entry::value);
#endif
}

int _ns1__login_credentials_entry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out__ns1__login_credentials_entry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__login_credentials_entry(struct soap *soap, const char *tag, int id,
                                                                 const _ns1__login_credentials_entry *a,
                                                                 const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4__ns1__login_credentials_entry),
                             type))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "key", -1, &(a->_ns1__login_credentials_entry::key), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "value", -1, &(a->_ns1__login_credentials_entry::value), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *_ns1__login_credentials_entry::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in__ns1__login_credentials_entry(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__login_credentials_entry *SOAP_FMAC4 soap_in__ns1__login_credentials_entry(
    struct soap *soap, const char *tag, _ns1__login_credentials_entry *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (_ns1__login_credentials_entry *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4__ns1__login_credentials_entry, sizeof(_ns1__login_credentials_entry),
      soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4__ns1__login_credentials_entry) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_ns1__login_credentials_entry *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag_key1 = 1;
  size_t soap_flag_value1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "key", &(a->_ns1__login_credentials_entry::key), "xsd:string")) {
          soap_flag_key1--;
          continue;
        }
      if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "value", &(a->_ns1__login_credentials_entry::value), "xsd:string")) {
          soap_flag_value1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (_ns1__login_credentials_entry *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4__ns1__login_credentials_entry, 0,
        sizeof(_ns1__login_credentials_entry), 0, soap_copy__ns1__login_credentials_entry);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int _ns1__login_credentials_entry::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4__ns1__login_credentials_entry);
  if (this->soap_out(soap, tag ? tag : "ns1:login-credentials-entry", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *_ns1__login_credentials_entry::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get__ns1__login_credentials_entry(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__login_credentials_entry *SOAP_FMAC4 soap_get__ns1__login_credentials_entry(
    struct soap *soap, _ns1__login_credentials_entry *p, const char *tag, const char *type) {
  if ((p = soap_in__ns1__login_credentials_entry(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 _ns1__login_credentials_entry *SOAP_FMAC2 soap_instantiate__ns1__login_credentials_entry(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__login_credentials_entry(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4__ns1__login_credentials_entry, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(_ns1__login_credentials_entry);
    if (size)
      *size = sizeof(_ns1__login_credentials_entry);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(_ns1__login_credentials_entry, n);
    if (size)
      *size = n * sizeof(_ns1__login_credentials_entry);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (_ns1__login_credentials_entry *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__login_credentials_entry(struct soap *soap, int st, int tt, void *p,
                                                                   size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__login_credentials_entry %p -> %p\n", q, p));
  *(_ns1__login_credentials_entry *)p = *(_ns1__login_credentials_entry *)q;
}

void _ns1__login_credentials::soap_default(struct soap *soap) {
  (void)soap; /* appease -Wall -Werror */
  this->_ns1__login_credentials::entry = nullptr;
}

void _ns1__login_credentials::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(soap,
                                                                             &this->_ns1__login_credentials::entry);
#endif
}

int _ns1__login_credentials::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out__ns1__login_credentials(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__login_credentials(struct soap *soap, const char *tag, int id,
                                                           const _ns1__login_credentials *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4__ns1__login_credentials), type))
    return soap->error;
  if (soap_out_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(soap, "entry", -1,
                                                                           &(a->_ns1__login_credentials::entry), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *_ns1__login_credentials::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in__ns1__login_credentials(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__login_credentials *SOAP_FMAC4 soap_in__ns1__login_credentials(struct soap *soap, const char *tag,
                                                                               _ns1__login_credentials *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (_ns1__login_credentials *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4__ns1__login_credentials,
                                                     sizeof(_ns1__login_credentials), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4__ns1__login_credentials) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_ns1__login_credentials *)a->soap_in(soap, tag, type);
    }
  }
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(
                soap, "entry", &(a->_ns1__login_credentials::entry), ""))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (_ns1__login_credentials *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4__ns1__login_credentials, 0, sizeof(_ns1__login_credentials), 0,
        soap_copy__ns1__login_credentials);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int _ns1__login_credentials::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4__ns1__login_credentials);
  if (this->soap_out(soap, tag ? tag : "ns1:login-credentials", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *_ns1__login_credentials::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get__ns1__login_credentials(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__login_credentials *SOAP_FMAC4 soap_get__ns1__login_credentials(struct soap *soap,
                                                                                _ns1__login_credentials *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in__ns1__login_credentials(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 _ns1__login_credentials *SOAP_FMAC2 soap_instantiate__ns1__login_credentials(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__login_credentials(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4__ns1__login_credentials, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(_ns1__login_credentials);
    if (size)
      *size = sizeof(_ns1__login_credentials);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(_ns1__login_credentials, n);
    if (size)
      *size = n * sizeof(_ns1__login_credentials);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (_ns1__login_credentials *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__login_credentials(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__login_credentials %p -> %p\n", q, p));
  *(_ns1__login_credentials *)p = *(_ns1__login_credentials *)q;
}

void ns1__accessType_::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_ns1__accessType(soap, &this->ns1__accessType_::__item);
}

void ns1__accessType_::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__accessType_::__item, SOAP_TYPE_ICat4_ns1__accessType);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__accessType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__accessType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__accessType_(struct soap *soap, const char *tag, int id,
                                                    const ns1__accessType_ *a, const char *type) {
  return soap_out_ns1__accessType(soap, tag, id, &(a->ns1__accessType_::__item), "ns1:accessType");
}

void *ns1__accessType_::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__accessType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__accessType_ *SOAP_FMAC4 soap_in_ns1__accessType_(struct soap *soap, const char *tag,
                                                                 ns1__accessType_ *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__accessType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__accessType_,
                                                    sizeof(ns1__accessType_), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__accessType_)
      return (ns1__accessType_ *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_ns1__accessType(soap, tag, &(a->ns1__accessType_::__item), "ns1:accessType"))
    return nullptr;
  return a;
}

int ns1__accessType_::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__accessType_);
  if (this->soap_out(soap, tag ? tag : "ns1:accessType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__accessType_::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__accessType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__accessType_ *SOAP_FMAC4 soap_get_ns1__accessType_(struct soap *soap, ns1__accessType_ *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__accessType_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__accessType_ *SOAP_FMAC2 soap_instantiate_ns1__accessType_(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__accessType_(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__accessType_, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__accessType_);
    if (size)
      *size = sizeof(ns1__accessType_);
    ((ns1__accessType_ *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__accessType_, n);
    if (size)
      *size = n * sizeof(ns1__accessType_);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__accessType_ *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__accessType_ *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__accessType_(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__accessType_ %p -> %p\n", q, p));
  *(ns1__accessType_ *)p = *(ns1__accessType_ *)q;
}

void ns1__relType_::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_ns1__relType(soap, &this->ns1__relType_::__item);
}

void ns1__relType_::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__relType_::__item, SOAP_TYPE_ICat4_ns1__relType);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__relType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__relType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relType_(struct soap *soap, const char *tag, int id, const ns1__relType_ *a,
                                                 const char *type) {
  return soap_out_ns1__relType(soap, tag, id, &(a->ns1__relType_::__item), "ns1:relType");
}

void *ns1__relType_::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__relType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__relType_ *SOAP_FMAC4 soap_in_ns1__relType_(struct soap *soap, const char *tag, ns1__relType_ *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__relType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__relType_,
                                                 sizeof(ns1__relType_), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__relType_)
      return (ns1__relType_ *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_ns1__relType(soap, tag, &(a->ns1__relType_::__item), "ns1:relType"))
    return nullptr;
  return a;
}

int ns1__relType_::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__relType_);
  if (this->soap_out(soap, tag ? tag : "ns1:relType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__relType_::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__relType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__relType_ *SOAP_FMAC4 soap_get_ns1__relType_(struct soap *soap, ns1__relType_ *p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_ns1__relType_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__relType_ *SOAP_FMAC2 soap_instantiate_ns1__relType_(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__relType_(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__relType_, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__relType_);
    if (size)
      *size = sizeof(ns1__relType_);
    ((ns1__relType_ *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__relType_, n);
    if (size)
      *size = n * sizeof(ns1__relType_);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__relType_ *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__relType_ *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__relType_(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__relType_ %p -> %p\n", q, p));
  *(ns1__relType_ *)p = *(ns1__relType_ *)q;
}

void ns1__parameterValueType_::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_ns1__parameterValueType(soap, &this->ns1__parameterValueType_::__item);
}

void ns1__parameterValueType_::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__parameterValueType_::__item, SOAP_TYPE_ICat4_ns1__parameterValueType);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__parameterValueType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__parameterValueType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameterValueType_(struct soap *soap, const char *tag, int id,
                                                            const ns1__parameterValueType_ *a, const char *type) {
  return soap_out_ns1__parameterValueType(soap, tag, id, &(a->ns1__parameterValueType_::__item),
                                          "ns1:parameterValueType");
}

void *ns1__parameterValueType_::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__parameterValueType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__parameterValueType_ *SOAP_FMAC4 soap_in_ns1__parameterValueType_(struct soap *soap, const char *tag,
                                                                                 ns1__parameterValueType_ *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__parameterValueType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__parameterValueType_,
                                                            sizeof(ns1__parameterValueType_), soap->type,
                                                            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__parameterValueType_)
      return (ns1__parameterValueType_ *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_ns1__parameterValueType(soap, tag, &(a->ns1__parameterValueType_::__item), "ns1:parameterValueType"))
    return nullptr;
  return a;
}

int ns1__parameterValueType_::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__parameterValueType_);
  if (this->soap_out(soap, tag ? tag : "ns1:parameterValueType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__parameterValueType_::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__parameterValueType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__parameterValueType_ *SOAP_FMAC4 soap_get_ns1__parameterValueType_(struct soap *soap,
                                                                                  ns1__parameterValueType_ *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__parameterValueType_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__parameterValueType_ *SOAP_FMAC2 soap_instantiate_ns1__parameterValueType_(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__parameterValueType_(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__parameterValueType_, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__parameterValueType_);
    if (size)
      *size = sizeof(ns1__parameterValueType_);
    ((ns1__parameterValueType_ *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameterValueType_, n);
    if (size)
      *size = n * sizeof(ns1__parameterValueType_);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__parameterValueType_ *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__parameterValueType_ *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__parameterValueType_(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__parameterValueType_ %p -> %p\n", q, p));
  *(ns1__parameterValueType_ *)p = *(ns1__parameterValueType_ *)q;
}

void ns1__studyStatus_::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_ns1__studyStatus(soap, &this->ns1__studyStatus_::__item);
}

void ns1__studyStatus_::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__studyStatus_::__item, SOAP_TYPE_ICat4_ns1__studyStatus);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__studyStatus_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__studyStatus_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__studyStatus_(struct soap *soap, const char *tag, int id,
                                                     const ns1__studyStatus_ *a, const char *type) {
  return soap_out_ns1__studyStatus(soap, tag, id, &(a->ns1__studyStatus_::__item), "ns1:studyStatus");
}

void *ns1__studyStatus_::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__studyStatus_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__studyStatus_ *SOAP_FMAC4 soap_in_ns1__studyStatus_(struct soap *soap, const char *tag,
                                                                   ns1__studyStatus_ *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__studyStatus_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__studyStatus_,
                                                     sizeof(ns1__studyStatus_), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__studyStatus_)
      return (ns1__studyStatus_ *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_ns1__studyStatus(soap, tag, &(a->ns1__studyStatus_::__item), "ns1:studyStatus"))
    return nullptr;
  return a;
}

int ns1__studyStatus_::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__studyStatus_);
  if (this->soap_out(soap, tag ? tag : "ns1:studyStatus", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__studyStatus_::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__studyStatus_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__studyStatus_ *SOAP_FMAC4 soap_get_ns1__studyStatus_(struct soap *soap, ns1__studyStatus_ *p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_ns1__studyStatus_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__studyStatus_ *SOAP_FMAC2 soap_instantiate_ns1__studyStatus_(struct soap *soap, int n, const char *type,
                                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__studyStatus_(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__studyStatus_, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__studyStatus_);
    if (size)
      *size = sizeof(ns1__studyStatus_);
    ((ns1__studyStatus_ *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__studyStatus_, n);
    if (size)
      *size = n * sizeof(ns1__studyStatus_);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__studyStatus_ *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__studyStatus_ *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__studyStatus_(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__studyStatus_ %p -> %p\n", q, p));
  *(ns1__studyStatus_ *)p = *(ns1__studyStatus_ *)q;
}

void ns1__icatExceptionType_::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_ns1__icatExceptionType(soap, &this->ns1__icatExceptionType_::__item);
}

void ns1__icatExceptionType_::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__icatExceptionType_::__item, SOAP_TYPE_ICat4_ns1__icatExceptionType);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__icatExceptionType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__icatExceptionType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__icatExceptionType_(struct soap *soap, const char *tag, int id,
                                                           const ns1__icatExceptionType_ *a, const char *type) {
  return soap_out_ns1__icatExceptionType(soap, tag, id, &(a->ns1__icatExceptionType_::__item), "ns1:icatExceptionType");
}

void *ns1__icatExceptionType_::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__icatExceptionType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__icatExceptionType_ *SOAP_FMAC4 soap_in_ns1__icatExceptionType_(struct soap *soap, const char *tag,
                                                                               ns1__icatExceptionType_ *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__icatExceptionType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__icatExceptionType_,
                                                           sizeof(ns1__icatExceptionType_), soap->type,
                                                           soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__icatExceptionType_)
      return (ns1__icatExceptionType_ *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_ns1__icatExceptionType(soap, tag, &(a->ns1__icatExceptionType_::__item), "ns1:icatExceptionType"))
    return nullptr;
  return a;
}

int ns1__icatExceptionType_::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__icatExceptionType_);
  if (this->soap_out(soap, tag ? tag : "ns1:icatExceptionType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__icatExceptionType_::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__icatExceptionType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__icatExceptionType_ *SOAP_FMAC4 soap_get_ns1__icatExceptionType_(struct soap *soap,
                                                                                ns1__icatExceptionType_ *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in_ns1__icatExceptionType_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__icatExceptionType_ *SOAP_FMAC2 soap_instantiate_ns1__icatExceptionType_(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__icatExceptionType_(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__icatExceptionType_, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__icatExceptionType_);
    if (size)
      *size = sizeof(ns1__icatExceptionType_);
    ((ns1__icatExceptionType_ *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__icatExceptionType_, n);
    if (size)
      *size = n * sizeof(ns1__icatExceptionType_);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__icatExceptionType_ *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__icatExceptionType_ *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__icatExceptionType_(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__icatExceptionType_ %p -> %p\n", q, p));
  *(ns1__icatExceptionType_ *)p = *(ns1__icatExceptionType_ *)q;
}

void ns1__getRemainingMinutesResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_double(soap, &this->ns1__getRemainingMinutesResponse::return_);
}

void ns1__getRemainingMinutesResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__getRemainingMinutesResponse::return_, SOAP_TYPE_ICat4_double);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getRemainingMinutesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getRemainingMinutesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRemainingMinutesResponse(struct soap *soap, const char *tag, int id,
                                                                    const ns1__getRemainingMinutesResponse *a,
                                                                    const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse),
                             "ns1:getRemainingMinutesResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_double(soap, "return", -1, &(a->ns1__getRemainingMinutesResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getRemainingMinutesResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getRemainingMinutesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRemainingMinutesResponse *SOAP_FMAC4 soap_in_ns1__getRemainingMinutesResponse(
    struct soap *soap, const char *tag, ns1__getRemainingMinutesResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getRemainingMinutesResponse *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse, sizeof(ns1__getRemainingMinutesResponse),
      soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getRemainingMinutesResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_double(soap, "return", &(a->ns1__getRemainingMinutesResponse::return_), "xsd:double")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getRemainingMinutesResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse, 0,
        sizeof(ns1__getRemainingMinutesResponse), 0, soap_copy_ns1__getRemainingMinutesResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__getRemainingMinutesResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getRemainingMinutesResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getRemainingMinutesResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getRemainingMinutesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRemainingMinutesResponse *SOAP_FMAC4 soap_get_ns1__getRemainingMinutesResponse(
    struct soap *soap, ns1__getRemainingMinutesResponse *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__getRemainingMinutesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getRemainingMinutesResponse *SOAP_FMAC2 soap_instantiate_ns1__getRemainingMinutesResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRemainingMinutesResponse(%d, %s, %s)\n", n,
                            type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getRemainingMinutesResponse);
    if (size)
      *size = sizeof(ns1__getRemainingMinutesResponse);
    ((ns1__getRemainingMinutesResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getRemainingMinutesResponse, n);
    if (size)
      *size = n * sizeof(ns1__getRemainingMinutesResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getRemainingMinutesResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getRemainingMinutesResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRemainingMinutesResponse(struct soap *soap, int st, int tt, void *p,
                                                                      size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRemainingMinutesResponse %p -> %p\n", q, p));
  *(ns1__getRemainingMinutesResponse *)p = *(ns1__getRemainingMinutesResponse *)q;
}

void ns1__getRemainingMinutes::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getRemainingMinutes::sessionId = nullptr;
}

void ns1__getRemainingMinutes::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getRemainingMinutes::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getRemainingMinutes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getRemainingMinutes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRemainingMinutes(struct soap *soap, const char *tag, int id,
                                                            const ns1__getRemainingMinutes *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getRemainingMinutes),
                             "ns1:getRemainingMinutes"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getRemainingMinutes::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getRemainingMinutes::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getRemainingMinutes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRemainingMinutes *SOAP_FMAC4 soap_in_ns1__getRemainingMinutes(struct soap *soap, const char *tag,
                                                                                 ns1__getRemainingMinutes *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getRemainingMinutes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getRemainingMinutes,
                                                      sizeof(ns1__getRemainingMinutes), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getRemainingMinutes) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getRemainingMinutes *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getRemainingMinutes::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getRemainingMinutes *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getRemainingMinutes, 0, sizeof(ns1__getRemainingMinutes),
        0, soap_copy_ns1__getRemainingMinutes);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getRemainingMinutes::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getRemainingMinutes);
  if (this->soap_out(soap, tag ? tag : "ns1:getRemainingMinutes", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getRemainingMinutes::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getRemainingMinutes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRemainingMinutes *SOAP_FMAC4 soap_get_ns1__getRemainingMinutes(struct soap *soap,
                                                                                  ns1__getRemainingMinutes *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__getRemainingMinutes(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getRemainingMinutes *SOAP_FMAC2 soap_instantiate_ns1__getRemainingMinutes(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRemainingMinutes(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getRemainingMinutes, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getRemainingMinutes);
    if (size)
      *size = sizeof(ns1__getRemainingMinutes);
    ((ns1__getRemainingMinutes *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getRemainingMinutes, n);
    if (size)
      *size = n * sizeof(ns1__getRemainingMinutes);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getRemainingMinutes *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getRemainingMinutes *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRemainingMinutes(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRemainingMinutes %p -> %p\n", q, p));
  *(ns1__getRemainingMinutes *)p = *(ns1__getRemainingMinutes *)q;
}

void ns1__logoutResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__logoutResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id,
                                                       const ns1__logoutResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:logoutResponse");
}

void *ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logoutResponse *SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag,
                                                                       ns1__logoutResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__logoutResponse,
                                                       sizeof(ns1__logoutResponse), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__logoutResponse)
      return (ns1__logoutResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__logoutResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:logoutResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logoutResponse *SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, ns1__logoutResponse *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__logoutResponse *SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logoutResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__logoutResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__logoutResponse);
    if (size)
      *size = sizeof(ns1__logoutResponse);
    ((ns1__logoutResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__logoutResponse, n);
    if (size)
      *size = n * sizeof(ns1__logoutResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__logoutResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__logoutResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logoutResponse %p -> %p\n", q, p));
  *(ns1__logoutResponse *)p = *(ns1__logoutResponse *)q;
}

void ns1__logout::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__logout::sessionId = nullptr;
}

void ns1__logout::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__logout::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const ns1__logout *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__logout), "ns1:logout"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__logout::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logout *SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, ns1__logout *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__logout, sizeof(ns1__logout),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__logout) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__logout *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__logout::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__logout *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__logout, 0,
                                       sizeof(ns1__logout), 0, soap_copy_ns1__logout);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__logout::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__logout);
  if (this->soap_out(soap, tag ? tag : "ns1:logout", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logout *SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, ns1__logout *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__logout(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__logout *SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logout(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__logout, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__logout);
    if (size)
      *size = sizeof(ns1__logout);
    ((ns1__logout *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__logout, n);
    if (size)
      *size = n * sizeof(ns1__logout);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__logout *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__logout *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logout %p -> %p\n", q, p));
  *(ns1__logout *)p = *(ns1__logout *)q;
}

void ns1__searchResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__searchResponse::return_);
}

void ns1__searchResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__searchResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__searchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__searchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchResponse(struct soap *soap, const char *tag, int id,
                                                       const ns1__searchResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__searchResponse),
                             "ns1:searchResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfPointerToxsd__anyType(soap, "return", -1, &(a->ns1__searchResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__searchResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__searchResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchResponse *SOAP_FMAC4 soap_in_ns1__searchResponse(struct soap *soap, const char *tag,
                                                                       ns1__searchResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__searchResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__searchResponse,
                                                 sizeof(ns1__searchResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__searchResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__searchResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerToxsd__anyType(soap, "return", &(a->ns1__searchResponse::return_),
                                                               "xsd:anyType"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__searchResponse *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__searchResponse, 0,
                                               sizeof(ns1__searchResponse), 0, soap_copy_ns1__searchResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__searchResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__searchResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:searchResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__searchResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__searchResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchResponse *SOAP_FMAC4 soap_get_ns1__searchResponse(struct soap *soap, ns1__searchResponse *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__searchResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__searchResponse *SOAP_FMAC2 soap_instantiate_ns1__searchResponse(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__searchResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__searchResponse);
    if (size)
      *size = sizeof(ns1__searchResponse);
    ((ns1__searchResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchResponse, n);
    if (size)
      *size = n * sizeof(ns1__searchResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__searchResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__searchResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchResponse %p -> %p\n", q, p));
  *(ns1__searchResponse *)p = *(ns1__searchResponse *)q;
}

void ns1__search::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__search::sessionId = nullptr;
  this->ns1__search::query = nullptr;
}

void ns1__search::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__search::sessionId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__search::query);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__search::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__search(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search(struct soap *soap, const char *tag, int id, const ns1__search *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__search), "ns1:search"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__search::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "query", -1, &(a->ns1__search::query), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__search::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__search(soap, tag, this, type);
}

SOAP_FMAC3 ns1__search *SOAP_FMAC4 soap_in_ns1__search(struct soap *soap, const char *tag, ns1__search *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__search *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__search, sizeof(ns1__search),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__search) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__search *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_query1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__search::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "query", &(a->ns1__search::query), "xsd:string")) {
          soap_flag_query1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__search *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__search, 0,
                                       sizeof(ns1__search), 0, soap_copy_ns1__search);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__search::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__search);
  if (this->soap_out(soap, tag ? tag : "ns1:search", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__search::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__search(soap, this, tag, type);
}

SOAP_FMAC3 ns1__search *SOAP_FMAC4 soap_get_ns1__search(struct soap *soap, ns1__search *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__search(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__search *SOAP_FMAC2 soap_instantiate_ns1__search(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__search(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__search, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__search);
    if (size)
      *size = sizeof(ns1__search);
    ((ns1__search *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__search, n);
    if (size)
      *size = n * sizeof(ns1__search);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__search *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__search *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__search(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__search %p -> %p\n", q, p));
  *(ns1__search *)p = *(ns1__search *)q;
}

void ns1__isAccessAllowedResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_bool(soap, &this->ns1__isAccessAllowedResponse::return_);
}

void ns1__isAccessAllowedResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__isAccessAllowedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__isAccessAllowedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__isAccessAllowedResponse(struct soap *soap, const char *tag, int id,
                                                                const ns1__isAccessAllowedResponse *a,
                                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse),
                             "ns1:isAccessAllowedResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_bool(soap, "return", -1, &(a->ns1__isAccessAllowedResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__isAccessAllowedResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__isAccessAllowedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__isAccessAllowedResponse *SOAP_FMAC4 soap_in_ns1__isAccessAllowedResponse(
    struct soap *soap, const char *tag, ns1__isAccessAllowedResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__isAccessAllowedResponse *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse, sizeof(ns1__isAccessAllowedResponse), soap->type,
      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__isAccessAllowedResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "return", &(a->ns1__isAccessAllowedResponse::return_), "xsd:boolean")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__isAccessAllowedResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse, 0,
        sizeof(ns1__isAccessAllowedResponse), 0, soap_copy_ns1__isAccessAllowedResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__isAccessAllowedResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:isAccessAllowedResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__isAccessAllowedResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__isAccessAllowedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__isAccessAllowedResponse *SOAP_FMAC4 soap_get_ns1__isAccessAllowedResponse(
    struct soap *soap, ns1__isAccessAllowedResponse *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__isAccessAllowedResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__isAccessAllowedResponse *SOAP_FMAC2 soap_instantiate_ns1__isAccessAllowedResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__isAccessAllowedResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__isAccessAllowedResponse);
    if (size)
      *size = sizeof(ns1__isAccessAllowedResponse);
    ((ns1__isAccessAllowedResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__isAccessAllowedResponse, n);
    if (size)
      *size = n * sizeof(ns1__isAccessAllowedResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__isAccessAllowedResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__isAccessAllowedResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__isAccessAllowedResponse(struct soap *soap, int st, int tt, void *p,
                                                                  size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__isAccessAllowedResponse %p -> %p\n", q, p));
  *(ns1__isAccessAllowedResponse *)p = *(ns1__isAccessAllowedResponse *)q;
}

void ns1__isAccessAllowed::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__isAccessAllowed::sessionId = nullptr;
  this->ns1__isAccessAllowed::bean = nullptr;
  this->ns1__isAccessAllowed::accessType = nullptr;
}

void ns1__isAccessAllowed::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__isAccessAllowed::sessionId);
  soap_serialize_PointerTons1__entityBaseBean(soap, &this->ns1__isAccessAllowed::bean);
  soap_serialize_PointerTons1__accessType(soap, &this->ns1__isAccessAllowed::accessType);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__isAccessAllowed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__isAccessAllowed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__isAccessAllowed(struct soap *soap, const char *tag, int id,
                                                        const ns1__isAccessAllowed *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__isAccessAllowed),
                             "ns1:isAccessAllowed"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__isAccessAllowed::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTons1__entityBaseBean(soap, "bean", -1, &(a->ns1__isAccessAllowed::bean), ""))
    return soap->error;
  if (soap_out_PointerTons1__accessType(soap, "accessType", -1, &(a->ns1__isAccessAllowed::accessType), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__isAccessAllowed::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__isAccessAllowed(soap, tag, this, type);
}

SOAP_FMAC3 ns1__isAccessAllowed *SOAP_FMAC4 soap_in_ns1__isAccessAllowed(struct soap *soap, const char *tag,
                                                                         ns1__isAccessAllowed *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__isAccessAllowed *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__isAccessAllowed,
                                                  sizeof(ns1__isAccessAllowed), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__isAccessAllowed) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__isAccessAllowed *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_bean1 = 1;
  size_t soap_flag_accessType1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__isAccessAllowed::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_bean1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityBaseBean(soap, "bean", &(a->ns1__isAccessAllowed::bean),
                                                 "ns1:entityBaseBean")) {
          soap_flag_bean1--;
          continue;
        }
      if (soap_flag_accessType1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__accessType(soap, "accessType", &(a->ns1__isAccessAllowed::accessType),
                                             "ns1:accessType")) {
          soap_flag_accessType1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__isAccessAllowed *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__isAccessAllowed, 0,
                                                sizeof(ns1__isAccessAllowed), 0, soap_copy_ns1__isAccessAllowed);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__isAccessAllowed::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__isAccessAllowed);
  if (this->soap_out(soap, tag ? tag : "ns1:isAccessAllowed", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__isAccessAllowed::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__isAccessAllowed(soap, this, tag, type);
}

SOAP_FMAC3 ns1__isAccessAllowed *SOAP_FMAC4 soap_get_ns1__isAccessAllowed(struct soap *soap, ns1__isAccessAllowed *p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_ns1__isAccessAllowed(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__isAccessAllowed *SOAP_FMAC2 soap_instantiate_ns1__isAccessAllowed(struct soap *soap, int n,
                                                                                  const char *type,
                                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__isAccessAllowed(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__isAccessAllowed, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__isAccessAllowed);
    if (size)
      *size = sizeof(ns1__isAccessAllowed);
    ((ns1__isAccessAllowed *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__isAccessAllowed, n);
    if (size)
      *size = n * sizeof(ns1__isAccessAllowed);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__isAccessAllowed *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__isAccessAllowed *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__isAccessAllowed(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__isAccessAllowed %p -> %p\n", q, p));
  *(ns1__isAccessAllowed *)p = *(ns1__isAccessAllowed *)q;
}

void ns1__deleteResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__deleteResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__deleteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__deleteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteResponse(struct soap *soap, const char *tag, int id,
                                                       const ns1__deleteResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteResponse");
}

void *ns1__deleteResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__deleteResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteResponse *SOAP_FMAC4 soap_in_ns1__deleteResponse(struct soap *soap, const char *tag,
                                                                       ns1__deleteResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__deleteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__deleteResponse,
                                                       sizeof(ns1__deleteResponse), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__deleteResponse)
      return (ns1__deleteResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__deleteResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__deleteResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:deleteResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__deleteResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__deleteResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteResponse *SOAP_FMAC4 soap_get_ns1__deleteResponse(struct soap *soap, ns1__deleteResponse *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__deleteResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__deleteResponse *SOAP_FMAC2 soap_instantiate_ns1__deleteResponse(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__deleteResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__deleteResponse);
    if (size)
      *size = sizeof(ns1__deleteResponse);
    ((ns1__deleteResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteResponse, n);
    if (size)
      *size = n * sizeof(ns1__deleteResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__deleteResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__deleteResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteResponse %p -> %p\n", q, p));
  *(ns1__deleteResponse *)p = *(ns1__deleteResponse *)q;
}

void ns1__delete::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__delete::sessionId = nullptr;
  this->ns1__delete::bean = nullptr;
}

void ns1__delete::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__delete::sessionId);
  soap_serialize_PointerTons1__entityBaseBean(soap, &this->ns1__delete::bean);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__delete::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__delete(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delete(struct soap *soap, const char *tag, int id, const ns1__delete *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__delete), "ns1:delete"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__delete::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTons1__entityBaseBean(soap, "bean", -1, &(a->ns1__delete::bean), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__delete::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__delete(soap, tag, this, type);
}

SOAP_FMAC3 ns1__delete *SOAP_FMAC4 soap_in_ns1__delete(struct soap *soap, const char *tag, ns1__delete *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__delete *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__delete, sizeof(ns1__delete),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__delete) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__delete *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_bean1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__delete::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_bean1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityBaseBean(soap, "bean", &(a->ns1__delete::bean), "ns1:entityBaseBean")) {
          soap_flag_bean1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__delete *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__delete, 0,
                                       sizeof(ns1__delete), 0, soap_copy_ns1__delete);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__delete::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__delete);
  if (this->soap_out(soap, tag ? tag : "ns1:delete", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__delete::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__delete(soap, this, tag, type);
}

SOAP_FMAC3 ns1__delete *SOAP_FMAC4 soap_get_ns1__delete(struct soap *soap, ns1__delete *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__delete(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__delete *SOAP_FMAC2 soap_instantiate_ns1__delete(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delete(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__delete, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__delete);
    if (size)
      *size = sizeof(ns1__delete);
    ((ns1__delete *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__delete, n);
    if (size)
      *size = n * sizeof(ns1__delete);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__delete *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__delete *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delete(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__delete %p -> %p\n", q, p));
  *(ns1__delete *)p = *(ns1__delete *)q;
}

void ns1__searchTextResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__searchTextResponse::return_);
}

void ns1__searchTextResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->ns1__searchTextResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__searchTextResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__searchTextResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchTextResponse(struct soap *soap, const char *tag, int id,
                                                           const ns1__searchTextResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__searchTextResponse),
                             "ns1:searchTextResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfPointerToxsd__anyType(soap, "return", -1, &(a->ns1__searchTextResponse::return_),
                                                          ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__searchTextResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__searchTextResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchTextResponse *SOAP_FMAC4 soap_in_ns1__searchTextResponse(struct soap *soap, const char *tag,
                                                                               ns1__searchTextResponse *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__searchTextResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__searchTextResponse,
                                                     sizeof(ns1__searchTextResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__searchTextResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__searchTextResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerToxsd__anyType(soap, "return", &(a->ns1__searchTextResponse::return_),
                                                               "xsd:anyType"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__searchTextResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__searchTextResponse, 0, sizeof(ns1__searchTextResponse), 0,
        soap_copy_ns1__searchTextResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__searchTextResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__searchTextResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:searchTextResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__searchTextResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__searchTextResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchTextResponse *SOAP_FMAC4 soap_get_ns1__searchTextResponse(struct soap *soap,
                                                                                ns1__searchTextResponse *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in_ns1__searchTextResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__searchTextResponse *SOAP_FMAC2 soap_instantiate_ns1__searchTextResponse(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchTextResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__searchTextResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__searchTextResponse);
    if (size)
      *size = sizeof(ns1__searchTextResponse);
    ((ns1__searchTextResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchTextResponse, n);
    if (size)
      *size = n * sizeof(ns1__searchTextResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__searchTextResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__searchTextResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchTextResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchTextResponse %p -> %p\n", q, p));
  *(ns1__searchTextResponse *)p = *(ns1__searchTextResponse *)q;
}

void ns1__searchText::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__searchText::sessionId = nullptr;
  this->ns1__searchText::query = nullptr;
  soap_default_int(soap, &this->ns1__searchText::maxCount);
  this->ns1__searchText::entityName = nullptr;
}

void ns1__searchText::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__searchText::sessionId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__searchText::query);
  soap_embedded(soap, &this->ns1__searchText::maxCount, SOAP_TYPE_ICat4_int);
  soap_serialize_PointerTostd__string(soap, &this->ns1__searchText::entityName);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__searchText::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__searchText(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchText(struct soap *soap, const char *tag, int id, const ns1__searchText *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__searchText),
                             "ns1:searchText"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__searchText::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "query", -1, &(a->ns1__searchText::query), ""))
    return soap->error;
  if (soap_out_int(soap, "maxCount", -1, &(a->ns1__searchText::maxCount), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "entityName", -1, &(a->ns1__searchText::entityName), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__searchText::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__searchText(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchText *SOAP_FMAC4 soap_in_ns1__searchText(struct soap *soap, const char *tag, ns1__searchText *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__searchText *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__searchText,
                                             sizeof(ns1__searchText), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__searchText) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__searchText *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_query1 = 1;
  size_t soap_flag_maxCount1 = 1;
  size_t soap_flag_entityName1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__searchText::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "query", &(a->ns1__searchText::query), "xsd:string")) {
          soap_flag_query1--;
          continue;
        }
      if (soap_flag_maxCount1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "maxCount", &(a->ns1__searchText::maxCount), "xsd:int")) {
          soap_flag_maxCount1--;
          continue;
        }
      if (soap_flag_entityName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "entityName", &(a->ns1__searchText::entityName), "xsd:string")) {
          soap_flag_entityName1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__searchText *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__searchText, 0,
                                           sizeof(ns1__searchText), 0, soap_copy_ns1__searchText);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxCount1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__searchText::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__searchText);
  if (this->soap_out(soap, tag ? tag : "ns1:searchText", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__searchText::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__searchText(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchText *SOAP_FMAC4 soap_get_ns1__searchText(struct soap *soap, ns1__searchText *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__searchText(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__searchText *SOAP_FMAC2 soap_instantiate_ns1__searchText(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchText(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__searchText, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__searchText);
    if (size)
      *size = sizeof(ns1__searchText);
    ((ns1__searchText *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchText, n);
    if (size)
      *size = n * sizeof(ns1__searchText);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__searchText *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__searchText *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchText(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchText %p -> %p\n", q, p));
  *(ns1__searchText *)p = *(ns1__searchText *)q;
}

void ns1__luceneCommitResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__luceneCommitResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneCommitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneCommitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneCommitResponse(struct soap *soap, const char *tag, int id,
                                                             const ns1__luceneCommitResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:luceneCommitResponse");
}

void *ns1__luceneCommitResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneCommitResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneCommitResponse *SOAP_FMAC4 soap_in_ns1__luceneCommitResponse(struct soap *soap, const char *tag,
                                                                                   ns1__luceneCommitResponse *a,
                                                                                   const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__luceneCommitResponse *)soap_class_id_enter(
            soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneCommitResponse, sizeof(ns1__luceneCommitResponse), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneCommitResponse)
      return (ns1__luceneCommitResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__luceneCommitResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneCommitResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneCommitResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneCommitResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneCommitResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneCommitResponse *SOAP_FMAC4 soap_get_ns1__luceneCommitResponse(struct soap *soap,
                                                                                    ns1__luceneCommitResponse *p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneCommitResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneCommitResponse *SOAP_FMAC2 soap_instantiate_ns1__luceneCommitResponse(struct soap *soap, int n,
                                                                                            const char *type,
                                                                                            const char *arrayType,
                                                                                            size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneCommitResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneCommitResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneCommitResponse);
    if (size)
      *size = sizeof(ns1__luceneCommitResponse);
    ((ns1__luceneCommitResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneCommitResponse, n);
    if (size)
      *size = n * sizeof(ns1__luceneCommitResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneCommitResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneCommitResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneCommitResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                               const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneCommitResponse %p -> %p\n", q, p));
  *(ns1__luceneCommitResponse *)p = *(ns1__luceneCommitResponse *)q;
}

void ns1__luceneCommit::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__luceneCommit::sessionId = nullptr;
}

void ns1__luceneCommit::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneCommit::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneCommit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneCommit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneCommit(struct soap *soap, const char *tag, int id,
                                                     const ns1__luceneCommit *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneCommit),
                             "ns1:luceneCommit"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__luceneCommit::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneCommit::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneCommit(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneCommit *SOAP_FMAC4 soap_in_ns1__luceneCommit(struct soap *soap, const char *tag,
                                                                   ns1__luceneCommit *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneCommit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneCommit,
                                               sizeof(ns1__luceneCommit), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneCommit) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneCommit *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__luceneCommit::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneCommit *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneCommit, 0,
                                             sizeof(ns1__luceneCommit), 0, soap_copy_ns1__luceneCommit);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__luceneCommit::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneCommit);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneCommit", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneCommit::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneCommit(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneCommit *SOAP_FMAC4 soap_get_ns1__luceneCommit(struct soap *soap, ns1__luceneCommit *p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneCommit(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneCommit *SOAP_FMAC2 soap_instantiate_ns1__luceneCommit(struct soap *soap, int n, const char *type,
                                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneCommit(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneCommit, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneCommit);
    if (size)
      *size = sizeof(ns1__luceneCommit);
    ((ns1__luceneCommit *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneCommit, n);
    if (size)
      *size = n * sizeof(ns1__luceneCommit);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneCommit *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneCommit *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneCommit(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneCommit %p -> %p\n", q, p));
  *(ns1__luceneCommit *)p = *(ns1__luceneCommit *)q;
}

void ns1__entityField::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__entityField::comment = nullptr;
  this->ns1__entityField::name = nullptr;
  soap_default_bool(soap, &this->ns1__entityField::notNullable);
  this->ns1__entityField::relType = nullptr;
  this->ns1__entityField::stringLength = nullptr;
  this->ns1__entityField::type = nullptr;
}

void ns1__entityField::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityField::comment);
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityField::name);
  soap_serialize_PointerTons1__relType(soap, &this->ns1__entityField::relType);
  soap_serialize_PointerToint(soap, &this->ns1__entityField::stringLength);
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityField::type);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__entityField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__entityField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityField(struct soap *soap, const char *tag, int id,
                                                    const ns1__entityField *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__entityField),
                             "ns1:entityField"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "comment", -1, &(a->ns1__entityField::comment), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__entityField::name), ""))
    return soap->error;
  if (soap_out_bool(soap, "notNullable", -1, &(a->ns1__entityField::notNullable), ""))
    return soap->error;
  if (soap_out_PointerTons1__relType(soap, "relType", -1, &(a->ns1__entityField::relType), ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "stringLength", -1, &(a->ns1__entityField::stringLength), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "type", -1, &(a->ns1__entityField::type), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__entityField::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__entityField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__entityField *SOAP_FMAC4 soap_in_ns1__entityField(struct soap *soap, const char *tag,
                                                                 ns1__entityField *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__entityField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__entityField,
                                              sizeof(ns1__entityField), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__entityField) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__entityField *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_comment1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_notNullable1 = 1;
  size_t soap_flag_relType1 = 1;
  size_t soap_flag_stringLength1 = 1;
  size_t soap_flag_type1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "comment", &(a->ns1__entityField::comment), "xsd:string")) {
          soap_flag_comment1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__entityField::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_notNullable1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "notNullable", &(a->ns1__entityField::notNullable), "xsd:boolean")) {
          soap_flag_notNullable1--;
          continue;
        }
      if (soap_flag_relType1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__relType(soap, "relType", &(a->ns1__entityField::relType), "ns1:relType")) {
          soap_flag_relType1--;
          continue;
        }
      if (soap_flag_stringLength1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "stringLength", &(a->ns1__entityField::stringLength), "xsd:int")) {
          soap_flag_stringLength1--;
          continue;
        }
      if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "type", &(a->ns1__entityField::type), "xsd:string")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__entityField *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__entityField, 0,
                                            sizeof(ns1__entityField), 0, soap_copy_ns1__entityField);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_notNullable1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__entityField::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__entityField);
  if (this->soap_out(soap, tag ? tag : "ns1:entityField", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__entityField::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__entityField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__entityField *SOAP_FMAC4 soap_get_ns1__entityField(struct soap *soap, ns1__entityField *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__entityField(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__entityField *SOAP_FMAC2 soap_instantiate_ns1__entityField(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__entityField(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__entityField, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__entityField);
    if (size)
      *size = sizeof(ns1__entityField);
    ((ns1__entityField *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityField, n);
    if (size)
      *size = n * sizeof(ns1__entityField);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__entityField *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__entityField *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__entityField(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__entityField %p -> %p\n", q, p));
  *(ns1__entityField *)p = *(ns1__entityField *)q;
}

void ns1__constraint::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__constraint::fieldNames);
}

void ns1__constraint::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__constraint::fieldNames);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__constraint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__constraint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__constraint(struct soap *soap, const char *tag, int id, const ns1__constraint *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__constraint),
                             "ns1:constraint"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfstd__string(soap, "fieldNames", -1, &(a->ns1__constraint::fieldNames), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__constraint::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__constraint(soap, tag, this, type);
}

SOAP_FMAC3 ns1__constraint *SOAP_FMAC4 soap_in_ns1__constraint(struct soap *soap, const char *tag, ns1__constraint *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__constraint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__constraint,
                                             sizeof(ns1__constraint), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__constraint) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__constraint *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "fieldNames", &(a->ns1__constraint::fieldNames),
                                                     "xsd:string"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__constraint *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__constraint, 0,
                                           sizeof(ns1__constraint), 0, soap_copy_ns1__constraint);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__constraint::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__constraint);
  if (this->soap_out(soap, tag ? tag : "ns1:constraint", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__constraint::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__constraint(soap, this, tag, type);
}

SOAP_FMAC3 ns1__constraint *SOAP_FMAC4 soap_get_ns1__constraint(struct soap *soap, ns1__constraint *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__constraint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__constraint *SOAP_FMAC2 soap_instantiate_ns1__constraint(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__constraint(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__constraint, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__constraint);
    if (size)
      *size = sizeof(ns1__constraint);
    ((ns1__constraint *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__constraint, n);
    if (size)
      *size = n * sizeof(ns1__constraint);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__constraint *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__constraint *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__constraint(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__constraint %p -> %p\n", q, p));
  *(ns1__constraint *)p = *(ns1__constraint *)q;
}

void ns1__entityInfo::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__entityInfo::classComment = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__constraint(soap, &this->ns1__entityInfo::constraints);
  soap_default_std__vectorTemplateOfPointerTons1__entityField(soap, &this->ns1__entityInfo::fields);
}

void ns1__entityInfo::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityInfo::classComment);
  soap_serialize_std__vectorTemplateOfPointerTons1__constraint(soap, &this->ns1__entityInfo::constraints);
  soap_serialize_std__vectorTemplateOfPointerTons1__entityField(soap, &this->ns1__entityInfo::fields);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__entityInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__entityInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityInfo(struct soap *soap, const char *tag, int id, const ns1__entityInfo *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__entityInfo),
                             "ns1:entityInfo"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "classComment", -1, &(a->ns1__entityInfo::classComment), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__constraint(soap, "constraints", -1,
                                                             &(a->ns1__entityInfo::constraints), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__entityField(soap, "fields", -1, &(a->ns1__entityInfo::fields), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__entityInfo::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__entityInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__entityInfo *SOAP_FMAC4 soap_in_ns1__entityInfo(struct soap *soap, const char *tag, ns1__entityInfo *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__entityInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__entityInfo,
                                             sizeof(ns1__entityInfo), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__entityInfo) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__entityInfo *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_classComment1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_classComment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "classComment", &(a->ns1__entityInfo::classComment), "xsd:string")) {
          soap_flag_classComment1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__constraint(soap, "constraints",
                                                                  &(a->ns1__entityInfo::constraints), "ns1:constraint"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__entityField(soap, "fields", &(a->ns1__entityInfo::fields),
                                                                   "ns1:entityField"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__entityInfo *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__entityInfo, 0,
                                           sizeof(ns1__entityInfo), 0, soap_copy_ns1__entityInfo);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__entityInfo::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__entityInfo);
  if (this->soap_out(soap, tag ? tag : "ns1:entityInfo", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__entityInfo::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__entityInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__entityInfo *SOAP_FMAC4 soap_get_ns1__entityInfo(struct soap *soap, ns1__entityInfo *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__entityInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__entityInfo *SOAP_FMAC2 soap_instantiate_ns1__entityInfo(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__entityInfo(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__entityInfo, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__entityInfo);
    if (size)
      *size = sizeof(ns1__entityInfo);
    ((ns1__entityInfo *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityInfo, n);
    if (size)
      *size = n * sizeof(ns1__entityInfo);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__entityInfo *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__entityInfo *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__entityInfo(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__entityInfo %p -> %p\n", q, p));
  *(ns1__entityInfo *)p = *(ns1__entityInfo *)q;
}

void ns1__getEntityInfoResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getEntityInfoResponse::return_ = nullptr;
}

void ns1__getEntityInfoResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__entityInfo(soap, &this->ns1__getEntityInfoResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getEntityInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getEntityInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityInfoResponse(struct soap *soap, const char *tag, int id,
                                                              const ns1__getEntityInfoResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse),
                             "ns1:getEntityInfoResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTons1__entityInfo(soap, "return", -1, &(a->ns1__getEntityInfoResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getEntityInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getEntityInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityInfoResponse *SOAP_FMAC4 soap_in_ns1__getEntityInfoResponse(struct soap *soap, const char *tag,
                                                                                     ns1__getEntityInfoResponse *a,
                                                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getEntityInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse,
                                                        sizeof(ns1__getEntityInfoResponse), soap->type,
                                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getEntityInfoResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getEntityInfoResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityInfo(soap, "return", &(a->ns1__getEntityInfoResponse::return_),
                                             "ns1:entityInfo")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getEntityInfoResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse, 0,
        sizeof(ns1__getEntityInfoResponse), 0, soap_copy_ns1__getEntityInfoResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getEntityInfoResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getEntityInfoResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getEntityInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getEntityInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityInfoResponse *SOAP_FMAC4 soap_get_ns1__getEntityInfoResponse(struct soap *soap,
                                                                                      ns1__getEntityInfoResponse *p,
                                                                                      const char *tag,
                                                                                      const char *type) {
  if ((p = soap_in_ns1__getEntityInfoResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getEntityInfoResponse *SOAP_FMAC2 soap_instantiate_ns1__getEntityInfoResponse(struct soap *soap, int n,
                                                                                              const char *type,
                                                                                              const char *arrayType,
                                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityInfoResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getEntityInfoResponse);
    if (size)
      *size = sizeof(ns1__getEntityInfoResponse);
    ((ns1__getEntityInfoResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityInfoResponse, n);
    if (size)
      *size = n * sizeof(ns1__getEntityInfoResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getEntityInfoResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getEntityInfoResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityInfoResponse %p -> %p\n", q, p));
  *(ns1__getEntityInfoResponse *)p = *(ns1__getEntityInfoResponse *)q;
}

void ns1__getEntityInfo::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getEntityInfo::beanName = nullptr;
}

void ns1__getEntityInfo::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getEntityInfo::beanName);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getEntityInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getEntityInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityInfo(struct soap *soap, const char *tag, int id,
                                                      const ns1__getEntityInfo *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getEntityInfo),
                             "ns1:getEntityInfo"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "beanName", -1, &(a->ns1__getEntityInfo::beanName), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getEntityInfo::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getEntityInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityInfo *SOAP_FMAC4 soap_in_ns1__getEntityInfo(struct soap *soap, const char *tag,
                                                                     ns1__getEntityInfo *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getEntityInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getEntityInfo,
                                                sizeof(ns1__getEntityInfo), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getEntityInfo) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getEntityInfo *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_beanName1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_beanName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "beanName", &(a->ns1__getEntityInfo::beanName), "xsd:string")) {
          soap_flag_beanName1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getEntityInfo *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getEntityInfo, 0,
                                              sizeof(ns1__getEntityInfo), 0, soap_copy_ns1__getEntityInfo);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getEntityInfo::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getEntityInfo);
  if (this->soap_out(soap, tag ? tag : "ns1:getEntityInfo", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getEntityInfo::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getEntityInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityInfo *SOAP_FMAC4 soap_get_ns1__getEntityInfo(struct soap *soap, ns1__getEntityInfo *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__getEntityInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getEntityInfo *SOAP_FMAC2 soap_instantiate_ns1__getEntityInfo(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityInfo(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getEntityInfo, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getEntityInfo);
    if (size)
      *size = sizeof(ns1__getEntityInfo);
    ((ns1__getEntityInfo *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityInfo, n);
    if (size)
      *size = n * sizeof(ns1__getEntityInfo);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getEntityInfo *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getEntityInfo *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityInfo(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityInfo %p -> %p\n", q, p));
  *(ns1__getEntityInfo *)p = *(ns1__getEntityInfo *)q;
}

void ns1__dummyResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__dummyResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dummyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dummyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dummyResponse(struct soap *soap, const char *tag, int id,
                                                      const ns1__dummyResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:dummyResponse");
}

void *ns1__dummyResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dummyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dummyResponse *SOAP_FMAC4 soap_in_ns1__dummyResponse(struct soap *soap, const char *tag,
                                                                     ns1__dummyResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__dummyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dummyResponse,
                                                      sizeof(ns1__dummyResponse), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dummyResponse)
      return (ns1__dummyResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__dummyResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dummyResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:dummyResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dummyResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dummyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dummyResponse *SOAP_FMAC4 soap_get_ns1__dummyResponse(struct soap *soap, ns1__dummyResponse *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__dummyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dummyResponse *SOAP_FMAC2 soap_instantiate_ns1__dummyResponse(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dummyResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dummyResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dummyResponse);
    if (size)
      *size = sizeof(ns1__dummyResponse);
    ((ns1__dummyResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dummyResponse, n);
    if (size)
      *size = n * sizeof(ns1__dummyResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dummyResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dummyResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dummyResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dummyResponse %p -> %p\n", q, p));
  *(ns1__dummyResponse *)p = *(ns1__dummyResponse *)q;
}

void ns1__publicStep::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__publicStep::field = nullptr;
  this->ns1__publicStep::origin = nullptr;
}

void ns1__publicStep::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__publicStep::field);
  soap_serialize_PointerTostd__string(soap, &this->ns1__publicStep::origin);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__publicStep::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__publicStep(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__publicStep(struct soap *soap, const char *tag, int id, const ns1__publicStep *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__publicStep),
                             "ns1:publicStep"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "field", -1, &(a->ns1__publicStep::field), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "origin", -1, &(a->ns1__publicStep::origin), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__publicStep::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__publicStep(soap, tag, this, type);
}

SOAP_FMAC3 ns1__publicStep *SOAP_FMAC4 soap_in_ns1__publicStep(struct soap *soap, const char *tag, ns1__publicStep *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__publicStep *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__publicStep,
                                             sizeof(ns1__publicStep), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__publicStep) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__publicStep *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_field1 = 1;
  size_t soap_flag_origin1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "field", &(a->ns1__publicStep::field), "xsd:string")) {
          soap_flag_field1--;
          continue;
        }
      if (soap_flag_origin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "origin", &(a->ns1__publicStep::origin), "xsd:string")) {
          soap_flag_origin1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__publicStep *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__publicStep, 0,
                                           sizeof(ns1__publicStep), 0, soap_copy_ns1__publicStep);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__publicStep::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__publicStep);
  if (this->soap_out(soap, tag ? tag : "ns1:publicStep", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__publicStep::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__publicStep(soap, this, tag, type);
}

SOAP_FMAC3 ns1__publicStep *SOAP_FMAC4 soap_get_ns1__publicStep(struct soap *soap, ns1__publicStep *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__publicStep(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__publicStep *SOAP_FMAC2 soap_instantiate_ns1__publicStep(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__publicStep(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__publicStep, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__publicStep);
    if (size)
      *size = sizeof(ns1__publicStep);
    ((ns1__publicStep *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publicStep, n);
    if (size)
      *size = n * sizeof(ns1__publicStep);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__publicStep *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__publicStep *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__publicStep(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__publicStep %p -> %p\n", q, p));
  *(ns1__publicStep *)p = *(ns1__publicStep *)q;
}

void ns1__log::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_LONG64(soap, &this->ns1__log::duration);
  this->ns1__log::entityId = nullptr;
  this->ns1__log::entityName = nullptr;
  this->ns1__log::operation = nullptr;
  this->ns1__log::query = nullptr;
}

void ns1__log::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__log::duration, SOAP_TYPE_ICat4_LONG64);
  soap_serialize_PointerToLONG64(soap, &this->ns1__log::entityId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__log::entityName);
  soap_serialize_PointerTostd__string(soap, &this->ns1__log::operation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__log::query);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__log::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__log(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__log(struct soap *soap, const char *tag, int id, const ns1__log *a,
                                            const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__log), "ns1:log"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_LONG64(soap, "duration", -1, &(a->ns1__log::duration), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "entityId", -1, &(a->ns1__log::entityId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "entityName", -1, &(a->ns1__log::entityName), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "operation", -1, &(a->ns1__log::operation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "query", -1, &(a->ns1__log::query), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__log::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__log(soap, tag, this, type);
}

SOAP_FMAC3 ns1__log *SOAP_FMAC4 soap_in_ns1__log(struct soap *soap, const char *tag, ns1__log *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__log *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__log, sizeof(ns1__log), soap->type,
                                      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__log) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__log *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_duration1 = 1;
  size_t soap_flag_entityId1 = 1;
  size_t soap_flag_entityName1 = 1;
  size_t soap_flag_operation1 = 1;
  size_t soap_flag_query1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "duration", &(a->ns1__log::duration), "xsd:long")) {
          soap_flag_duration1--;
          continue;
        }
      if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "entityId", &(a->ns1__log::entityId), "xsd:long")) {
          soap_flag_entityId1--;
          continue;
        }
      if (soap_flag_entityName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "entityName", &(a->ns1__log::entityName), "xsd:string")) {
          soap_flag_entityName1--;
          continue;
        }
      if (soap_flag_operation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "operation", &(a->ns1__log::operation), "xsd:string")) {
          soap_flag_operation1--;
          continue;
        }
      if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "query", &(a->ns1__log::query), "xsd:string")) {
          soap_flag_query1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__log *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__log, 0, sizeof(ns1__log), 0,
                                    soap_copy_ns1__log);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_duration1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__log::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__log);
  if (this->soap_out(soap, tag ? tag : "ns1:log", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__log::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__log(soap, this, tag, type);
}

SOAP_FMAC3 ns1__log *SOAP_FMAC4 soap_get_ns1__log(struct soap *soap, ns1__log *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__log(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__log *SOAP_FMAC2 soap_instantiate_ns1__log(struct soap *soap, int n, const char *type,
                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__log(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__log, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__log);
    if (size)
      *size = sizeof(ns1__log);
    ((ns1__log *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__log, n);
    if (size)
      *size = n * sizeof(ns1__log);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__log *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__log *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__log(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__log %p -> %p\n", q, p));
  *(ns1__log *)p = *(ns1__log *)q;
}

void ns1__relatedDatafile::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__relatedDatafile::destDatafile = nullptr;
  this->ns1__relatedDatafile::relation = nullptr;
  this->ns1__relatedDatafile::sourceDatafile = nullptr;
}

void ns1__relatedDatafile::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__datafile(soap, &this->ns1__relatedDatafile::destDatafile);
  soap_serialize_PointerTostd__string(soap, &this->ns1__relatedDatafile::relation);
  soap_serialize_PointerTons1__datafile(soap, &this->ns1__relatedDatafile::sourceDatafile);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__relatedDatafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__relatedDatafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relatedDatafile(struct soap *soap, const char *tag, int id,
                                                        const ns1__relatedDatafile *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__relatedDatafile),
                             "ns1:relatedDatafile"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafile(soap, "destDatafile", -1, &(a->ns1__relatedDatafile::destDatafile), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "relation", -1, &(a->ns1__relatedDatafile::relation), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafile(soap, "sourceDatafile", -1, &(a->ns1__relatedDatafile::sourceDatafile), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__relatedDatafile::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__relatedDatafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__relatedDatafile *SOAP_FMAC4 soap_in_ns1__relatedDatafile(struct soap *soap, const char *tag,
                                                                         ns1__relatedDatafile *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__relatedDatafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__relatedDatafile,
                                                  sizeof(ns1__relatedDatafile), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__relatedDatafile) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__relatedDatafile *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_destDatafile1 = 1;
  size_t soap_flag_relation1 = 1;
  size_t soap_flag_sourceDatafile1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_destDatafile1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafile(soap, "destDatafile", &(a->ns1__relatedDatafile::destDatafile),
                                           "ns1:datafile")) {
          soap_flag_destDatafile1--;
          continue;
        }
      if (soap_flag_relation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "relation", &(a->ns1__relatedDatafile::relation), "xsd:string")) {
          soap_flag_relation1--;
          continue;
        }
      if (soap_flag_sourceDatafile1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafile(soap, "sourceDatafile", &(a->ns1__relatedDatafile::sourceDatafile),
                                           "ns1:datafile")) {
          soap_flag_sourceDatafile1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__relatedDatafile *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__relatedDatafile, 0,
                                                sizeof(ns1__relatedDatafile), 0, soap_copy_ns1__relatedDatafile);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__relatedDatafile::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__relatedDatafile);
  if (this->soap_out(soap, tag ? tag : "ns1:relatedDatafile", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__relatedDatafile::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__relatedDatafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__relatedDatafile *SOAP_FMAC4 soap_get_ns1__relatedDatafile(struct soap *soap, ns1__relatedDatafile *p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_ns1__relatedDatafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__relatedDatafile *SOAP_FMAC2 soap_instantiate_ns1__relatedDatafile(struct soap *soap, int n,
                                                                                  const char *type,
                                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__relatedDatafile(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__relatedDatafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__relatedDatafile);
    if (size)
      *size = sizeof(ns1__relatedDatafile);
    ((ns1__relatedDatafile *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__relatedDatafile, n);
    if (size)
      *size = n * sizeof(ns1__relatedDatafile);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__relatedDatafile *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__relatedDatafile *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__relatedDatafile(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__relatedDatafile %p -> %p\n", q, p));
  *(ns1__relatedDatafile *)p = *(ns1__relatedDatafile *)q;
}

void ns1__shift::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__shift::comment = nullptr;
  this->ns1__shift::endDate = nullptr;
  this->ns1__shift::investigation = nullptr;
  this->ns1__shift::startDate = nullptr;
}

void ns1__shift::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__shift::comment);
  soap_serialize_PointerTotime(soap, &this->ns1__shift::endDate);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__shift::investigation);
  soap_serialize_PointerTotime(soap, &this->ns1__shift::startDate);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__shift::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__shift(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__shift(struct soap *soap, const char *tag, int id, const ns1__shift *a,
                                              const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__shift), "ns1:shift"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "comment", -1, &(a->ns1__shift::comment), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__shift::endDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__shift::investigation), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__shift::startDate), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__shift::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__shift(soap, tag, this, type);
}

SOAP_FMAC3 ns1__shift *SOAP_FMAC4 soap_in_ns1__shift(struct soap *soap, const char *tag, ns1__shift *a,
                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__shift *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__shift, sizeof(ns1__shift), soap->type,
                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__shift) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__shift *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_comment1 = 1;
  size_t soap_flag_endDate1 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_startDate1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "comment", &(a->ns1__shift::comment), "xsd:string")) {
          soap_flag_comment1--;
          continue;
        }
      if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__shift::endDate), "xsd:dateTime")) {
          soap_flag_endDate1--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__shift::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__shift::startDate), "xsd:dateTime")) {
          soap_flag_startDate1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__shift *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__shift, 0, sizeof(ns1__shift),
                                      0, soap_copy_ns1__shift);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__shift::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__shift);
  if (this->soap_out(soap, tag ? tag : "ns1:shift", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__shift::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__shift(soap, this, tag, type);
}

SOAP_FMAC3 ns1__shift *SOAP_FMAC4 soap_get_ns1__shift(struct soap *soap, ns1__shift *p, const char *tag,
                                                      const char *type) {
  if ((p = soap_in_ns1__shift(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__shift *SOAP_FMAC2 soap_instantiate_ns1__shift(struct soap *soap, int n, const char *type,
                                                              const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__shift(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__shift, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__shift);
    if (size)
      *size = sizeof(ns1__shift);
    ((ns1__shift *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__shift, n);
    if (size)
      *size = n * sizeof(ns1__shift);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__shift *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__shift *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__shift(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__shift %p -> %p\n", q, p));
  *(ns1__shift *)p = *(ns1__shift *)q;
}

void ns1__publication::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__publication::doi = nullptr;
  this->ns1__publication::fullReference = nullptr;
  this->ns1__publication::investigation = nullptr;
  this->ns1__publication::repository = nullptr;
  this->ns1__publication::repositoryId = nullptr;
  this->ns1__publication::url = nullptr;
}

void ns1__publication::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__publication::doi);
  soap_serialize_PointerTostd__string(soap, &this->ns1__publication::fullReference);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__publication::investigation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__publication::repository);
  soap_serialize_PointerTostd__string(soap, &this->ns1__publication::repositoryId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__publication::url);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__publication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__publication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__publication(struct soap *soap, const char *tag, int id,
                                                    const ns1__publication *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__publication),
                             "ns1:publication"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "doi", -1, &(a->ns1__publication::doi), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "fullReference", -1, &(a->ns1__publication::fullReference), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__publication::investigation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "repository", -1, &(a->ns1__publication::repository), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "repositoryId", -1, &(a->ns1__publication::repositoryId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "url", -1, &(a->ns1__publication::url), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__publication::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__publication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__publication *SOAP_FMAC4 soap_in_ns1__publication(struct soap *soap, const char *tag,
                                                                 ns1__publication *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__publication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__publication,
                                              sizeof(ns1__publication), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__publication) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__publication *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_doi1 = 1;
  size_t soap_flag_fullReference1 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_repository1 = 1;
  size_t soap_flag_repositoryId1 = 1;
  size_t soap_flag_url1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_doi1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "doi", &(a->ns1__publication::doi), "xsd:string")) {
          soap_flag_doi1--;
          continue;
        }
      if (soap_flag_fullReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "fullReference", &(a->ns1__publication::fullReference), "xsd:string")) {
          soap_flag_fullReference1--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__publication::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_repository1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "repository", &(a->ns1__publication::repository), "xsd:string")) {
          soap_flag_repository1--;
          continue;
        }
      if (soap_flag_repositoryId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "repositoryId", &(a->ns1__publication::repositoryId), "xsd:string")) {
          soap_flag_repositoryId1--;
          continue;
        }
      if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "url", &(a->ns1__publication::url), "xsd:string")) {
          soap_flag_url1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__publication *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__publication, 0,
                                            sizeof(ns1__publication), 0, soap_copy_ns1__publication);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__publication::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__publication);
  if (this->soap_out(soap, tag ? tag : "ns1:publication", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__publication::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__publication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__publication *SOAP_FMAC4 soap_get_ns1__publication(struct soap *soap, ns1__publication *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__publication(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__publication *SOAP_FMAC2 soap_instantiate_ns1__publication(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__publication(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__publication, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__publication);
    if (size)
      *size = sizeof(ns1__publication);
    ((ns1__publication *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publication, n);
    if (size)
      *size = n * sizeof(ns1__publication);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__publication *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__publication *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__publication(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__publication %p -> %p\n", q, p));
  *(ns1__publication *)p = *(ns1__publication *)q;
}

void ns1__keyword::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__keyword::investigation = nullptr;
  this->ns1__keyword::name = nullptr;
}

void ns1__keyword::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__keyword::investigation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__keyword::name);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__keyword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__keyword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__keyword(struct soap *soap, const char *tag, int id, const ns1__keyword *a,
                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__keyword), "ns1:keyword"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__keyword::investigation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__keyword::name), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__keyword::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__keyword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__keyword *SOAP_FMAC4 soap_in_ns1__keyword(struct soap *soap, const char *tag, ns1__keyword *a,
                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__keyword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__keyword, sizeof(ns1__keyword),
                                          soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__keyword) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__keyword *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__keyword::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__keyword::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__keyword *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__keyword, 0,
                                        sizeof(ns1__keyword), 0, soap_copy_ns1__keyword);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__keyword::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__keyword);
  if (this->soap_out(soap, tag ? tag : "ns1:keyword", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__keyword::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__keyword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__keyword *SOAP_FMAC4 soap_get_ns1__keyword(struct soap *soap, ns1__keyword *p, const char *tag,
                                                          const char *type) {
  if ((p = soap_in_ns1__keyword(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__keyword *SOAP_FMAC2 soap_instantiate_ns1__keyword(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__keyword(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__keyword, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__keyword);
    if (size)
      *size = sizeof(ns1__keyword);
    ((ns1__keyword *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__keyword, n);
    if (size)
      *size = n * sizeof(ns1__keyword);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__keyword *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__keyword *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__keyword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__keyword %p -> %p\n", q, p));
  *(ns1__keyword *)p = *(ns1__keyword *)q;
}

void ns1__sampleType::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__sampleType::facility = nullptr;
  this->ns1__sampleType::molecularFormula = nullptr;
  this->ns1__sampleType::name = nullptr;
  this->ns1__sampleType::safetyInformation = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__sampleType::samples);
}

void ns1__sampleType::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__facility(soap, &this->ns1__sampleType::facility);
  soap_serialize_PointerTostd__string(soap, &this->ns1__sampleType::molecularFormula);
  soap_serialize_PointerTostd__string(soap, &this->ns1__sampleType::name);
  soap_serialize_PointerTostd__string(soap, &this->ns1__sampleType::safetyInformation);
  soap_serialize_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__sampleType::samples);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__sampleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__sampleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sampleType(struct soap *soap, const char *tag, int id, const ns1__sampleType *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__sampleType),
                             "ns1:sampleType"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__sampleType::facility), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "molecularFormula", -1, &(a->ns1__sampleType::molecularFormula), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__sampleType::name), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "safetyInformation", -1, &(a->ns1__sampleType::safetyInformation), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__sample(soap, "samples", -1, &(a->ns1__sampleType::samples), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__sampleType::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__sampleType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sampleType *SOAP_FMAC4 soap_in_ns1__sampleType(struct soap *soap, const char *tag, ns1__sampleType *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__sampleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__sampleType,
                                             sizeof(ns1__sampleType), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__sampleType) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__sampleType *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_molecularFormula1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_safetyInformation1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__sampleType::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap_flag_molecularFormula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "molecularFormula", &(a->ns1__sampleType::molecularFormula),
                                         "xsd:string")) {
          soap_flag_molecularFormula1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__sampleType::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_safetyInformation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "safetyInformation", &(a->ns1__sampleType::safetyInformation),
                                         "xsd:string")) {
          soap_flag_safetyInformation1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__sample(soap, "samples", &(a->ns1__sampleType::samples),
                                                              "ns1:sample"))
          continue;
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__sampleType *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__sampleType, 0,
                                           sizeof(ns1__sampleType), 0, soap_copy_ns1__sampleType);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__sampleType::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__sampleType);
  if (this->soap_out(soap, tag ? tag : "ns1:sampleType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__sampleType::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__sampleType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sampleType *SOAP_FMAC4 soap_get_ns1__sampleType(struct soap *soap, ns1__sampleType *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__sampleType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__sampleType *SOAP_FMAC2 soap_instantiate_ns1__sampleType(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sampleType(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__sampleType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__sampleType);
    if (size)
      *size = sizeof(ns1__sampleType);
    ((ns1__sampleType *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleType, n);
    if (size)
      *size = n * sizeof(ns1__sampleType);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__sampleType *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__sampleType *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sampleType(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sampleType %p -> %p\n", q, p));
  *(ns1__sampleType *)p = *(ns1__sampleType *)q;
}

void ns1__sample::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__sample::datasets);
  this->ns1__sample::investigation = nullptr;
  this->ns1__sample::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__sample::parameters);
  this->ns1__sample::type = nullptr;
}

void ns1__sample::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__sample::datasets);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__sample::investigation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__sample::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__sample::parameters);
  soap_serialize_PointerTons1__sampleType(soap, &this->ns1__sample::type);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__sample::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__sample(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sample(struct soap *soap, const char *tag, int id, const ns1__sample *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__sample), "ns1:sample"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", -1, &(a->ns1__sample::datasets), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__sample::investigation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__sample::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__sampleParameter(soap, "parameters", -1, &(a->ns1__sample::parameters),
                                                                  ""))
    return soap->error;
  if (soap_out_PointerTons1__sampleType(soap, "type", -1, &(a->ns1__sample::type), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__sample::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__sample(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sample *SOAP_FMAC4 soap_in_ns1__sample(struct soap *soap, const char *tag, ns1__sample *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__sample *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__sample, sizeof(ns1__sample),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__sample) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__sample *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_type1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", &(a->ns1__sample::datasets),
                                                               "ns1:dataset"))
          continue;
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__sample::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__sample::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__sampleParameter(
                soap, "parameters", &(a->ns1__sample::parameters), "ns1:sampleParameter"))
          continue;
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__sampleType(soap, "type", &(a->ns1__sample::type), "ns1:sampleType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__sample *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__sample, 0,
                                       sizeof(ns1__sample), 0, soap_copy_ns1__sample);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__sample::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__sample);
  if (this->soap_out(soap, tag ? tag : "ns1:sample", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__sample::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__sample(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sample *SOAP_FMAC4 soap_get_ns1__sample(struct soap *soap, ns1__sample *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__sample(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__sample *SOAP_FMAC2 soap_instantiate_ns1__sample(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sample(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__sample, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__sample);
    if (size)
      *size = sizeof(ns1__sample);
    ((ns1__sample *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sample, n);
    if (size)
      *size = n * sizeof(ns1__sample);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__sample *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__sample *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sample(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sample %p -> %p\n", q, p));
  *(ns1__sample *)p = *(ns1__sample *)q;
}

void ns1__sampleParameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__parameter::soap_default(soap);
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__sampleParameter::sample = nullptr;
}

void ns1__sampleParameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__sample(soap, &this->ns1__sampleParameter::sample);
  this->ns1__parameter::soap_serialize(soap);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__sampleParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__sampleParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sampleParameter(struct soap *soap, const char *tag, int id,
                                                        const ns1__sampleParameter *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__sampleParameter),
                             "ns1:sampleParameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  if (soap_out_PointerTons1__sample(soap, "sample", -1, &(a->ns1__sampleParameter::sample), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__sampleParameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__sampleParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sampleParameter *SOAP_FMAC4 soap_in_ns1__sampleParameter(struct soap *soap, const char *tag,
                                                                         ns1__sampleParameter *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__sampleParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__sampleParameter,
                                                  sizeof(ns1__sampleParameter), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__sampleParameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__sampleParameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item4 = 1;
  size_t soap_flag_createId3 = 1;
  size_t soap_flag_createTime3 = 1;
  size_t soap_flag_modTime3 = 1;
  size_t soap_flag_id3 = 1;
  size_t soap_flag_modId3 = 1;
  size_t soap_flag_dateTimeValue2 = 1;
  size_t soap_flag_error2 = 1;
  size_t soap_flag_numericValue2 = 1;
  size_t soap_flag_rangeBottom2 = 1;
  size_t soap_flag_rangeTop2 = 1;
  size_t soap_flag_stringValue2 = 1;
  size_t soap_flag_type2 = 1;
  size_t soap_flag_sample1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId3--;
          continue;
        }
      if (soap_flag_createTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime3--;
          continue;
        }
      if (soap_flag_modTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime3--;
          continue;
        }
      if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id3--;
          continue;
        }
      if (soap_flag_modId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId3--;
          continue;
        }
      if (soap_flag_dateTimeValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue2--;
          continue;
        }
      if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error2--;
          continue;
        }
      if (soap_flag_numericValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue2--;
          continue;
        }
      if (soap_flag_rangeBottom2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom2--;
          continue;
        }
      if (soap_flag_rangeTop2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop2--;
          continue;
        }
      if (soap_flag_stringValue2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue2--;
          continue;
        }
      if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type2--;
          continue;
        }
      if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__sample(soap, "sample", &(a->ns1__sampleParameter::sample), "ns1:sample")) {
          soap_flag_sample1--;
          continue;
        }
      if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item4--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__sampleParameter *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__sampleParameter, 0,
                                                sizeof(ns1__sampleParameter), 0, soap_copy_ns1__sampleParameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__sampleParameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__sampleParameter);
  if (this->soap_out(soap, tag ? tag : "ns1:sampleParameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__sampleParameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__sampleParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sampleParameter *SOAP_FMAC4 soap_get_ns1__sampleParameter(struct soap *soap, ns1__sampleParameter *p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_ns1__sampleParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__sampleParameter *SOAP_FMAC2 soap_instantiate_ns1__sampleParameter(struct soap *soap, int n,
                                                                                  const char *type,
                                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sampleParameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__sampleParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__sampleParameter);
    if (size)
      *size = sizeof(ns1__sampleParameter);
    ((ns1__sampleParameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleParameter, n);
    if (size)
      *size = n * sizeof(ns1__sampleParameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__sampleParameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__sampleParameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sampleParameter(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sampleParameter %p -> %p\n", q, p));
  *(ns1__sampleParameter *)p = *(ns1__sampleParameter *)q;
}

void ns1__permissibleStringValue::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__permissibleStringValue::type = nullptr;
  this->ns1__permissibleStringValue::value = nullptr;
}

void ns1__permissibleStringValue::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__parameterType(soap, &this->ns1__permissibleStringValue::type);
  soap_serialize_PointerTostd__string(soap, &this->ns1__permissibleStringValue::value);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__permissibleStringValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__permissibleStringValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__permissibleStringValue(struct soap *soap, const char *tag, int id,
                                                               const ns1__permissibleStringValue *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__permissibleStringValue),
                             "ns1:permissibleStringValue"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__permissibleStringValue::type), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "value", -1, &(a->ns1__permissibleStringValue::value), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__permissibleStringValue::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__permissibleStringValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__permissibleStringValue *SOAP_FMAC4 soap_in_ns1__permissibleStringValue(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__permissibleStringValue *a,
                                                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__permissibleStringValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__permissibleStringValue,
                                                         sizeof(ns1__permissibleStringValue), soap->type,
                                                         soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__permissibleStringValue) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__permissibleStringValue *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_type1 = 1;
  size_t soap_flag_value1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__permissibleStringValue::type),
                                                "ns1:parameterType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "value", &(a->ns1__permissibleStringValue::value), "xsd:string")) {
          soap_flag_value1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__permissibleStringValue *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__permissibleStringValue, 0,
        sizeof(ns1__permissibleStringValue), 0, soap_copy_ns1__permissibleStringValue);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__permissibleStringValue::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__permissibleStringValue);
  if (this->soap_out(soap, tag ? tag : "ns1:permissibleStringValue", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__permissibleStringValue::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__permissibleStringValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__permissibleStringValue *SOAP_FMAC4 soap_get_ns1__permissibleStringValue(struct soap *soap,
                                                                                        ns1__permissibleStringValue *p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_ns1__permissibleStringValue(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__permissibleStringValue *SOAP_FMAC2 soap_instantiate_ns1__permissibleStringValue(struct soap *soap,
                                                                                                int n, const char *type,
                                                                                                const char *arrayType,
                                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__permissibleStringValue(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__permissibleStringValue, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__permissibleStringValue);
    if (size)
      *size = sizeof(ns1__permissibleStringValue);
    ((ns1__permissibleStringValue *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__permissibleStringValue, n);
    if (size)
      *size = n * sizeof(ns1__permissibleStringValue);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__permissibleStringValue *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__permissibleStringValue *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__permissibleStringValue(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__permissibleStringValue %p -> %p\n", q, p));
  *(ns1__permissibleStringValue *)p = *(ns1__permissibleStringValue *)q;
}

void ns1__investigationParameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__parameter::soap_default(soap);
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__investigationParameter::investigation = nullptr;
}

void ns1__investigationParameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__investigationParameter::investigation);
  this->ns1__parameter::soap_serialize(soap);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__investigationParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__investigationParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationParameter(struct soap *soap, const char *tag, int id,
                                                               const ns1__investigationParameter *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__investigationParameter),
                             "ns1:investigationParameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__investigationParameter::investigation),
                                           ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__investigationParameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__investigationParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigationParameter *SOAP_FMAC4 soap_in_ns1__investigationParameter(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__investigationParameter *a,
                                                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__investigationParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__investigationParameter,
                                                         sizeof(ns1__investigationParameter), soap->type,
                                                         soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__investigationParameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__investigationParameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item4 = 1;
  size_t soap_flag_createId3 = 1;
  size_t soap_flag_createTime3 = 1;
  size_t soap_flag_modTime3 = 1;
  size_t soap_flag_id3 = 1;
  size_t soap_flag_modId3 = 1;
  size_t soap_flag_dateTimeValue2 = 1;
  size_t soap_flag_error2 = 1;
  size_t soap_flag_numericValue2 = 1;
  size_t soap_flag_rangeBottom2 = 1;
  size_t soap_flag_rangeTop2 = 1;
  size_t soap_flag_stringValue2 = 1;
  size_t soap_flag_type2 = 1;
  size_t soap_flag_investigation1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId3--;
          continue;
        }
      if (soap_flag_createTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime3--;
          continue;
        }
      if (soap_flag_modTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime3--;
          continue;
        }
      if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id3--;
          continue;
        }
      if (soap_flag_modId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId3--;
          continue;
        }
      if (soap_flag_dateTimeValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue2--;
          continue;
        }
      if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error2--;
          continue;
        }
      if (soap_flag_numericValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue2--;
          continue;
        }
      if (soap_flag_rangeBottom2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom2--;
          continue;
        }
      if (soap_flag_rangeTop2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop2--;
          continue;
        }
      if (soap_flag_stringValue2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue2--;
          continue;
        }
      if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type2--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__investigationParameter::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item4--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__investigationParameter *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__investigationParameter, 0,
        sizeof(ns1__investigationParameter), 0, soap_copy_ns1__investigationParameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__investigationParameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__investigationParameter);
  if (this->soap_out(soap, tag ? tag : "ns1:investigationParameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__investigationParameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__investigationParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigationParameter *SOAP_FMAC4 soap_get_ns1__investigationParameter(struct soap *soap,
                                                                                        ns1__investigationParameter *p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_ns1__investigationParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__investigationParameter *SOAP_FMAC2 soap_instantiate_ns1__investigationParameter(struct soap *soap,
                                                                                                int n, const char *type,
                                                                                                const char *arrayType,
                                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigationParameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__investigationParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__investigationParameter);
    if (size)
      *size = sizeof(ns1__investigationParameter);
    ((ns1__investigationParameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationParameter, n);
    if (size)
      *size = n * sizeof(ns1__investigationParameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__investigationParameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__investigationParameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigationParameter(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigationParameter %p -> %p\n", q, p));
  *(ns1__investigationParameter *)p = *(ns1__investigationParameter *)q;
}

void ns1__datasetParameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__parameter::soap_default(soap);
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__datasetParameter::dataset = nullptr;
}

void ns1__datasetParameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dataset(soap, &this->ns1__datasetParameter::dataset);
  this->ns1__parameter::soap_serialize(soap);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__datasetParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__datasetParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetParameter(struct soap *soap, const char *tag, int id,
                                                         const ns1__datasetParameter *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__datasetParameter),
                             "ns1:datasetParameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataset(soap, "dataset", -1, &(a->ns1__datasetParameter::dataset), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__datasetParameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__datasetParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datasetParameter *SOAP_FMAC4 soap_in_ns1__datasetParameter(struct soap *soap, const char *tag,
                                                                           ns1__datasetParameter *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__datasetParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__datasetParameter,
                                                   sizeof(ns1__datasetParameter), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__datasetParameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__datasetParameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item4 = 1;
  size_t soap_flag_createId3 = 1;
  size_t soap_flag_createTime3 = 1;
  size_t soap_flag_modTime3 = 1;
  size_t soap_flag_id3 = 1;
  size_t soap_flag_modId3 = 1;
  size_t soap_flag_dateTimeValue2 = 1;
  size_t soap_flag_error2 = 1;
  size_t soap_flag_numericValue2 = 1;
  size_t soap_flag_rangeBottom2 = 1;
  size_t soap_flag_rangeTop2 = 1;
  size_t soap_flag_stringValue2 = 1;
  size_t soap_flag_type2 = 1;
  size_t soap_flag_dataset1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId3--;
          continue;
        }
      if (soap_flag_createTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime3--;
          continue;
        }
      if (soap_flag_modTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime3--;
          continue;
        }
      if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id3--;
          continue;
        }
      if (soap_flag_modId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId3--;
          continue;
        }
      if (soap_flag_dateTimeValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue2--;
          continue;
        }
      if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error2--;
          continue;
        }
      if (soap_flag_numericValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue2--;
          continue;
        }
      if (soap_flag_rangeBottom2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom2--;
          continue;
        }
      if (soap_flag_rangeTop2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop2--;
          continue;
        }
      if (soap_flag_stringValue2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue2--;
          continue;
        }
      if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type2--;
          continue;
        }
      if (soap_flag_dataset1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataset(soap, "dataset", &(a->ns1__datasetParameter::dataset), "ns1:dataset")) {
          soap_flag_dataset1--;
          continue;
        }
      if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item4--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__datasetParameter *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__datasetParameter,
                                                 0, sizeof(ns1__datasetParameter), 0, soap_copy_ns1__datasetParameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__datasetParameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__datasetParameter);
  if (this->soap_out(soap, tag ? tag : "ns1:datasetParameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__datasetParameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__datasetParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datasetParameter *SOAP_FMAC4 soap_get_ns1__datasetParameter(struct soap *soap, ns1__datasetParameter *p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_ns1__datasetParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__datasetParameter *SOAP_FMAC2 soap_instantiate_ns1__datasetParameter(struct soap *soap, int n,
                                                                                    const char *type,
                                                                                    const char *arrayType,
                                                                                    size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datasetParameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__datasetParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__datasetParameter);
    if (size)
      *size = sizeof(ns1__datasetParameter);
    ((ns1__datasetParameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetParameter, n);
    if (size)
      *size = n * sizeof(ns1__datasetParameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__datasetParameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__datasetParameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datasetParameter(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datasetParameter %p -> %p\n", q, p));
  *(ns1__datasetParameter *)p = *(ns1__datasetParameter *)q;
}

void ns1__datafileParameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__parameter::soap_default(soap);
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__datafileParameter::datafile = nullptr;
}

void ns1__datafileParameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__datafile(soap, &this->ns1__datafileParameter::datafile);
  this->ns1__parameter::soap_serialize(soap);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__datafileParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__datafileParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileParameter(struct soap *soap, const char *tag, int id,
                                                          const ns1__datafileParameter *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__datafileParameter),
                             "ns1:datafileParameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafile(soap, "datafile", -1, &(a->ns1__datafileParameter::datafile), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__datafileParameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__datafileParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileParameter *SOAP_FMAC4 soap_in_ns1__datafileParameter(struct soap *soap, const char *tag,
                                                                             ns1__datafileParameter *a,
                                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__datafileParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__datafileParameter,
                                                    sizeof(ns1__datafileParameter), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__datafileParameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__datafileParameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item4 = 1;
  size_t soap_flag_createId3 = 1;
  size_t soap_flag_createTime3 = 1;
  size_t soap_flag_modTime3 = 1;
  size_t soap_flag_id3 = 1;
  size_t soap_flag_modId3 = 1;
  size_t soap_flag_dateTimeValue2 = 1;
  size_t soap_flag_error2 = 1;
  size_t soap_flag_numericValue2 = 1;
  size_t soap_flag_rangeBottom2 = 1;
  size_t soap_flag_rangeTop2 = 1;
  size_t soap_flag_stringValue2 = 1;
  size_t soap_flag_type2 = 1;
  size_t soap_flag_datafile1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId3--;
          continue;
        }
      if (soap_flag_createTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime3--;
          continue;
        }
      if (soap_flag_modTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime3--;
          continue;
        }
      if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id3--;
          continue;
        }
      if (soap_flag_modId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId3--;
          continue;
        }
      if (soap_flag_dateTimeValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue2--;
          continue;
        }
      if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error2--;
          continue;
        }
      if (soap_flag_numericValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue2--;
          continue;
        }
      if (soap_flag_rangeBottom2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom2--;
          continue;
        }
      if (soap_flag_rangeTop2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop2--;
          continue;
        }
      if (soap_flag_stringValue2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue2--;
          continue;
        }
      if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type2--;
          continue;
        }
      if (soap_flag_datafile1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafile(soap, "datafile", &(a->ns1__datafileParameter::datafile), "ns1:datafile")) {
          soap_flag_datafile1--;
          continue;
        }
      if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item4--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__datafileParameter *)soap_id_forward(soap, soap->href, (void *)a, 0,
                                                  SOAP_TYPE_ICat4_ns1__datafileParameter, 0,
                                                  sizeof(ns1__datafileParameter), 0, soap_copy_ns1__datafileParameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__datafileParameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__datafileParameter);
  if (this->soap_out(soap, tag ? tag : "ns1:datafileParameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__datafileParameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__datafileParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileParameter *SOAP_FMAC4 soap_get_ns1__datafileParameter(struct soap *soap,
                                                                              ns1__datafileParameter *p,
                                                                              const char *tag, const char *type) {
  if ((p = soap_in_ns1__datafileParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__datafileParameter *SOAP_FMAC2 soap_instantiate_ns1__datafileParameter(struct soap *soap, int n,
                                                                                      const char *type,
                                                                                      const char *arrayType,
                                                                                      size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileParameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__datafileParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__datafileParameter);
    if (size)
      *size = sizeof(ns1__datafileParameter);
    ((ns1__datafileParameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileParameter, n);
    if (size)
      *size = n * sizeof(ns1__datafileParameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__datafileParameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__datafileParameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileParameter(struct soap *soap, int st, int tt, void *p, size_t len,
                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileParameter %p -> %p\n", q, p));
  *(ns1__datafileParameter *)p = *(ns1__datafileParameter *)q;
}

void ns1__parameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__parameter::dateTimeValue = nullptr;
  this->ns1__parameter::error = nullptr;
  this->ns1__parameter::numericValue = nullptr;
  this->ns1__parameter::rangeBottom = nullptr;
  this->ns1__parameter::rangeTop = nullptr;
  this->ns1__parameter::stringValue = nullptr;
  this->ns1__parameter::type = nullptr;
}

void ns1__parameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTotime(soap, &this->ns1__parameter::dateTimeValue);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameter::error);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameter::numericValue);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameter::rangeBottom);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameter::rangeTop);
  soap_serialize_PointerTostd__string(soap, &this->ns1__parameter::stringValue);
  soap_serialize_PointerTons1__parameterType(soap, &this->ns1__parameter::type);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameter(struct soap *soap, const char *tag, int id, const ns1__parameter *a,
                                                  const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__parameter), "ns1:parameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__parameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__parameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__parameter *SOAP_FMAC4 soap_in_ns1__parameter(struct soap *soap, const char *tag, ns1__parameter *a,
                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__parameter, sizeof(ns1__parameter),
                                            soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__parameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__parameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_dateTimeValue1 = 1;
  size_t soap_flag_error1 = 1;
  size_t soap_flag_numericValue1 = 1;
  size_t soap_flag_rangeBottom1 = 1;
  size_t soap_flag_rangeTop1 = 1;
  size_t soap_flag_stringValue1 = 1;
  size_t soap_flag_type1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_dateTimeValue1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue1--;
          continue;
        }
      if (soap_flag_error1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error1--;
          continue;
        }
      if (soap_flag_numericValue1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue1--;
          continue;
        }
      if (soap_flag_rangeBottom1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom1--;
          continue;
        }
      if (soap_flag_rangeTop1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop1--;
          continue;
        }
      if (soap_flag_stringValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue1--;
          continue;
        }
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__parameter *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__parameter, 0,
                                          sizeof(ns1__parameter), 0, soap_copy_ns1__parameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__parameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__parameter);
  if (this->soap_out(soap, tag ? tag : "ns1:parameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__parameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__parameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__parameter *SOAP_FMAC4 soap_get_ns1__parameter(struct soap *soap, ns1__parameter *p, const char *tag,
                                                              const char *type) {
  if ((p = soap_in_ns1__parameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__parameter *SOAP_FMAC2 soap_instantiate_ns1__parameter(struct soap *soap, int n, const char *type,
                                                                      const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__parameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__parameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionParameter);
      if (size)
        *size = sizeof(ns1__dataCollectionParameter);
      ((ns1__dataCollectionParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionParameter, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafileParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafileParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafileParameter);
      if (size)
        *size = sizeof(ns1__datafileParameter);
      ((ns1__datafileParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileParameter, n);
      if (size)
        *size = n * sizeof(ns1__datafileParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafileParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafileParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datasetParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datasetParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datasetParameter);
      if (size)
        *size = sizeof(ns1__datasetParameter);
      ((ns1__datasetParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetParameter, n);
      if (size)
        *size = n * sizeof(ns1__datasetParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datasetParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datasetParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationParameter);
      if (size)
        *size = sizeof(ns1__investigationParameter);
      ((ns1__investigationParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationParameter, n);
      if (size)
        *size = n * sizeof(ns1__investigationParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sampleParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sampleParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sampleParameter);
      if (size)
        *size = sizeof(ns1__sampleParameter);
      ((ns1__sampleParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleParameter, n);
      if (size)
        *size = n * sizeof(ns1__sampleParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sampleParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sampleParameter *)cp->ptr;
  }
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__parameter);
    if (size)
      *size = sizeof(ns1__parameter);
    ((ns1__parameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameter, n);
    if (size)
      *size = n * sizeof(ns1__parameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__parameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__parameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__parameter(struct soap *soap, int st, int tt, void *p, size_t len,
                                                    const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__parameter %p -> %p\n", q, p));
  *(ns1__parameter *)p = *(ns1__parameter *)q;
}

void ns1__dataCollectionParameter::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__parameter::soap_default(soap);
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__dataCollectionParameter::dataCollection = nullptr;
}

void ns1__dataCollectionParameter::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__dataCollectionParameter::dataCollection);
  this->ns1__parameter::soap_serialize(soap);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dataCollectionParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dataCollectionParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataCollectionParameter(struct soap *soap, const char *tag, int id,
                                                                const ns1__dataCollectionParameter *a,
                                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dataCollectionParameter),
                             "ns1:dataCollectionParameter"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "dateTimeValue", -1, &(a->ns1__parameter::dateTimeValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "error", -1, &(a->ns1__parameter::error), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "numericValue", -1, &(a->ns1__parameter::numericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeBottom", -1, &(a->ns1__parameter::rangeBottom), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "rangeTop", -1, &(a->ns1__parameter::rangeTop), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "stringValue", -1, &(a->ns1__parameter::stringValue), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "type", -1, &(a->ns1__parameter::type), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "dataCollection", -1,
                                            &(a->ns1__dataCollectionParameter::dataCollection), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dataCollectionParameter::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dataCollectionParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataCollectionParameter *SOAP_FMAC4 soap_in_ns1__dataCollectionParameter(
    struct soap *soap, const char *tag, ns1__dataCollectionParameter *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dataCollectionParameter *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dataCollectionParameter, sizeof(ns1__dataCollectionParameter), soap->type,
      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dataCollectionParameter) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dataCollectionParameter *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item4 = 1;
  size_t soap_flag_createId3 = 1;
  size_t soap_flag_createTime3 = 1;
  size_t soap_flag_modTime3 = 1;
  size_t soap_flag_id3 = 1;
  size_t soap_flag_modId3 = 1;
  size_t soap_flag_dateTimeValue2 = 1;
  size_t soap_flag_error2 = 1;
  size_t soap_flag_numericValue2 = 1;
  size_t soap_flag_rangeBottom2 = 1;
  size_t soap_flag_rangeTop2 = 1;
  size_t soap_flag_stringValue2 = 1;
  size_t soap_flag_type2 = 1;
  size_t soap_flag_dataCollection1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId3--;
          continue;
        }
      if (soap_flag_createTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime3--;
          continue;
        }
      if (soap_flag_modTime3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime3--;
          continue;
        }
      if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id3--;
          continue;
        }
      if (soap_flag_modId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId3--;
          continue;
        }
      if (soap_flag_dateTimeValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "dateTimeValue", &(a->ns1__parameter::dateTimeValue), "xsd:dateTime")) {
          soap_flag_dateTimeValue2--;
          continue;
        }
      if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "error", &(a->ns1__parameter::error), "xsd:double")) {
          soap_flag_error2--;
          continue;
        }
      if (soap_flag_numericValue2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "numericValue", &(a->ns1__parameter::numericValue), "xsd:double")) {
          soap_flag_numericValue2--;
          continue;
        }
      if (soap_flag_rangeBottom2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeBottom", &(a->ns1__parameter::rangeBottom), "xsd:double")) {
          soap_flag_rangeBottom2--;
          continue;
        }
      if (soap_flag_rangeTop2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "rangeTop", &(a->ns1__parameter::rangeTop), "xsd:double")) {
          soap_flag_rangeTop2--;
          continue;
        }
      if (soap_flag_stringValue2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "stringValue", &(a->ns1__parameter::stringValue), "xsd:string")) {
          soap_flag_stringValue2--;
          continue;
        }
      if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "type", &(a->ns1__parameter::type), "ns1:parameterType")) {
          soap_flag_type2--;
          continue;
        }
      if (soap_flag_dataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(
                soap, "dataCollection", &(a->ns1__dataCollectionParameter::dataCollection), "ns1:dataCollection")) {
          soap_flag_dataCollection1--;
          continue;
        }
      if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item4--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dataCollectionParameter *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dataCollectionParameter, 0,
        sizeof(ns1__dataCollectionParameter), 0, soap_copy_ns1__dataCollectionParameter);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__dataCollectionParameter::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dataCollectionParameter);
  if (this->soap_out(soap, tag ? tag : "ns1:dataCollectionParameter", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dataCollectionParameter::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dataCollectionParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataCollectionParameter *SOAP_FMAC4 soap_get_ns1__dataCollectionParameter(
    struct soap *soap, ns1__dataCollectionParameter *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__dataCollectionParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dataCollectionParameter *SOAP_FMAC2 soap_instantiate_ns1__dataCollectionParameter(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataCollectionParameter(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dataCollectionParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionParameter);
    if (size)
      *size = sizeof(ns1__dataCollectionParameter);
    ((ns1__dataCollectionParameter *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionParameter, n);
    if (size)
      *size = n * sizeof(ns1__dataCollectionParameter);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dataCollectionParameter *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dataCollectionParameter *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataCollectionParameter(struct soap *soap, int st, int tt, void *p,
                                                                  size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataCollectionParameter %p -> %p\n", q, p));
  *(ns1__dataCollectionParameter *)p = *(ns1__dataCollectionParameter *)q;
}

void ns1__parameterType::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_bool(soap, &this->ns1__parameterType::applicableToDataCollection);
  soap_default_bool(soap, &this->ns1__parameterType::applicableToDatafile);
  soap_default_bool(soap, &this->ns1__parameterType::applicableToDataset);
  soap_default_bool(soap, &this->ns1__parameterType::applicableToInvestigation);
  soap_default_bool(soap, &this->ns1__parameterType::applicableToSample);
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
      soap, &this->ns1__parameterType::dataCollectionParameters);
  soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(soap,
                                                                    &this->ns1__parameterType::datafileParameters);
  soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__parameterType::datasetParameters);
  this->ns1__parameterType::description = nullptr;
  soap_default_bool(soap, &this->ns1__parameterType::enforced);
  this->ns1__parameterType::facility = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__investigationParameter(
      soap, &this->ns1__parameterType::investigationParameters);
  this->ns1__parameterType::maximumNumericValue = nullptr;
  this->ns1__parameterType::minimumNumericValue = nullptr;
  this->ns1__parameterType::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__permissibleStringValue(
      soap, &this->ns1__parameterType::permissibleStringValues);
  soap_default_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__parameterType::sampleParameters);
  this->ns1__parameterType::units = nullptr;
  this->ns1__parameterType::unitsFullName = nullptr;
  this->ns1__parameterType::valueType = nullptr;
  soap_default_bool(soap, &this->ns1__parameterType::verified);
}

void ns1__parameterType::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
      soap, &this->ns1__parameterType::dataCollectionParameters);
  soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(soap,
                                                                      &this->ns1__parameterType::datafileParameters);
  soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(soap,
                                                                     &this->ns1__parameterType::datasetParameters);
  soap_serialize_PointerTostd__string(soap, &this->ns1__parameterType::description);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__parameterType::facility);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationParameter(
      soap, &this->ns1__parameterType::investigationParameters);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameterType::maximumNumericValue);
  soap_serialize_PointerTodouble(soap, &this->ns1__parameterType::minimumNumericValue);
  soap_serialize_PointerTostd__string(soap, &this->ns1__parameterType::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__permissibleStringValue(
      soap, &this->ns1__parameterType::permissibleStringValues);
  soap_serialize_std__vectorTemplateOfPointerTons1__sampleParameter(soap, &this->ns1__parameterType::sampleParameters);
  soap_serialize_PointerTostd__string(soap, &this->ns1__parameterType::units);
  soap_serialize_PointerTostd__string(soap, &this->ns1__parameterType::unitsFullName);
  soap_serialize_PointerTons1__parameterValueType(soap, &this->ns1__parameterType::valueType);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__parameterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__parameterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__parameterType(struct soap *soap, const char *tag, int id,
                                                      const ns1__parameterType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__parameterType),
                             "ns1:parameterType"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_bool(soap, "applicableToDataCollection", -1, &(a->ns1__parameterType::applicableToDataCollection), ""))
    return soap->error;
  if (soap_out_bool(soap, "applicableToDatafile", -1, &(a->ns1__parameterType::applicableToDatafile), ""))
    return soap->error;
  if (soap_out_bool(soap, "applicableToDataset", -1, &(a->ns1__parameterType::applicableToDataset), ""))
    return soap->error;
  if (soap_out_bool(soap, "applicableToInvestigation", -1, &(a->ns1__parameterType::applicableToInvestigation), ""))
    return soap->error;
  if (soap_out_bool(soap, "applicableToSample", -1, &(a->ns1__parameterType::applicableToSample), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
          soap, "dataCollectionParameters", -1, &(a->ns1__parameterType::dataCollectionParameters), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "datafileParameters", -1,
                                                                    &(a->ns1__parameterType::datafileParameters), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "datasetParameters", -1,
                                                                   &(a->ns1__parameterType::datasetParameters), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__parameterType::description), ""))
    return soap->error;
  if (soap_out_bool(soap, "enforced", -1, &(a->ns1__parameterType::enforced), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__parameterType::facility), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationParameter(
          soap, "investigationParameters", -1, &(a->ns1__parameterType::investigationParameters), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "maximumNumericValue", -1, &(a->ns1__parameterType::maximumNumericValue), ""))
    return soap->error;
  if (soap_out_PointerTodouble(soap, "minimumNumericValue", -1, &(a->ns1__parameterType::minimumNumericValue), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__parameterType::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__permissibleStringValue(
          soap, "permissibleStringValues", -1, &(a->ns1__parameterType::permissibleStringValues), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__sampleParameter(soap, "sampleParameters", -1,
                                                                  &(a->ns1__parameterType::sampleParameters), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "units", -1, &(a->ns1__parameterType::units), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "unitsFullName", -1, &(a->ns1__parameterType::unitsFullName), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterValueType(soap, "valueType", -1, &(a->ns1__parameterType::valueType), ""))
    return soap->error;
  if (soap_out_bool(soap, "verified", -1, &(a->ns1__parameterType::verified), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__parameterType::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__parameterType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__parameterType *SOAP_FMAC4 soap_in_ns1__parameterType(struct soap *soap, const char *tag,
                                                                     ns1__parameterType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__parameterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__parameterType,
                                                sizeof(ns1__parameterType), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__parameterType) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__parameterType *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_applicableToDataCollection1 = 1;
  size_t soap_flag_applicableToDatafile1 = 1;
  size_t soap_flag_applicableToDataset1 = 1;
  size_t soap_flag_applicableToInvestigation1 = 1;
  size_t soap_flag_applicableToSample1 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_enforced1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_maximumNumericValue1 = 1;
  size_t soap_flag_minimumNumericValue1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_units1 = 1;
  size_t soap_flag_unitsFullName1 = 1;
  size_t soap_flag_valueType1 = 1;
  size_t soap_flag_verified1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_applicableToDataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "applicableToDataCollection", &(a->ns1__parameterType::applicableToDataCollection),
                         "xsd:boolean")) {
          soap_flag_applicableToDataCollection1--;
          continue;
        }
      if (soap_flag_applicableToDatafile1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "applicableToDatafile", &(a->ns1__parameterType::applicableToDatafile), "xsd:boolean")) {
          soap_flag_applicableToDatafile1--;
          continue;
        }
      if (soap_flag_applicableToDataset1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "applicableToDataset", &(a->ns1__parameterType::applicableToDataset), "xsd:boolean")) {
          soap_flag_applicableToDataset1--;
          continue;
        }
      if (soap_flag_applicableToInvestigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "applicableToInvestigation", &(a->ns1__parameterType::applicableToInvestigation),
                         "xsd:boolean")) {
          soap_flag_applicableToInvestigation1--;
          continue;
        }
      if (soap_flag_applicableToSample1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "applicableToSample", &(a->ns1__parameterType::applicableToSample), "xsd:boolean")) {
          soap_flag_applicableToSample1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
                soap, "dataCollectionParameters", &(a->ns1__parameterType::dataCollectionParameters),
                "ns1:dataCollectionParameter"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(
                soap, "datafileParameters", &(a->ns1__parameterType::datafileParameters), "ns1:datafileParameter"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(
                soap, "datasetParameters", &(a->ns1__parameterType::datasetParameters), "ns1:datasetParameter"))
          continue;
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__parameterType::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_enforced1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "enforced", &(a->ns1__parameterType::enforced), "xsd:boolean")) {
          soap_flag_enforced1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__parameterType::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationParameter(
                soap, "investigationParameters", &(a->ns1__parameterType::investigationParameters),
                "ns1:investigationParameter"))
          continue;
      if (soap_flag_maximumNumericValue1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "maximumNumericValue", &(a->ns1__parameterType::maximumNumericValue),
                                    "xsd:double")) {
          soap_flag_maximumNumericValue1--;
          continue;
        }
      if (soap_flag_minimumNumericValue1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTodouble(soap, "minimumNumericValue", &(a->ns1__parameterType::minimumNumericValue),
                                    "xsd:double")) {
          soap_flag_minimumNumericValue1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__parameterType::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__permissibleStringValue(
                soap, "permissibleStringValues", &(a->ns1__parameterType::permissibleStringValues),
                "ns1:permissibleStringValue"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__sampleParameter(
                soap, "sampleParameters", &(a->ns1__parameterType::sampleParameters), "ns1:sampleParameter"))
          continue;
      if (soap_flag_units1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "units", &(a->ns1__parameterType::units), "xsd:string")) {
          soap_flag_units1--;
          continue;
        }
      if (soap_flag_unitsFullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "unitsFullName", &(a->ns1__parameterType::unitsFullName),
                                         "xsd:string")) {
          soap_flag_unitsFullName1--;
          continue;
        }
      if (soap_flag_valueType1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterValueType(soap, "valueType", &(a->ns1__parameterType::valueType),
                                                     "ns1:parameterValueType")) {
          soap_flag_valueType1--;
          continue;
        }
      if (soap_flag_verified1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "verified", &(a->ns1__parameterType::verified), "xsd:boolean")) {
          soap_flag_verified1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__parameterType *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__parameterType, 0,
                                              sizeof(ns1__parameterType), 0, soap_copy_ns1__parameterType);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) &&
      (soap_flag_applicableToDataCollection1 > 0 || soap_flag_applicableToDatafile1 > 0 ||
       soap_flag_applicableToDataset1 > 0 || soap_flag_applicableToInvestigation1 > 0 ||
       soap_flag_applicableToSample1 > 0 || soap_flag_enforced1 > 0 || soap_flag_verified1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__parameterType::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__parameterType);
  if (this->soap_out(soap, tag ? tag : "ns1:parameterType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__parameterType::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__parameterType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__parameterType *SOAP_FMAC4 soap_get_ns1__parameterType(struct soap *soap, ns1__parameterType *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__parameterType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__parameterType *SOAP_FMAC2 soap_instantiate_ns1__parameterType(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__parameterType(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__parameterType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__parameterType);
    if (size)
      *size = sizeof(ns1__parameterType);
    ((ns1__parameterType *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameterType, n);
    if (size)
      *size = n * sizeof(ns1__parameterType);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__parameterType *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__parameterType *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__parameterType(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__parameterType %p -> %p\n", q, p));
  *(ns1__parameterType *)p = *(ns1__parameterType *)q;
}

void ns1__investigationType::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__investigationType::description = nullptr;
  this->ns1__investigationType::facility = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__investigationType::investigations);
  this->ns1__investigationType::name = nullptr;
}

void ns1__investigationType::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigationType::description);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__investigationType::facility);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__investigationType::investigations);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigationType::name);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__investigationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__investigationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationType(struct soap *soap, const char *tag, int id,
                                                          const ns1__investigationType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__investigationType),
                             "ns1:investigationType"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__investigationType::description), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__investigationType::facility), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "investigations", -1,
                                                                &(a->ns1__investigationType::investigations), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__investigationType::name), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__investigationType::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__investigationType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigationType *SOAP_FMAC4 soap_in_ns1__investigationType(struct soap *soap, const char *tag,
                                                                             ns1__investigationType *a,
                                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__investigationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__investigationType,
                                                    sizeof(ns1__investigationType), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__investigationType) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__investigationType *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__investigationType::description),
                                         "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__investigationType::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigation(
                soap, "investigations", &(a->ns1__investigationType::investigations), "ns1:investigation"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__investigationType::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__investigationType *)soap_id_forward(soap, soap->href, (void *)a, 0,
                                                  SOAP_TYPE_ICat4_ns1__investigationType, 0,
                                                  sizeof(ns1__investigationType), 0, soap_copy_ns1__investigationType);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__investigationType::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__investigationType);
  if (this->soap_out(soap, tag ? tag : "ns1:investigationType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__investigationType::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__investigationType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigationType *SOAP_FMAC4 soap_get_ns1__investigationType(struct soap *soap,
                                                                              ns1__investigationType *p,
                                                                              const char *tag, const char *type) {
  if ((p = soap_in_ns1__investigationType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__investigationType *SOAP_FMAC2 soap_instantiate_ns1__investigationType(struct soap *soap, int n,
                                                                                      const char *type,
                                                                                      const char *arrayType,
                                                                                      size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigationType(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__investigationType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__investigationType);
    if (size)
      *size = sizeof(ns1__investigationType);
    ((ns1__investigationType *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationType, n);
    if (size)
      *size = n * sizeof(ns1__investigationType);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__investigationType *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__investigationType *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigationType(struct soap *soap, int st, int tt, void *p, size_t len,
                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigationType %p -> %p\n", q, p));
  *(ns1__investigationType *)p = *(ns1__investigationType *)q;
}

void ns1__investigationInstrument::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__investigationInstrument::instrument = nullptr;
  this->ns1__investigationInstrument::investigation = nullptr;
}

void ns1__investigationInstrument::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__instrument(soap, &this->ns1__investigationInstrument::instrument);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__investigationInstrument::investigation);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__investigationInstrument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__investigationInstrument(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationInstrument(struct soap *soap, const char *tag, int id,
                                                                const ns1__investigationInstrument *a,
                                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__investigationInstrument),
                             "ns1:investigationInstrument"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__instrument(soap, "instrument", -1, &(a->ns1__investigationInstrument::instrument), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__investigationInstrument::investigation),
                                           ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__investigationInstrument::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__investigationInstrument(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigationInstrument *SOAP_FMAC4 soap_in_ns1__investigationInstrument(
    struct soap *soap, const char *tag, ns1__investigationInstrument *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__investigationInstrument *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4_ns1__investigationInstrument, sizeof(ns1__investigationInstrument), soap->type,
      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__investigationInstrument) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__investigationInstrument *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_instrument1 = 1;
  size_t soap_flag_investigation1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__instrument(soap, "instrument", &(a->ns1__investigationInstrument::instrument),
                                             "ns1:instrument")) {
          soap_flag_instrument1--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(
                soap, "investigation", &(a->ns1__investigationInstrument::investigation), "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__investigationInstrument *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__investigationInstrument, 0,
        sizeof(ns1__investigationInstrument), 0, soap_copy_ns1__investigationInstrument);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__investigationInstrument::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__investigationInstrument);
  if (this->soap_out(soap, tag ? tag : "ns1:investigationInstrument", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__investigationInstrument::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__investigationInstrument(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigationInstrument *SOAP_FMAC4 soap_get_ns1__investigationInstrument(
    struct soap *soap, ns1__investigationInstrument *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__investigationInstrument(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__investigationInstrument *SOAP_FMAC2 soap_instantiate_ns1__investigationInstrument(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigationInstrument(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__investigationInstrument, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__investigationInstrument);
    if (size)
      *size = sizeof(ns1__investigationInstrument);
    ((ns1__investigationInstrument *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationInstrument, n);
    if (size)
      *size = n * sizeof(ns1__investigationInstrument);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__investigationInstrument *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__investigationInstrument *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigationInstrument(struct soap *soap, int st, int tt, void *p,
                                                                  size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigationInstrument %p -> %p\n", q, p));
  *(ns1__investigationInstrument *)p = *(ns1__investigationInstrument *)q;
}

void ns1__rule::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__rule::crudFlags = nullptr;
  this->ns1__rule::grouping = nullptr;
  this->ns1__rule::what = nullptr;
}

void ns1__rule::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__rule::crudFlags);
  soap_serialize_PointerTons1__grouping(soap, &this->ns1__rule::grouping);
  soap_serialize_PointerTostd__string(soap, &this->ns1__rule::what);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__rule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__rule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__rule(struct soap *soap, const char *tag, int id, const ns1__rule *a,
                                             const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__rule), "ns1:rule"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "crudFlags", -1, &(a->ns1__rule::crudFlags), ""))
    return soap->error;
  if (soap_out_PointerTons1__grouping(soap, "grouping", -1, &(a->ns1__rule::grouping), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "what", -1, &(a->ns1__rule::what), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__rule::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__rule(soap, tag, this, type);
}

SOAP_FMAC3 ns1__rule *SOAP_FMAC4 soap_in_ns1__rule(struct soap *soap, const char *tag, ns1__rule *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__rule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__rule, sizeof(ns1__rule), soap->type,
                                       soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__rule) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__rule *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_crudFlags1 = 1;
  size_t soap_flag_grouping1 = 1;
  size_t soap_flag_what1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_crudFlags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "crudFlags", &(a->ns1__rule::crudFlags), "xsd:string")) {
          soap_flag_crudFlags1--;
          continue;
        }
      if (soap_flag_grouping1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__grouping(soap, "grouping", &(a->ns1__rule::grouping), "ns1:grouping")) {
          soap_flag_grouping1--;
          continue;
        }
      if (soap_flag_what1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "what", &(a->ns1__rule::what), "xsd:string")) {
          soap_flag_what1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__rule *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__rule, 0, sizeof(ns1__rule), 0,
                                     soap_copy_ns1__rule);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__rule::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__rule);
  if (this->soap_out(soap, tag ? tag : "ns1:rule", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__rule::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__rule(soap, this, tag, type);
}

SOAP_FMAC3 ns1__rule *SOAP_FMAC4 soap_get_ns1__rule(struct soap *soap, ns1__rule *p, const char *tag,
                                                    const char *type) {
  if ((p = soap_in_ns1__rule(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__rule *SOAP_FMAC2 soap_instantiate_ns1__rule(struct soap *soap, int n, const char *type,
                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__rule(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__rule, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__rule);
    if (size)
      *size = sizeof(ns1__rule);
    ((ns1__rule *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__rule, n);
    if (size)
      *size = n * sizeof(ns1__rule);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__rule *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__rule *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__rule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                               size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__rule %p -> %p\n", q, p));
  *(ns1__rule *)p = *(ns1__rule *)q;
}

void ns1__grouping::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__grouping::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__rule(soap, &this->ns1__grouping::rules);
  soap_default_std__vectorTemplateOfPointerTons1__userGroup(soap, &this->ns1__grouping::userGroups);
}

void ns1__grouping::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__grouping::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__rule(soap, &this->ns1__grouping::rules);
  soap_serialize_std__vectorTemplateOfPointerTons1__userGroup(soap, &this->ns1__grouping::userGroups);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__grouping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__grouping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__grouping(struct soap *soap, const char *tag, int id, const ns1__grouping *a,
                                                 const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__grouping), "ns1:grouping"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__grouping::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__rule(soap, "rules", -1, &(a->ns1__grouping::rules), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__userGroup(soap, "userGroups", -1, &(a->ns1__grouping::userGroups),
                                                            ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__grouping::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__grouping(soap, tag, this, type);
}

SOAP_FMAC3 ns1__grouping *SOAP_FMAC4 soap_in_ns1__grouping(struct soap *soap, const char *tag, ns1__grouping *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__grouping *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__grouping, sizeof(ns1__grouping),
                                           soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__grouping) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__grouping *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__grouping::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__rule(soap, "rules", &(a->ns1__grouping::rules), "ns1:rule"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__userGroup(soap, "userGroups", &(a->ns1__grouping::userGroups),
                                                                 "ns1:userGroup"))
          continue;
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__grouping *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__grouping, 0,
                                         sizeof(ns1__grouping), 0, soap_copy_ns1__grouping);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__grouping::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__grouping);
  if (this->soap_out(soap, tag ? tag : "ns1:grouping", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__grouping::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__grouping(soap, this, tag, type);
}

SOAP_FMAC3 ns1__grouping *SOAP_FMAC4 soap_get_ns1__grouping(struct soap *soap, ns1__grouping *p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_ns1__grouping(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__grouping *SOAP_FMAC2 soap_instantiate_ns1__grouping(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__grouping(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__grouping, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__grouping);
    if (size)
      *size = sizeof(ns1__grouping);
    ((ns1__grouping *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__grouping, n);
    if (size)
      *size = n * sizeof(ns1__grouping);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__grouping *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__grouping *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__grouping(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__grouping %p -> %p\n", q, p));
  *(ns1__grouping *)p = *(ns1__grouping *)q;
}

void ns1__userGroup::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__userGroup::grouping = nullptr;
  this->ns1__userGroup::user = nullptr;
}

void ns1__userGroup::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__grouping(soap, &this->ns1__userGroup::grouping);
  soap_serialize_PointerTons1__user(soap, &this->ns1__userGroup::user);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__userGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__userGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userGroup(struct soap *soap, const char *tag, int id, const ns1__userGroup *a,
                                                  const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__userGroup), "ns1:userGroup"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__grouping(soap, "grouping", -1, &(a->ns1__userGroup::grouping), ""))
    return soap->error;
  if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__userGroup::user), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__userGroup::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__userGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userGroup *SOAP_FMAC4 soap_in_ns1__userGroup(struct soap *soap, const char *tag, ns1__userGroup *a,
                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__userGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__userGroup, sizeof(ns1__userGroup),
                                            soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__userGroup) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__userGroup *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_grouping1 = 1;
  size_t soap_flag_user1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_grouping1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__grouping(soap, "grouping", &(a->ns1__userGroup::grouping), "ns1:grouping")) {
          soap_flag_grouping1--;
          continue;
        }
      if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__userGroup::user), "ns1:user")) {
          soap_flag_user1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__userGroup *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__userGroup, 0,
                                          sizeof(ns1__userGroup), 0, soap_copy_ns1__userGroup);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__userGroup::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__userGroup);
  if (this->soap_out(soap, tag ? tag : "ns1:userGroup", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__userGroup::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__userGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userGroup *SOAP_FMAC4 soap_get_ns1__userGroup(struct soap *soap, ns1__userGroup *p, const char *tag,
                                                              const char *type) {
  if ((p = soap_in_ns1__userGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__userGroup *SOAP_FMAC2 soap_instantiate_ns1__userGroup(struct soap *soap, int n, const char *type,
                                                                      const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__userGroup(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__userGroup, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__userGroup);
    if (size)
      *size = sizeof(ns1__userGroup);
    ((ns1__userGroup *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__userGroup, n);
    if (size)
      *size = n * sizeof(ns1__userGroup);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__userGroup *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__userGroup *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__userGroup(struct soap *soap, int st, int tt, void *p, size_t len,
                                                    const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__userGroup %p -> %p\n", q, p));
  *(ns1__userGroup *)p = *(ns1__userGroup *)q;
}

void ns1__studyInvestigation::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__studyInvestigation::investigation = nullptr;
  this->ns1__studyInvestigation::study = nullptr;
}

void ns1__studyInvestigation::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__studyInvestigation::investigation);
  soap_serialize_PointerTons1__study(soap, &this->ns1__studyInvestigation::study);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__studyInvestigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__studyInvestigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__studyInvestigation(struct soap *soap, const char *tag, int id,
                                                           const ns1__studyInvestigation *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__studyInvestigation),
                             "ns1:studyInvestigation"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__studyInvestigation::investigation), ""))
    return soap->error;
  if (soap_out_PointerTons1__study(soap, "study", -1, &(a->ns1__studyInvestigation::study), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__studyInvestigation::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__studyInvestigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__studyInvestigation *SOAP_FMAC4 soap_in_ns1__studyInvestigation(struct soap *soap, const char *tag,
                                                                               ns1__studyInvestigation *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__studyInvestigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__studyInvestigation,
                                                     sizeof(ns1__studyInvestigation), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__studyInvestigation) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__studyInvestigation *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_study1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__studyInvestigation::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_study1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__study(soap, "study", &(a->ns1__studyInvestigation::study), "ns1:study")) {
          soap_flag_study1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__studyInvestigation *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__studyInvestigation, 0, sizeof(ns1__studyInvestigation), 0,
        soap_copy_ns1__studyInvestigation);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__studyInvestigation::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__studyInvestigation);
  if (this->soap_out(soap, tag ? tag : "ns1:studyInvestigation", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__studyInvestigation::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__studyInvestigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__studyInvestigation *SOAP_FMAC4 soap_get_ns1__studyInvestigation(struct soap *soap,
                                                                                ns1__studyInvestigation *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in_ns1__studyInvestigation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__studyInvestigation *SOAP_FMAC2 soap_instantiate_ns1__studyInvestigation(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__studyInvestigation(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__studyInvestigation, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__studyInvestigation);
    if (size)
      *size = sizeof(ns1__studyInvestigation);
    ((ns1__studyInvestigation *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__studyInvestigation, n);
    if (size)
      *size = n * sizeof(ns1__studyInvestigation);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__studyInvestigation *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__studyInvestigation *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__studyInvestigation(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__studyInvestigation %p -> %p\n", q, p));
  *(ns1__studyInvestigation *)p = *(ns1__studyInvestigation *)q;
}

void ns1__study::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__study::description = nullptr;
  this->ns1__study::name = nullptr;
  this->ns1__study::startDate = nullptr;
  this->ns1__study::status = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, &this->ns1__study::studyInvestigations);
  this->ns1__study::user = nullptr;
}

void ns1__study::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__study::description);
  soap_serialize_PointerTostd__string(soap, &this->ns1__study::name);
  soap_serialize_PointerTotime(soap, &this->ns1__study::startDate);
  soap_serialize_PointerTons1__studyStatus(soap, &this->ns1__study::status);
  soap_serialize_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, &this->ns1__study::studyInvestigations);
  soap_serialize_PointerTons1__user(soap, &this->ns1__study::user);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__study::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__study(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__study(struct soap *soap, const char *tag, int id, const ns1__study *a,
                                              const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__study), "ns1:study"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__study::description), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__study::name), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__study::startDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__studyStatus(soap, "status", -1, &(a->ns1__study::status), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, "studyInvestigations", -1,
                                                                     &(a->ns1__study::studyInvestigations), ""))
    return soap->error;
  if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__study::user), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__study::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__study(soap, tag, this, type);
}

SOAP_FMAC3 ns1__study *SOAP_FMAC4 soap_in_ns1__study(struct soap *soap, const char *tag, ns1__study *a,
                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__study *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__study, sizeof(ns1__study), soap->type,
                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__study) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__study *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_startDate1 = 1;
  size_t soap_flag_status1 = 1;
  size_t soap_flag_user1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__study::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__study::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__study::startDate), "xsd:dateTime")) {
          soap_flag_startDate1--;
          continue;
        }
      if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__studyStatus(soap, "status", &(a->ns1__study::status), "ns1:studyStatus")) {
          soap_flag_status1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__studyInvestigation(
                soap, "studyInvestigations", &(a->ns1__study::studyInvestigations), "ns1:studyInvestigation"))
          continue;
      if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__study::user), "ns1:user")) {
          soap_flag_user1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__study *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__study, 0, sizeof(ns1__study),
                                      0, soap_copy_ns1__study);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__study::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__study);
  if (this->soap_out(soap, tag ? tag : "ns1:study", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__study::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__study(soap, this, tag, type);
}

SOAP_FMAC3 ns1__study *SOAP_FMAC4 soap_get_ns1__study(struct soap *soap, ns1__study *p, const char *tag,
                                                      const char *type) {
  if ((p = soap_in_ns1__study(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__study *SOAP_FMAC2 soap_instantiate_ns1__study(struct soap *soap, int n, const char *type,
                                                              const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__study(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__study, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__study);
    if (size)
      *size = sizeof(ns1__study);
    ((ns1__study *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__study, n);
    if (size)
      *size = n * sizeof(ns1__study);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__study *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__study *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__study(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__study %p -> %p\n", q, p));
  *(ns1__study *)p = *(ns1__study *)q;
}

void ns1__investigationUser::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__investigationUser::investigation = nullptr;
  this->ns1__investigationUser::role = nullptr;
  this->ns1__investigationUser::user = nullptr;
}

void ns1__investigationUser::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__investigationUser::investigation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigationUser::role);
  soap_serialize_PointerTons1__user(soap, &this->ns1__investigationUser::user);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__investigationUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__investigationUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigationUser(struct soap *soap, const char *tag, int id,
                                                          const ns1__investigationUser *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__investigationUser),
                             "ns1:investigationUser"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__investigationUser::investigation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "role", -1, &(a->ns1__investigationUser::role), ""))
    return soap->error;
  if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__investigationUser::user), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__investigationUser::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__investigationUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigationUser *SOAP_FMAC4 soap_in_ns1__investigationUser(struct soap *soap, const char *tag,
                                                                             ns1__investigationUser *a,
                                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__investigationUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__investigationUser,
                                                    sizeof(ns1__investigationUser), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__investigationUser) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__investigationUser *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_role1 = 1;
  size_t soap_flag_user1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__investigationUser::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_role1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "role", &(a->ns1__investigationUser::role), "xsd:string")) {
          soap_flag_role1--;
          continue;
        }
      if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__investigationUser::user), "ns1:user")) {
          soap_flag_user1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__investigationUser *)soap_id_forward(soap, soap->href, (void *)a, 0,
                                                  SOAP_TYPE_ICat4_ns1__investigationUser, 0,
                                                  sizeof(ns1__investigationUser), 0, soap_copy_ns1__investigationUser);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__investigationUser::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__investigationUser);
  if (this->soap_out(soap, tag ? tag : "ns1:investigationUser", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__investigationUser::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__investigationUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigationUser *SOAP_FMAC4 soap_get_ns1__investigationUser(struct soap *soap,
                                                                              ns1__investigationUser *p,
                                                                              const char *tag, const char *type) {
  if ((p = soap_in_ns1__investigationUser(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__investigationUser *SOAP_FMAC2 soap_instantiate_ns1__investigationUser(struct soap *soap, int n,
                                                                                      const char *type,
                                                                                      const char *arrayType,
                                                                                      size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigationUser(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__investigationUser, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__investigationUser);
    if (size)
      *size = sizeof(ns1__investigationUser);
    ((ns1__investigationUser *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationUser, n);
    if (size)
      *size = n * sizeof(ns1__investigationUser);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__investigationUser *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__investigationUser *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigationUser(struct soap *soap, int st, int tt, void *p, size_t len,
                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigationUser %p -> %p\n", q, p));
  *(ns1__investigationUser *)p = *(ns1__investigationUser *)q;
}

void ns1__user::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__user::fullName = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, &this->ns1__user::instrumentScientists);
  soap_default_std__vectorTemplateOfPointerTons1__investigationUser(soap, &this->ns1__user::investigationUsers);
  this->ns1__user::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__study(soap, &this->ns1__user::studies);
  soap_default_std__vectorTemplateOfPointerTons1__userGroup(soap, &this->ns1__user::userGroups);
}

void ns1__user::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__user::fullName);
  soap_serialize_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, &this->ns1__user::instrumentScientists);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationUser(soap, &this->ns1__user::investigationUsers);
  soap_serialize_PointerTostd__string(soap, &this->ns1__user::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__study(soap, &this->ns1__user::studies);
  soap_serialize_std__vectorTemplateOfPointerTons1__userGroup(soap, &this->ns1__user::userGroups);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user(struct soap *soap, const char *tag, int id, const ns1__user *a,
                                             const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__user), "ns1:user"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "fullName", -1, &(a->ns1__user::fullName), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, "instrumentScientists", -1,
                                                                      &(a->ns1__user::instrumentScientists), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationUser(soap, "investigationUsers", -1,
                                                                    &(a->ns1__user::investigationUsers), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__user::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__study(soap, "studies", -1, &(a->ns1__user::studies), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__userGroup(soap, "userGroups", -1, &(a->ns1__user::userGroups), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__user::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__user(soap, tag, this, type);
}

SOAP_FMAC3 ns1__user *SOAP_FMAC4 soap_in_ns1__user(struct soap *soap, const char *tag, ns1__user *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__user, sizeof(ns1__user), soap->type,
                                       soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__user) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__user *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_fullName1 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "fullName", &(a->ns1__user::fullName), "xsd:string")) {
          soap_flag_fullName1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__instrumentScientist(
                soap, "instrumentScientists", &(a->ns1__user::instrumentScientists), "ns1:instrumentScientist"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationUser(
                soap, "investigationUsers", &(a->ns1__user::investigationUsers), "ns1:investigationUser"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__user::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__study(soap, "studies", &(a->ns1__user::studies), "ns1:study"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__userGroup(soap, "userGroups", &(a->ns1__user::userGroups),
                                                                 "ns1:userGroup"))
          continue;
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__user *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__user, 0, sizeof(ns1__user), 0,
                                     soap_copy_ns1__user);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__user::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__user);
  if (this->soap_out(soap, tag ? tag : "ns1:user", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__user::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__user(soap, this, tag, type);
}

SOAP_FMAC3 ns1__user *SOAP_FMAC4 soap_get_ns1__user(struct soap *soap, ns1__user *p, const char *tag,
                                                    const char *type) {
  if ((p = soap_in_ns1__user(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__user *SOAP_FMAC2 soap_instantiate_ns1__user(struct soap *soap, int n, const char *type,
                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__user(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__user, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__user);
    if (size)
      *size = sizeof(ns1__user);
    ((ns1__user *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__user, n);
    if (size)
      *size = n * sizeof(ns1__user);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__user *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__user *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                               size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__user %p -> %p\n", q, p));
  *(ns1__user *)p = *(ns1__user *)q;
}

void ns1__instrumentScientist::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__instrumentScientist::instrument = nullptr;
  this->ns1__instrumentScientist::user = nullptr;
}

void ns1__instrumentScientist::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__instrument(soap, &this->ns1__instrumentScientist::instrument);
  soap_serialize_PointerTons1__user(soap, &this->ns1__instrumentScientist::user);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__instrumentScientist::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__instrumentScientist(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__instrumentScientist(struct soap *soap, const char *tag, int id,
                                                            const ns1__instrumentScientist *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__instrumentScientist),
                             "ns1:instrumentScientist"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__instrument(soap, "instrument", -1, &(a->ns1__instrumentScientist::instrument), ""))
    return soap->error;
  if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__instrumentScientist::user), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__instrumentScientist::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__instrumentScientist(soap, tag, this, type);
}

SOAP_FMAC3 ns1__instrumentScientist *SOAP_FMAC4 soap_in_ns1__instrumentScientist(struct soap *soap, const char *tag,
                                                                                 ns1__instrumentScientist *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__instrumentScientist *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__instrumentScientist,
                                                      sizeof(ns1__instrumentScientist), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__instrumentScientist) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__instrumentScientist *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_instrument1 = 1;
  size_t soap_flag_user1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_instrument1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__instrument(soap, "instrument", &(a->ns1__instrumentScientist::instrument),
                                             "ns1:instrument")) {
          soap_flag_instrument1--;
          continue;
        }
      if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__instrumentScientist::user), "ns1:user")) {
          soap_flag_user1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__instrumentScientist *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__instrumentScientist, 0, sizeof(ns1__instrumentScientist),
        0, soap_copy_ns1__instrumentScientist);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__instrumentScientist::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__instrumentScientist);
  if (this->soap_out(soap, tag ? tag : "ns1:instrumentScientist", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__instrumentScientist::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__instrumentScientist(soap, this, tag, type);
}

SOAP_FMAC3 ns1__instrumentScientist *SOAP_FMAC4 soap_get_ns1__instrumentScientist(struct soap *soap,
                                                                                  ns1__instrumentScientist *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__instrumentScientist(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__instrumentScientist *SOAP_FMAC2 soap_instantiate_ns1__instrumentScientist(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__instrumentScientist(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__instrumentScientist, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__instrumentScientist);
    if (size)
      *size = sizeof(ns1__instrumentScientist);
    ((ns1__instrumentScientist *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrumentScientist, n);
    if (size)
      *size = n * sizeof(ns1__instrumentScientist);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__instrumentScientist *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__instrumentScientist *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__instrumentScientist(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__instrumentScientist %p -> %p\n", q, p));
  *(ns1__instrumentScientist *)p = *(ns1__instrumentScientist *)q;
}

void ns1__instrument::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__instrument::description = nullptr;
  this->ns1__instrument::facility = nullptr;
  this->ns1__instrument::fullName = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__instrumentScientist(soap,
                                                                      &this->ns1__instrument::instrumentScientists);
  soap_default_std__vectorTemplateOfPointerTons1__investigationInstrument(
      soap, &this->ns1__instrument::investigationInstruments);
  this->ns1__instrument::name = nullptr;
  this->ns1__instrument::type = nullptr;
  this->ns1__instrument::url = nullptr;
}

void ns1__instrument::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__instrument::description);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__instrument::facility);
  soap_serialize_PointerTostd__string(soap, &this->ns1__instrument::fullName);
  soap_serialize_std__vectorTemplateOfPointerTons1__instrumentScientist(soap,
                                                                        &this->ns1__instrument::instrumentScientists);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationInstrument(
      soap, &this->ns1__instrument::investigationInstruments);
  soap_serialize_PointerTostd__string(soap, &this->ns1__instrument::name);
  soap_serialize_PointerTostd__string(soap, &this->ns1__instrument::type);
  soap_serialize_PointerTostd__string(soap, &this->ns1__instrument::url);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__instrument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__instrument(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__instrument(struct soap *soap, const char *tag, int id, const ns1__instrument *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__instrument),
                             "ns1:instrument"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__instrument::description), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__instrument::facility), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "fullName", -1, &(a->ns1__instrument::fullName), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, "instrumentScientists", -1,
                                                                      &(a->ns1__instrument::instrumentScientists), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationInstrument(
          soap, "investigationInstruments", -1, &(a->ns1__instrument::investigationInstruments), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__instrument::name), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "type", -1, &(a->ns1__instrument::type), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "url", -1, &(a->ns1__instrument::url), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__instrument::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__instrument(soap, tag, this, type);
}

SOAP_FMAC3 ns1__instrument *SOAP_FMAC4 soap_in_ns1__instrument(struct soap *soap, const char *tag, ns1__instrument *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__instrument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__instrument,
                                             sizeof(ns1__instrument), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__instrument) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__instrument *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_fullName1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_type1 = 1;
  size_t soap_flag_url1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__instrument::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__instrument::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "fullName", &(a->ns1__instrument::fullName), "xsd:string")) {
          soap_flag_fullName1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__instrumentScientist(
                soap, "instrumentScientists", &(a->ns1__instrument::instrumentScientists), "ns1:instrumentScientist"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationInstrument(
                soap, "investigationInstruments", &(a->ns1__instrument::investigationInstruments),
                "ns1:investigationInstrument"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__instrument::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "type", &(a->ns1__instrument::type), "xsd:string")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "url", &(a->ns1__instrument::url), "xsd:string")) {
          soap_flag_url1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__instrument *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__instrument, 0,
                                           sizeof(ns1__instrument), 0, soap_copy_ns1__instrument);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__instrument::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__instrument);
  if (this->soap_out(soap, tag ? tag : "ns1:instrument", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__instrument::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__instrument(soap, this, tag, type);
}

SOAP_FMAC3 ns1__instrument *SOAP_FMAC4 soap_get_ns1__instrument(struct soap *soap, ns1__instrument *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__instrument(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__instrument *SOAP_FMAC2 soap_instantiate_ns1__instrument(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__instrument(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__instrument, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__instrument);
    if (size)
      *size = sizeof(ns1__instrument);
    ((ns1__instrument *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrument, n);
    if (size)
      *size = n * sizeof(ns1__instrument);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__instrument *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__instrument *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__instrument(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__instrument %p -> %p\n", q, p));
  *(ns1__instrument *)p = *(ns1__instrument *)q;
}

void ns1__facilityCycle::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__facilityCycle::description = nullptr;
  this->ns1__facilityCycle::endDate = nullptr;
  this->ns1__facilityCycle::facility = nullptr;
  this->ns1__facilityCycle::name = nullptr;
  this->ns1__facilityCycle::startDate = nullptr;
}

void ns1__facilityCycle::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__facilityCycle::description);
  soap_serialize_PointerTotime(soap, &this->ns1__facilityCycle::endDate);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__facilityCycle::facility);
  soap_serialize_PointerTostd__string(soap, &this->ns1__facilityCycle::name);
  soap_serialize_PointerTotime(soap, &this->ns1__facilityCycle::startDate);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__facilityCycle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__facilityCycle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__facilityCycle(struct soap *soap, const char *tag, int id,
                                                      const ns1__facilityCycle *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__facilityCycle),
                             "ns1:facilityCycle"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__facilityCycle::description), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__facilityCycle::endDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__facilityCycle::facility), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__facilityCycle::name), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__facilityCycle::startDate), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__facilityCycle::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__facilityCycle(soap, tag, this, type);
}

SOAP_FMAC3 ns1__facilityCycle *SOAP_FMAC4 soap_in_ns1__facilityCycle(struct soap *soap, const char *tag,
                                                                     ns1__facilityCycle *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__facilityCycle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__facilityCycle,
                                                sizeof(ns1__facilityCycle), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__facilityCycle) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__facilityCycle *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_endDate1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_startDate1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__facilityCycle::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__facilityCycle::endDate), "xsd:dateTime")) {
          soap_flag_endDate1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__facilityCycle::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__facilityCycle::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__facilityCycle::startDate), "xsd:dateTime")) {
          soap_flag_startDate1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__facilityCycle *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__facilityCycle, 0,
                                              sizeof(ns1__facilityCycle), 0, soap_copy_ns1__facilityCycle);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__facilityCycle::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__facilityCycle);
  if (this->soap_out(soap, tag ? tag : "ns1:facilityCycle", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__facilityCycle::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__facilityCycle(soap, this, tag, type);
}

SOAP_FMAC3 ns1__facilityCycle *SOAP_FMAC4 soap_get_ns1__facilityCycle(struct soap *soap, ns1__facilityCycle *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__facilityCycle(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__facilityCycle *SOAP_FMAC2 soap_instantiate_ns1__facilityCycle(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__facilityCycle(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__facilityCycle, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__facilityCycle);
    if (size)
      *size = sizeof(ns1__facilityCycle);
    ((ns1__facilityCycle *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facilityCycle, n);
    if (size)
      *size = n * sizeof(ns1__facilityCycle);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__facilityCycle *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__facilityCycle *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__facilityCycle(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__facilityCycle %p -> %p\n", q, p));
  *(ns1__facilityCycle *)p = *(ns1__facilityCycle *)q;
}

void ns1__datasetType::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__datasetType::datasets);
  this->ns1__datasetType::description = nullptr;
  this->ns1__datasetType::facility = nullptr;
  this->ns1__datasetType::name = nullptr;
}

void ns1__datasetType::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__datasetType::datasets);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datasetType::description);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__datasetType::facility);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datasetType::name);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__datasetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__datasetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datasetType(struct soap *soap, const char *tag, int id,
                                                    const ns1__datasetType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__datasetType),
                             "ns1:datasetType"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", -1, &(a->ns1__datasetType::datasets), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datasetType::description), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__datasetType::facility), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datasetType::name), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__datasetType::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__datasetType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datasetType *SOAP_FMAC4 soap_in_ns1__datasetType(struct soap *soap, const char *tag,
                                                                 ns1__datasetType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__datasetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__datasetType,
                                              sizeof(ns1__datasetType), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__datasetType) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__datasetType *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", &(a->ns1__datasetType::datasets),
                                                               "ns1:dataset"))
          continue;
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datasetType::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__datasetType::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datasetType::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__datasetType *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__datasetType, 0,
                                            sizeof(ns1__datasetType), 0, soap_copy_ns1__datasetType);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__datasetType::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__datasetType);
  if (this->soap_out(soap, tag ? tag : "ns1:datasetType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__datasetType::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__datasetType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datasetType *SOAP_FMAC4 soap_get_ns1__datasetType(struct soap *soap, ns1__datasetType *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__datasetType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__datasetType *SOAP_FMAC2 soap_instantiate_ns1__datasetType(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datasetType(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__datasetType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__datasetType);
    if (size)
      *size = sizeof(ns1__datasetType);
    ((ns1__datasetType *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetType, n);
    if (size)
      *size = n * sizeof(ns1__datasetType);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__datasetType *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__datasetType *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datasetType(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datasetType %p -> %p\n", q, p));
  *(ns1__datasetType *)p = *(ns1__datasetType *)q;
}

void ns1__datafileFormat::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__datafileFormat::datafiles);
  this->ns1__datafileFormat::description = nullptr;
  this->ns1__datafileFormat::facility = nullptr;
  this->ns1__datafileFormat::name = nullptr;
  this->ns1__datafileFormat::type = nullptr;
  this->ns1__datafileFormat::version = nullptr;
}

void ns1__datafileFormat::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__datafileFormat::datafiles);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::description);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__datafileFormat::facility);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::name);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::type);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafileFormat::version);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__datafileFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__datafileFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafileFormat(struct soap *soap, const char *tag, int id,
                                                       const ns1__datafileFormat *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__datafileFormat),
                             "ns1:datafileFormat"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "datafiles", -1, &(a->ns1__datafileFormat::datafiles),
                                                           ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datafileFormat::description), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__datafileFormat::facility), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datafileFormat::name), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "type", -1, &(a->ns1__datafileFormat::type), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "version", -1, &(a->ns1__datafileFormat::version), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__datafileFormat::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__datafileFormat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafileFormat *SOAP_FMAC4 soap_in_ns1__datafileFormat(struct soap *soap, const char *tag,
                                                                       ns1__datafileFormat *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__datafileFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__datafileFormat,
                                                 sizeof(ns1__datafileFormat), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__datafileFormat) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__datafileFormat *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_type1 = 1;
  size_t soap_flag_version1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "datafiles", &(a->ns1__datafileFormat::datafiles),
                                                                "ns1:datafile"))
          continue;
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datafileFormat::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__datafileFormat::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datafileFormat::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "type", &(a->ns1__datafileFormat::type), "xsd:string")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "version", &(a->ns1__datafileFormat::version), "xsd:string")) {
          soap_flag_version1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__datafileFormat *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__datafileFormat, 0,
                                               sizeof(ns1__datafileFormat), 0, soap_copy_ns1__datafileFormat);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__datafileFormat::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__datafileFormat);
  if (this->soap_out(soap, tag ? tag : "ns1:datafileFormat", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__datafileFormat::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__datafileFormat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafileFormat *SOAP_FMAC4 soap_get_ns1__datafileFormat(struct soap *soap, ns1__datafileFormat *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__datafileFormat(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__datafileFormat *SOAP_FMAC2 soap_instantiate_ns1__datafileFormat(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafileFormat(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__datafileFormat, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__datafileFormat);
    if (size)
      *size = sizeof(ns1__datafileFormat);
    ((ns1__datafileFormat *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileFormat, n);
    if (size)
      *size = n * sizeof(ns1__datafileFormat);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__datafileFormat *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__datafileFormat *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafileFormat(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafileFormat %p -> %p\n", q, p));
  *(ns1__datafileFormat *)p = *(ns1__datafileFormat *)q;
}

void ns1__job::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__job::application = nullptr;
  this->ns1__job::arguments = nullptr;
  this->ns1__job::inputDataCollection = nullptr;
  this->ns1__job::outputDataCollection = nullptr;
}

void ns1__job::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__application(soap, &this->ns1__job::application);
  soap_serialize_PointerTostd__string(soap, &this->ns1__job::arguments);
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__job::inputDataCollection);
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__job::outputDataCollection);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__job::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__job(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__job(struct soap *soap, const char *tag, int id, const ns1__job *a,
                                            const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__job), "ns1:job"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__application(soap, "application", -1, &(a->ns1__job::application), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "arguments", -1, &(a->ns1__job::arguments), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "inputDataCollection", -1, &(a->ns1__job::inputDataCollection), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "outputDataCollection", -1, &(a->ns1__job::outputDataCollection), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__job::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__job(soap, tag, this, type);
}

SOAP_FMAC3 ns1__job *SOAP_FMAC4 soap_in_ns1__job(struct soap *soap, const char *tag, ns1__job *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__job *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__job, sizeof(ns1__job), soap->type,
                                      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__job) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__job *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_application1 = 1;
  size_t soap_flag_arguments1 = 1;
  size_t soap_flag_inputDataCollection1 = 1;
  size_t soap_flag_outputDataCollection1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_application1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__application(soap, "application", &(a->ns1__job::application), "ns1:application")) {
          soap_flag_application1--;
          continue;
        }
      if (soap_flag_arguments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "arguments", &(a->ns1__job::arguments), "xsd:string")) {
          soap_flag_arguments1--;
          continue;
        }
      if (soap_flag_inputDataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(soap, "inputDataCollection", &(a->ns1__job::inputDataCollection),
                                                 "ns1:dataCollection")) {
          soap_flag_inputDataCollection1--;
          continue;
        }
      if (soap_flag_outputDataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(soap, "outputDataCollection", &(a->ns1__job::outputDataCollection),
                                                 "ns1:dataCollection")) {
          soap_flag_outputDataCollection1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__job *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__job, 0, sizeof(ns1__job), 0,
                                    soap_copy_ns1__job);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__job::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__job);
  if (this->soap_out(soap, tag ? tag : "ns1:job", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__job::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__job(soap, this, tag, type);
}

SOAP_FMAC3 ns1__job *SOAP_FMAC4 soap_get_ns1__job(struct soap *soap, ns1__job *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__job(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__job *SOAP_FMAC2 soap_instantiate_ns1__job(struct soap *soap, int n, const char *type,
                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__job(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__job, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__job);
    if (size)
      *size = sizeof(ns1__job);
    ((ns1__job *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__job, n);
    if (size)
      *size = n * sizeof(ns1__job);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__job *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__job *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__job(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__job %p -> %p\n", q, p));
  *(ns1__job *)p = *(ns1__job *)q;
}

void ns1__application::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__application::facility = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__application::jobs);
  this->ns1__application::name = nullptr;
  this->ns1__application::version = nullptr;
}

void ns1__application::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__facility(soap, &this->ns1__application::facility);
  soap_serialize_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__application::jobs);
  soap_serialize_PointerTostd__string(soap, &this->ns1__application::name);
  soap_serialize_PointerTostd__string(soap, &this->ns1__application::version);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__application(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__application(struct soap *soap, const char *tag, int id,
                                                    const ns1__application *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__application),
                             "ns1:application"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__application::facility), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__job(soap, "jobs", -1, &(a->ns1__application::jobs), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__application::name), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "version", -1, &(a->ns1__application::version), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__application::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__application(soap, tag, this, type);
}

SOAP_FMAC3 ns1__application *SOAP_FMAC4 soap_in_ns1__application(struct soap *soap, const char *tag,
                                                                 ns1__application *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__application,
                                              sizeof(ns1__application), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__application) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__application *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_version1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__application::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__job(soap, "jobs", &(a->ns1__application::jobs), "ns1:job"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__application::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "version", &(a->ns1__application::version), "xsd:string")) {
          soap_flag_version1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__application *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__application, 0,
                                            sizeof(ns1__application), 0, soap_copy_ns1__application);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__application::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__application);
  if (this->soap_out(soap, tag ? tag : "ns1:application", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__application::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__application(soap, this, tag, type);
}

SOAP_FMAC3 ns1__application *SOAP_FMAC4 soap_get_ns1__application(struct soap *soap, ns1__application *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__application(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__application *SOAP_FMAC2 soap_instantiate_ns1__application(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__application(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__application, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__application);
    if (size)
      *size = sizeof(ns1__application);
    ((ns1__application *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__application, n);
    if (size)
      *size = n * sizeof(ns1__application);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__application *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__application *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__application(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__application %p -> %p\n", q, p));
  *(ns1__application *)p = *(ns1__application *)q;
}

void ns1__facility::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__application(soap, &this->ns1__facility::applications);
  soap_default_std__vectorTemplateOfPointerTons1__datafileFormat(soap, &this->ns1__facility::datafileFormats);
  soap_default_std__vectorTemplateOfPointerTons1__datasetType(soap, &this->ns1__facility::datasetTypes);
  this->ns1__facility::daysUntilRelease = nullptr;
  this->ns1__facility::description = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__facilityCycle(soap, &this->ns1__facility::facilityCycles);
  this->ns1__facility::fullName = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__instrument(soap, &this->ns1__facility::instruments);
  soap_default_std__vectorTemplateOfPointerTons1__investigationType(soap, &this->ns1__facility::investigationTypes);
  soap_default_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__facility::investigations);
  this->ns1__facility::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__parameterType(soap, &this->ns1__facility::parameterTypes);
  soap_default_std__vectorTemplateOfPointerTons1__sampleType(soap, &this->ns1__facility::sampleTypes);
  this->ns1__facility::url = nullptr;
}

void ns1__facility::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__application(soap, &this->ns1__facility::applications);
  soap_serialize_std__vectorTemplateOfPointerTons1__datafileFormat(soap, &this->ns1__facility::datafileFormats);
  soap_serialize_std__vectorTemplateOfPointerTons1__datasetType(soap, &this->ns1__facility::datasetTypes);
  soap_serialize_PointerToint(soap, &this->ns1__facility::daysUntilRelease);
  soap_serialize_PointerTostd__string(soap, &this->ns1__facility::description);
  soap_serialize_std__vectorTemplateOfPointerTons1__facilityCycle(soap, &this->ns1__facility::facilityCycles);
  soap_serialize_PointerTostd__string(soap, &this->ns1__facility::fullName);
  soap_serialize_std__vectorTemplateOfPointerTons1__instrument(soap, &this->ns1__facility::instruments);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationType(soap, &this->ns1__facility::investigationTypes);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigation(soap, &this->ns1__facility::investigations);
  soap_serialize_PointerTostd__string(soap, &this->ns1__facility::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__parameterType(soap, &this->ns1__facility::parameterTypes);
  soap_serialize_std__vectorTemplateOfPointerTons1__sampleType(soap, &this->ns1__facility::sampleTypes);
  soap_serialize_PointerTostd__string(soap, &this->ns1__facility::url);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__facility::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__facility(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__facility(struct soap *soap, const char *tag, int id, const ns1__facility *a,
                                                 const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__facility), "ns1:facility"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__application(soap, "applications", -1,
                                                              &(a->ns1__facility::applications), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datafileFormat(soap, "datafileFormats", -1,
                                                                 &(a->ns1__facility::datafileFormats), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datasetType(soap, "datasetTypes", -1,
                                                              &(a->ns1__facility::datasetTypes), ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "daysUntilRelease", -1, &(a->ns1__facility::daysUntilRelease), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__facility::description), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__facilityCycle(soap, "facilityCycles", -1,
                                                                &(a->ns1__facility::facilityCycles), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "fullName", -1, &(a->ns1__facility::fullName), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__instrument(soap, "instruments", -1, &(a->ns1__facility::instruments),
                                                             ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationType(soap, "investigationTypes", -1,
                                                                    &(a->ns1__facility::investigationTypes), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigation(soap, "investigations", -1,
                                                                &(a->ns1__facility::investigations), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__facility::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__parameterType(soap, "parameterTypes", -1,
                                                                &(a->ns1__facility::parameterTypes), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__sampleType(soap, "sampleTypes", -1, &(a->ns1__facility::sampleTypes),
                                                             ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "url", -1, &(a->ns1__facility::url), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__facility::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__facility(soap, tag, this, type);
}

SOAP_FMAC3 ns1__facility *SOAP_FMAC4 soap_in_ns1__facility(struct soap *soap, const char *tag, ns1__facility *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__facility *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__facility, sizeof(ns1__facility),
                                           soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__facility) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__facility *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_daysUntilRelease1 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_fullName1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_url1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__application(
                soap, "applications", &(a->ns1__facility::applications), "ns1:application"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datafileFormat(
                soap, "datafileFormats", &(a->ns1__facility::datafileFormats), "ns1:datafileFormat"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datasetType(
                soap, "datasetTypes", &(a->ns1__facility::datasetTypes), "ns1:datasetType"))
          continue;
      if (soap_flag_daysUntilRelease1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "daysUntilRelease", &(a->ns1__facility::daysUntilRelease), "xsd:int")) {
          soap_flag_daysUntilRelease1--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__facility::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__facilityCycle(
                soap, "facilityCycles", &(a->ns1__facility::facilityCycles), "ns1:facilityCycle"))
          continue;
      if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "fullName", &(a->ns1__facility::fullName), "xsd:string")) {
          soap_flag_fullName1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__instrument(soap, "instruments", &(a->ns1__facility::instruments),
                                                                  "ns1:instrument"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationType(
                soap, "investigationTypes", &(a->ns1__facility::investigationTypes), "ns1:investigationType"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigation(
                soap, "investigations", &(a->ns1__facility::investigations), "ns1:investigation"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__facility::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__parameterType(
                soap, "parameterTypes", &(a->ns1__facility::parameterTypes), "ns1:parameterType"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__sampleType(soap, "sampleTypes", &(a->ns1__facility::sampleTypes),
                                                                  "ns1:sampleType"))
          continue;
      if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "url", &(a->ns1__facility::url), "xsd:string")) {
          soap_flag_url1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__facility *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__facility, 0,
                                         sizeof(ns1__facility), 0, soap_copy_ns1__facility);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__facility::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__facility);
  if (this->soap_out(soap, tag ? tag : "ns1:facility", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__facility::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__facility(soap, this, tag, type);
}

SOAP_FMAC3 ns1__facility *SOAP_FMAC4 soap_get_ns1__facility(struct soap *soap, ns1__facility *p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_ns1__facility(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__facility *SOAP_FMAC2 soap_instantiate_ns1__facility(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__facility(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__facility, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__facility);
    if (size)
      *size = sizeof(ns1__facility);
    ((ns1__facility *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facility, n);
    if (size)
      *size = n * sizeof(ns1__facility);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__facility *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__facility *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__facility(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__facility %p -> %p\n", q, p));
  *(ns1__facility *)p = *(ns1__facility *)q;
}

void ns1__investigation::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__investigation::datasets);
  this->ns1__investigation::doi = nullptr;
  this->ns1__investigation::endDate = nullptr;
  this->ns1__investigation::facility = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__investigationInstrument(
      soap, &this->ns1__investigation::investigationInstruments);
  soap_default_std__vectorTemplateOfPointerTons1__investigationUser(soap,
                                                                    &this->ns1__investigation::investigationUsers);
  soap_default_std__vectorTemplateOfPointerTons1__keyword(soap, &this->ns1__investigation::keywords);
  this->ns1__investigation::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__investigationParameter(soap, &this->ns1__investigation::parameters);
  soap_default_std__vectorTemplateOfPointerTons1__publication(soap, &this->ns1__investigation::publications);
  this->ns1__investigation::releaseDate = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__investigation::samples);
  soap_default_std__vectorTemplateOfPointerTons1__shift(soap, &this->ns1__investigation::shifts);
  this->ns1__investigation::startDate = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__studyInvestigation(soap,
                                                                     &this->ns1__investigation::studyInvestigations);
  this->ns1__investigation::summary = nullptr;
  this->ns1__investigation::title = nullptr;
  this->ns1__investigation::type = nullptr;
  this->ns1__investigation::visitId = nullptr;
}

void ns1__investigation::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataset(soap, &this->ns1__investigation::datasets);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::doi);
  soap_serialize_PointerTotime(soap, &this->ns1__investigation::endDate);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__investigation::facility);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationInstrument(
      soap, &this->ns1__investigation::investigationInstruments);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationUser(soap,
                                                                      &this->ns1__investigation::investigationUsers);
  soap_serialize_std__vectorTemplateOfPointerTons1__keyword(soap, &this->ns1__investigation::keywords);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__investigationParameter(soap, &this->ns1__investigation::parameters);
  soap_serialize_std__vectorTemplateOfPointerTons1__publication(soap, &this->ns1__investigation::publications);
  soap_serialize_PointerTotime(soap, &this->ns1__investigation::releaseDate);
  soap_serialize_std__vectorTemplateOfPointerTons1__sample(soap, &this->ns1__investigation::samples);
  soap_serialize_std__vectorTemplateOfPointerTons1__shift(soap, &this->ns1__investigation::shifts);
  soap_serialize_PointerTotime(soap, &this->ns1__investigation::startDate);
  soap_serialize_std__vectorTemplateOfPointerTons1__studyInvestigation(soap,
                                                                       &this->ns1__investigation::studyInvestigations);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::summary);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::title);
  soap_serialize_PointerTons1__investigationType(soap, &this->ns1__investigation::type);
  soap_serialize_PointerTostd__string(soap, &this->ns1__investigation::visitId);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__investigation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__investigation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__investigation(struct soap *soap, const char *tag, int id,
                                                      const ns1__investigation *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__investigation),
                             "ns1:investigation"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", -1, &(a->ns1__investigation::datasets), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "doi", -1, &(a->ns1__investigation::doi), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__investigation::endDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "facility", -1, &(a->ns1__investigation::facility), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationInstrument(
          soap, "investigationInstruments", -1, &(a->ns1__investigation::investigationInstruments), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationUser(soap, "investigationUsers", -1,
                                                                    &(a->ns1__investigation::investigationUsers), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__keyword(soap, "keywords", -1, &(a->ns1__investigation::keywords), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__investigation::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__investigationParameter(soap, "parameters", -1,
                                                                         &(a->ns1__investigation::parameters), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__publication(soap, "publications", -1,
                                                              &(a->ns1__investigation::publications), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "releaseDate", -1, &(a->ns1__investigation::releaseDate), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__sample(soap, "samples", -1, &(a->ns1__investigation::samples), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__shift(soap, "shifts", -1, &(a->ns1__investigation::shifts), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__investigation::startDate), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, "studyInvestigations", -1,
                                                                     &(a->ns1__investigation::studyInvestigations), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "summary", -1, &(a->ns1__investigation::summary), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "title", -1, &(a->ns1__investigation::title), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigationType(soap, "type", -1, &(a->ns1__investigation::type), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "visitId", -1, &(a->ns1__investigation::visitId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__investigation::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__investigation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__investigation *SOAP_FMAC4 soap_in_ns1__investigation(struct soap *soap, const char *tag,
                                                                     ns1__investigation *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__investigation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__investigation,
                                                sizeof(ns1__investigation), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__investigation) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__investigation *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_doi1 = 1;
  size_t soap_flag_endDate1 = 1;
  size_t soap_flag_facility1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_releaseDate1 = 1;
  size_t soap_flag_startDate1 = 1;
  size_t soap_flag_summary1 = 1;
  size_t soap_flag_title1 = 1;
  size_t soap_flag_type1 = 1;
  size_t soap_flag_visitId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataset(soap, "datasets", &(a->ns1__investigation::datasets),
                                                               "ns1:dataset"))
          continue;
      if (soap_flag_doi1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "doi", &(a->ns1__investigation::doi), "xsd:string")) {
          soap_flag_doi1--;
          continue;
        }
      if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__investigation::endDate), "xsd:dateTime")) {
          soap_flag_endDate1--;
          continue;
        }
      if (soap_flag_facility1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "facility", &(a->ns1__investigation::facility), "ns1:facility")) {
          soap_flag_facility1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationInstrument(
                soap, "investigationInstruments", &(a->ns1__investigation::investigationInstruments),
                "ns1:investigationInstrument"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationUser(
                soap, "investigationUsers", &(a->ns1__investigation::investigationUsers), "ns1:investigationUser"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__keyword(soap, "keywords", &(a->ns1__investigation::keywords),
                                                               "ns1:keyword"))
          continue;
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__investigation::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__investigationParameter(
                soap, "parameters", &(a->ns1__investigation::parameters), "ns1:investigationParameter"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__publication(
                soap, "publications", &(a->ns1__investigation::publications), "ns1:publication"))
          continue;
      if (soap_flag_releaseDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "releaseDate", &(a->ns1__investigation::releaseDate), "xsd:dateTime")) {
          soap_flag_releaseDate1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__sample(soap, "samples", &(a->ns1__investigation::samples),
                                                              "ns1:sample"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__shift(soap, "shifts", &(a->ns1__investigation::shifts),
                                                             "ns1:shift"))
          continue;
      if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__investigation::startDate), "xsd:dateTime")) {
          soap_flag_startDate1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__studyInvestigation(
                soap, "studyInvestigations", &(a->ns1__investigation::studyInvestigations), "ns1:studyInvestigation"))
          continue;
      if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "summary", &(a->ns1__investigation::summary), "xsd:string")) {
          soap_flag_summary1--;
          continue;
        }
      if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "title", &(a->ns1__investigation::title), "xsd:string")) {
          soap_flag_title1--;
          continue;
        }
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigationType(soap, "type", &(a->ns1__investigation::type),
                                                    "ns1:investigationType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag_visitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "visitId", &(a->ns1__investigation::visitId), "xsd:string")) {
          soap_flag_visitId1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__investigation *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__investigation, 0,
                                              sizeof(ns1__investigation), 0, soap_copy_ns1__investigation);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__investigation::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__investigation);
  if (this->soap_out(soap, tag ? tag : "ns1:investigation", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__investigation::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__investigation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__investigation *SOAP_FMAC4 soap_get_ns1__investigation(struct soap *soap, ns1__investigation *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__investigation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__investigation *SOAP_FMAC2 soap_instantiate_ns1__investigation(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__investigation(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__investigation, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__investigation);
    if (size)
      *size = sizeof(ns1__investigation);
    ((ns1__investigation *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigation, n);
    if (size)
      *size = n * sizeof(ns1__investigation);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__investigation *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__investigation *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__investigation(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__investigation %p -> %p\n", q, p));
  *(ns1__investigation *)p = *(ns1__investigation *)q;
}

void ns1__dataset::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_bool(soap, &this->ns1__dataset::complete);
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap,
                                                                        &this->ns1__dataset::dataCollectionDatasets);
  soap_default_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__dataset::datafiles);
  this->ns1__dataset::description = nullptr;
  this->ns1__dataset::doi = nullptr;
  this->ns1__dataset::endDate = nullptr;
  this->ns1__dataset::investigation = nullptr;
  this->ns1__dataset::location = nullptr;
  this->ns1__dataset::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__dataset::parameters);
  this->ns1__dataset::sample = nullptr;
  this->ns1__dataset::startDate = nullptr;
  this->ns1__dataset::type = nullptr;
}

void ns1__dataset::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap,
                                                                          &this->ns1__dataset::dataCollectionDatasets);
  soap_serialize_std__vectorTemplateOfPointerTons1__datafile(soap, &this->ns1__dataset::datafiles);
  soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::description);
  soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::doi);
  soap_serialize_PointerTotime(soap, &this->ns1__dataset::endDate);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__dataset::investigation);
  soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::location);
  soap_serialize_PointerTostd__string(soap, &this->ns1__dataset::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(soap, &this->ns1__dataset::parameters);
  soap_serialize_PointerTons1__sample(soap, &this->ns1__dataset::sample);
  soap_serialize_PointerTotime(soap, &this->ns1__dataset::startDate);
  soap_serialize_PointerTons1__datasetType(soap, &this->ns1__dataset::type);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataset(struct soap *soap, const char *tag, int id, const ns1__dataset *a,
                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dataset), "ns1:dataset"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_bool(soap, "complete", -1, &(a->ns1__dataset::complete), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap, "dataCollectionDatasets", -1,
                                                                        &(a->ns1__dataset::dataCollectionDatasets), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datafile(soap, "datafiles", -1, &(a->ns1__dataset::datafiles), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__dataset::description), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "doi", -1, &(a->ns1__dataset::doi), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__dataset::endDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "investigation", -1, &(a->ns1__dataset::investigation), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "location", -1, &(a->ns1__dataset::location), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__dataset::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(soap, "parameters", -1,
                                                                   &(a->ns1__dataset::parameters), ""))
    return soap->error;
  if (soap_out_PointerTons1__sample(soap, "sample", -1, &(a->ns1__dataset::sample), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__dataset::startDate), ""))
    return soap->error;
  if (soap_out_PointerTons1__datasetType(soap, "type", -1, &(a->ns1__dataset::type), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dataset::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dataset(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataset *SOAP_FMAC4 soap_in_ns1__dataset(struct soap *soap, const char *tag, ns1__dataset *a,
                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dataset, sizeof(ns1__dataset),
                                          soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dataset) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dataset *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_complete1 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_doi1 = 1;
  size_t soap_flag_endDate1 = 1;
  size_t soap_flag_investigation1 = 1;
  size_t soap_flag_location1 = 1;
  size_t soap_flag_name1 = 1;
  size_t soap_flag_sample1 = 1;
  size_t soap_flag_startDate1 = 1;
  size_t soap_flag_type1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_complete1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_bool(soap, "complete", &(a->ns1__dataset::complete), "xsd:boolean")) {
          soap_flag_complete1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap, "dataCollectionDatasets",
                                                                             &(a->ns1__dataset::dataCollectionDatasets),
                                                                             "ns1:dataCollectionDataset"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datafile(soap, "datafiles", &(a->ns1__dataset::datafiles),
                                                                "ns1:datafile"))
          continue;
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__dataset::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap_flag_doi1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "doi", &(a->ns1__dataset::doi), "xsd:string")) {
          soap_flag_doi1--;
          continue;
        }
      if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__dataset::endDate), "xsd:dateTime")) {
          soap_flag_endDate1--;
          continue;
        }
      if (soap_flag_investigation1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "investigation", &(a->ns1__dataset::investigation),
                                                "ns1:investigation")) {
          soap_flag_investigation1--;
          continue;
        }
      if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "location", &(a->ns1__dataset::location), "xsd:string")) {
          soap_flag_location1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__dataset::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(
                soap, "parameters", &(a->ns1__dataset::parameters), "ns1:datasetParameter"))
          continue;
      if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__sample(soap, "sample", &(a->ns1__dataset::sample), "ns1:sample")) {
          soap_flag_sample1--;
          continue;
        }
      if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__dataset::startDate), "xsd:dateTime")) {
          soap_flag_startDate1--;
          continue;
        }
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datasetType(soap, "type", &(a->ns1__dataset::type), "ns1:datasetType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dataset *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dataset, 0,
                                        sizeof(ns1__dataset), 0, soap_copy_ns1__dataset);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_complete1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__dataset::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dataset);
  if (this->soap_out(soap, tag ? tag : "ns1:dataset", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dataset::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dataset(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataset *SOAP_FMAC4 soap_get_ns1__dataset(struct soap *soap, ns1__dataset *p, const char *tag,
                                                          const char *type) {
  if ((p = soap_in_ns1__dataset(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dataset *SOAP_FMAC2 soap_instantiate_ns1__dataset(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataset(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dataset, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dataset);
    if (size)
      *size = sizeof(ns1__dataset);
    ((ns1__dataset *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataset, n);
    if (size)
      *size = n * sizeof(ns1__dataset);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dataset *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dataset *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataset %p -> %p\n", q, p));
  *(ns1__dataset *)p = *(ns1__dataset *)q;
}

void ns1__dataCollectionDataset::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__dataCollectionDataset::dataCollection = nullptr;
  this->ns1__dataCollectionDataset::dataset = nullptr;
}

void ns1__dataCollectionDataset::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__dataCollectionDataset::dataCollection);
  soap_serialize_PointerTons1__dataset(soap, &this->ns1__dataCollectionDataset::dataset);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dataCollectionDataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dataCollectionDataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataCollectionDataset(struct soap *soap, const char *tag, int id,
                                                              const ns1__dataCollectionDataset *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dataCollectionDataset),
                             "ns1:dataCollectionDataset"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "dataCollection", -1,
                                            &(a->ns1__dataCollectionDataset::dataCollection), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataset(soap, "dataset", -1, &(a->ns1__dataCollectionDataset::dataset), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dataCollectionDataset::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dataCollectionDataset(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataCollectionDataset *SOAP_FMAC4 soap_in_ns1__dataCollectionDataset(struct soap *soap, const char *tag,
                                                                                     ns1__dataCollectionDataset *a,
                                                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dataCollectionDataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dataCollectionDataset,
                                                        sizeof(ns1__dataCollectionDataset), soap->type,
                                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dataCollectionDataset) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dataCollectionDataset *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_dataCollection1 = 1;
  size_t soap_flag_dataset1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_dataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(
                soap, "dataCollection", &(a->ns1__dataCollectionDataset::dataCollection), "ns1:dataCollection")) {
          soap_flag_dataCollection1--;
          continue;
        }
      if (soap_flag_dataset1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataset(soap, "dataset", &(a->ns1__dataCollectionDataset::dataset), "ns1:dataset")) {
          soap_flag_dataset1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dataCollectionDataset *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dataCollectionDataset, 0,
        sizeof(ns1__dataCollectionDataset), 0, soap_copy_ns1__dataCollectionDataset);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__dataCollectionDataset::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dataCollectionDataset);
  if (this->soap_out(soap, tag ? tag : "ns1:dataCollectionDataset", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dataCollectionDataset::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dataCollectionDataset(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataCollectionDataset *SOAP_FMAC4 soap_get_ns1__dataCollectionDataset(struct soap *soap,
                                                                                      ns1__dataCollectionDataset *p,
                                                                                      const char *tag,
                                                                                      const char *type) {
  if ((p = soap_in_ns1__dataCollectionDataset(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dataCollectionDataset *SOAP_FMAC2 soap_instantiate_ns1__dataCollectionDataset(struct soap *soap, int n,
                                                                                              const char *type,
                                                                                              const char *arrayType,
                                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataCollectionDataset(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dataCollectionDataset, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDataset);
    if (size)
      *size = sizeof(ns1__dataCollectionDataset);
    ((ns1__dataCollectionDataset *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDataset, n);
    if (size)
      *size = n * sizeof(ns1__dataCollectionDataset);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dataCollectionDataset *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dataCollectionDataset *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataCollectionDataset(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataCollectionDataset %p -> %p\n", q, p));
  *(ns1__dataCollectionDataset *)p = *(ns1__dataCollectionDataset *)q;
}

void ns1__dataCollection::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
      soap, &this->ns1__dataCollection::dataCollectionDatafiles);
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
      soap, &this->ns1__dataCollection::dataCollectionDatasets);
  soap_default_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__dataCollection::jobsAsInput);
  soap_default_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__dataCollection::jobsAsOutput);
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionParameter(soap, &this->ns1__dataCollection::parameters);
}

void ns1__dataCollection::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
      soap, &this->ns1__dataCollection::dataCollectionDatafiles);
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
      soap, &this->ns1__dataCollection::dataCollectionDatasets);
  soap_serialize_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__dataCollection::jobsAsInput);
  soap_serialize_std__vectorTemplateOfPointerTons1__job(soap, &this->ns1__dataCollection::jobsAsOutput);
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionParameter(soap,
                                                                            &this->ns1__dataCollection::parameters);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dataCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dataCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataCollection(struct soap *soap, const char *tag, int id,
                                                       const ns1__dataCollection *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dataCollection),
                             "ns1:dataCollection"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
          soap, "dataCollectionDatafiles", -1, &(a->ns1__dataCollection::dataCollectionDatafiles), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
          soap, "dataCollectionDatasets", -1, &(a->ns1__dataCollection::dataCollectionDatasets), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__job(soap, "jobsAsInput", -1, &(a->ns1__dataCollection::jobsAsInput),
                                                      ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__job(soap, "jobsAsOutput", -1, &(a->ns1__dataCollection::jobsAsOutput),
                                                      ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionParameter(soap, "parameters", -1,
                                                                          &(a->ns1__dataCollection::parameters), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dataCollection::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dataCollection(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataCollection *SOAP_FMAC4 soap_in_ns1__dataCollection(struct soap *soap, const char *tag,
                                                                       ns1__dataCollection *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dataCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dataCollection,
                                                 sizeof(ns1__dataCollection), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dataCollection) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dataCollection *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
                soap, "dataCollectionDatafiles", &(a->ns1__dataCollection::dataCollectionDatafiles),
                "ns1:dataCollectionDatafile"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
                soap, "dataCollectionDatasets", &(a->ns1__dataCollection::dataCollectionDatasets),
                "ns1:dataCollectionDataset"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__job(soap, "jobsAsInput", &(a->ns1__dataCollection::jobsAsInput),
                                                           "ns1:job"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__job(soap, "jobsAsOutput",
                                                           &(a->ns1__dataCollection::jobsAsOutput), "ns1:job"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
                soap, "parameters", &(a->ns1__dataCollection::parameters), "ns1:dataCollectionParameter"))
          continue;
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dataCollection *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dataCollection, 0,
                                               sizeof(ns1__dataCollection), 0, soap_copy_ns1__dataCollection);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__dataCollection::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dataCollection);
  if (this->soap_out(soap, tag ? tag : "ns1:dataCollection", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dataCollection::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dataCollection(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataCollection *SOAP_FMAC4 soap_get_ns1__dataCollection(struct soap *soap, ns1__dataCollection *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__dataCollection(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dataCollection *SOAP_FMAC2 soap_instantiate_ns1__dataCollection(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataCollection(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dataCollection, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dataCollection);
    if (size)
      *size = sizeof(ns1__dataCollection);
    ((ns1__dataCollection *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollection, n);
    if (size)
      *size = n * sizeof(ns1__dataCollection);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dataCollection *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dataCollection *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataCollection(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataCollection %p -> %p\n", q, p));
  *(ns1__dataCollection *)p = *(ns1__dataCollection *)q;
}

void ns1__dataCollectionDatafile::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__dataCollectionDatafile::dataCollection = nullptr;
  this->ns1__dataCollectionDatafile::datafile = nullptr;
}

void ns1__dataCollectionDatafile::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__dataCollectionDatafile::dataCollection);
  soap_serialize_PointerTons1__datafile(soap, &this->ns1__dataCollectionDatafile::datafile);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dataCollectionDatafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dataCollectionDatafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dataCollectionDatafile(struct soap *soap, const char *tag, int id,
                                                               const ns1__dataCollectionDatafile *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile),
                             "ns1:dataCollectionDatafile"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "dataCollection", -1,
                                            &(a->ns1__dataCollectionDatafile::dataCollection), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafile(soap, "datafile", -1, &(a->ns1__dataCollectionDatafile::datafile), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dataCollectionDatafile::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dataCollectionDatafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dataCollectionDatafile *SOAP_FMAC4 soap_in_ns1__dataCollectionDatafile(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__dataCollectionDatafile *a,
                                                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dataCollectionDatafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile,
                                                         sizeof(ns1__dataCollectionDatafile), soap->type,
                                                         soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dataCollectionDatafile) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dataCollectionDatafile *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_dataCollection1 = 1;
  size_t soap_flag_datafile1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_dataCollection1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(
                soap, "dataCollection", &(a->ns1__dataCollectionDatafile::dataCollection), "ns1:dataCollection")) {
          soap_flag_dataCollection1--;
          continue;
        }
      if (soap_flag_datafile1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafile(soap, "datafile", &(a->ns1__dataCollectionDatafile::datafile),
                                           "ns1:datafile")) {
          soap_flag_datafile1--;
          continue;
        }
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dataCollectionDatafile *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile, 0,
        sizeof(ns1__dataCollectionDatafile), 0, soap_copy_ns1__dataCollectionDatafile);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__dataCollectionDatafile::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile);
  if (this->soap_out(soap, tag ? tag : "ns1:dataCollectionDatafile", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dataCollectionDatafile::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dataCollectionDatafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dataCollectionDatafile *SOAP_FMAC4 soap_get_ns1__dataCollectionDatafile(struct soap *soap,
                                                                                        ns1__dataCollectionDatafile *p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_ns1__dataCollectionDatafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dataCollectionDatafile *SOAP_FMAC2 soap_instantiate_ns1__dataCollectionDatafile(struct soap *soap,
                                                                                                int n, const char *type,
                                                                                                const char *arrayType,
                                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dataCollectionDatafile(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDatafile);
    if (size)
      *size = sizeof(ns1__dataCollectionDatafile);
    ((ns1__dataCollectionDatafile *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDatafile, n);
    if (size)
      *size = n * sizeof(ns1__dataCollectionDatafile);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dataCollectionDatafile *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dataCollectionDatafile *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dataCollectionDatafile(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dataCollectionDatafile %p -> %p\n", q, p));
  *(ns1__dataCollectionDatafile *)p = *(ns1__dataCollectionDatafile *)q;
}

void ns1__datafile::soap_default(struct soap *soap) {
  this->soap = soap;
  this->ns1__entityBaseBean::soap_default(soap);
  this->xsd__anyType::soap_default(soap);
  this->ns1__datafile::checksum = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(soap,
                                                                         &this->ns1__datafile::dataCollectionDatafiles);
  this->ns1__datafile::datafileCreateTime = nullptr;
  this->ns1__datafile::datafileFormat = nullptr;
  this->ns1__datafile::datafileModTime = nullptr;
  this->ns1__datafile::dataset = nullptr;
  this->ns1__datafile::description = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, &this->ns1__datafile::destDatafiles);
  this->ns1__datafile::doi = nullptr;
  this->ns1__datafile::fileSize = nullptr;
  this->ns1__datafile::location = nullptr;
  this->ns1__datafile::name = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__datafile::parameters);
  soap_default_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, &this->ns1__datafile::sourceDatafiles);
}

void ns1__datafile::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::checksum);
  soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
      soap, &this->ns1__datafile::dataCollectionDatafiles);
  soap_serialize_PointerTotime(soap, &this->ns1__datafile::datafileCreateTime);
  soap_serialize_PointerTons1__datafileFormat(soap, &this->ns1__datafile::datafileFormat);
  soap_serialize_PointerTotime(soap, &this->ns1__datafile::datafileModTime);
  soap_serialize_PointerTons1__dataset(soap, &this->ns1__datafile::dataset);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::description);
  soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, &this->ns1__datafile::destDatafiles);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::doi);
  soap_serialize_PointerToLONG64(soap, &this->ns1__datafile::fileSize);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::location);
  soap_serialize_PointerTostd__string(soap, &this->ns1__datafile::name);
  soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(soap, &this->ns1__datafile::parameters);
  soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, &this->ns1__datafile::sourceDatafiles);
  this->ns1__entityBaseBean::soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__datafile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__datafile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__datafile(struct soap *soap, const char *tag, int id, const ns1__datafile *a,
                                                 const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__datafile), "ns1:datafile"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "checksum", -1, &(a->ns1__datafile::checksum), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
          soap, "dataCollectionDatafiles", -1, &(a->ns1__datafile::dataCollectionDatafiles), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "datafileCreateTime", -1, &(a->ns1__datafile::datafileCreateTime), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafileFormat(soap, "datafileFormat", -1, &(a->ns1__datafile::datafileFormat), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "datafileModTime", -1, &(a->ns1__datafile::datafileModTime), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataset(soap, "dataset", -1, &(a->ns1__datafile::dataset), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__datafile::description), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, "destDatafiles", -1,
                                                                  &(a->ns1__datafile::destDatafiles), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "doi", -1, &(a->ns1__datafile::doi), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "fileSize", -1, &(a->ns1__datafile::fileSize), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "location", -1, &(a->ns1__datafile::location), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__datafile::name), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(soap, "parameters", -1,
                                                                    &(a->ns1__datafile::parameters), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, "sourceDatafiles", -1,
                                                                  &(a->ns1__datafile::sourceDatafiles), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__datafile::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__datafile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__datafile *SOAP_FMAC4 soap_in_ns1__datafile(struct soap *soap, const char *tag, ns1__datafile *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__datafile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__datafile, sizeof(ns1__datafile),
                                           soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__datafile) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__datafile *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item3 = 1;
  size_t soap_flag_createId2 = 1;
  size_t soap_flag_createTime2 = 1;
  size_t soap_flag_modTime2 = 1;
  size_t soap_flag_id2 = 1;
  size_t soap_flag_modId2 = 1;
  size_t soap_flag_checksum1 = 1;
  size_t soap_flag_datafileCreateTime1 = 1;
  size_t soap_flag_datafileFormat1 = 1;
  size_t soap_flag_datafileModTime1 = 1;
  size_t soap_flag_dataset1 = 1;
  size_t soap_flag_description1 = 1;
  size_t soap_flag_doi1 = 1;
  size_t soap_flag_fileSize1 = 1;
  size_t soap_flag_location1 = 1;
  size_t soap_flag_name1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId2--;
          continue;
        }
      if (soap_flag_createTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime2--;
          continue;
        }
      if (soap_flag_modTime2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime2--;
          continue;
        }
      if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id2--;
          continue;
        }
      if (soap_flag_modId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId2--;
          continue;
        }
      if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "checksum", &(a->ns1__datafile::checksum), "xsd:string")) {
          soap_flag_checksum1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
                soap, "dataCollectionDatafiles", &(a->ns1__datafile::dataCollectionDatafiles),
                "ns1:dataCollectionDatafile"))
          continue;
      if (soap_flag_datafileCreateTime1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "datafileCreateTime", &(a->ns1__datafile::datafileCreateTime),
                                  "xsd:dateTime")) {
          soap_flag_datafileCreateTime1--;
          continue;
        }
      if (soap_flag_datafileFormat1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafileFormat(soap, "datafileFormat", &(a->ns1__datafile::datafileFormat),
                                                 "ns1:datafileFormat")) {
          soap_flag_datafileFormat1--;
          continue;
        }
      if (soap_flag_datafileModTime1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "datafileModTime", &(a->ns1__datafile::datafileModTime), "xsd:dateTime")) {
          soap_flag_datafileModTime1--;
          continue;
        }
      if (soap_flag_dataset1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataset(soap, "dataset", &(a->ns1__datafile::dataset), "ns1:dataset")) {
          soap_flag_dataset1--;
          continue;
        }
      if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__datafile::description), "xsd:string")) {
          soap_flag_description1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__relatedDatafile(
                soap, "destDatafiles", &(a->ns1__datafile::destDatafiles), "ns1:relatedDatafile"))
          continue;
      if (soap_flag_doi1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "doi", &(a->ns1__datafile::doi), "xsd:string")) {
          soap_flag_doi1--;
          continue;
        }
      if (soap_flag_fileSize1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "fileSize", &(a->ns1__datafile::fileSize), "xsd:long")) {
          soap_flag_fileSize1--;
          continue;
        }
      if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "location", &(a->ns1__datafile::location), "xsd:string")) {
          soap_flag_location1--;
          continue;
        }
      if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__datafile::name), "xsd:string")) {
          soap_flag_name1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(
                soap, "parameters", &(a->ns1__datafile::parameters), "ns1:datafileParameter"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__relatedDatafile(
                soap, "sourceDatafiles", &(a->ns1__datafile::sourceDatafiles), "ns1:relatedDatafile"))
          continue;
      if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item3--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__datafile *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__datafile, 0,
                                         sizeof(ns1__datafile), 0, soap_copy_ns1__datafile);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__datafile::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__datafile);
  if (this->soap_out(soap, tag ? tag : "ns1:datafile", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__datafile::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__datafile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__datafile *SOAP_FMAC4 soap_get_ns1__datafile(struct soap *soap, ns1__datafile *p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_ns1__datafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__datafile *SOAP_FMAC2 soap_instantiate_ns1__datafile(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__datafile(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__datafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__datafile);
    if (size)
      *size = sizeof(ns1__datafile);
    ((ns1__datafile *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafile, n);
    if (size)
      *size = n * sizeof(ns1__datafile);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__datafile *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__datafile *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__datafile(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__datafile %p -> %p\n", q, p));
  *(ns1__datafile *)p = *(ns1__datafile *)q;
}

void ns1__dummy::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__dummy::arg0 = nullptr;
  this->ns1__dummy::arg1 = nullptr;
  this->ns1__dummy::arg2 = nullptr;
  this->ns1__dummy::arg3 = nullptr;
  this->ns1__dummy::arg4 = nullptr;
  this->ns1__dummy::arg5 = nullptr;
  this->ns1__dummy::arg6 = nullptr;
  this->ns1__dummy::arg7 = nullptr;
  this->ns1__dummy::arg8 = nullptr;
  this->ns1__dummy::arg9 = nullptr;
  this->ns1__dummy::arg10 = nullptr;
  this->ns1__dummy::arg11 = nullptr;
  this->ns1__dummy::arg12 = nullptr;
  this->ns1__dummy::arg13 = nullptr;
  this->ns1__dummy::arg14 = nullptr;
  this->ns1__dummy::arg15 = nullptr;
  this->ns1__dummy::arg16 = nullptr;
  this->ns1__dummy::arg17 = nullptr;
  this->ns1__dummy::arg18 = nullptr;
  this->ns1__dummy::arg19 = nullptr;
  this->ns1__dummy::arg20 = nullptr;
  this->ns1__dummy::arg21 = nullptr;
  this->ns1__dummy::arg22 = nullptr;
  this->ns1__dummy::arg23 = nullptr;
  this->ns1__dummy::arg24 = nullptr;
  this->ns1__dummy::arg25 = nullptr;
  this->ns1__dummy::arg26 = nullptr;
  this->ns1__dummy::arg27 = nullptr;
  this->ns1__dummy::arg28 = nullptr;
  this->ns1__dummy::arg29 = nullptr;
  this->ns1__dummy::arg30 = nullptr;
  this->ns1__dummy::arg31 = nullptr;
  this->ns1__dummy::arg32 = nullptr;
  this->ns1__dummy::arg33 = nullptr;
}

void ns1__dummy::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__datafile(soap, &this->ns1__dummy::arg0);
  soap_serialize_PointerTons1__datafileFormat(soap, &this->ns1__dummy::arg1);
  soap_serialize_PointerTons1__datafileParameter(soap, &this->ns1__dummy::arg2);
  soap_serialize_PointerTons1__dataset(soap, &this->ns1__dummy::arg3);
  soap_serialize_PointerTons1__datasetParameter(soap, &this->ns1__dummy::arg4);
  soap_serialize_PointerTons1__datasetType(soap, &this->ns1__dummy::arg5);
  soap_serialize_PointerTons1__facility(soap, &this->ns1__dummy::arg6);
  soap_serialize_PointerTons1__facilityCycle(soap, &this->ns1__dummy::arg7);
  soap_serialize_PointerTons1__instrumentScientist(soap, &this->ns1__dummy::arg8);
  soap_serialize_PointerTons1__user(soap, &this->ns1__dummy::arg9);
  soap_serialize_PointerTons1__instrument(soap, &this->ns1__dummy::arg10);
  soap_serialize_PointerTons1__investigation(soap, &this->ns1__dummy::arg11);
  soap_serialize_PointerTons1__investigationType(soap, &this->ns1__dummy::arg12);
  soap_serialize_PointerTons1__investigationUser(soap, &this->ns1__dummy::arg13);
  soap_serialize_PointerTons1__keyword(soap, &this->ns1__dummy::arg14);
  soap_serialize_PointerTons1__parameterType(soap, &this->ns1__dummy::arg15);
  soap_serialize_PointerTons1__publication(soap, &this->ns1__dummy::arg16);
  soap_serialize_PointerTons1__relatedDatafile(soap, &this->ns1__dummy::arg17);
  soap_serialize_PointerTons1__sample(soap, &this->ns1__dummy::arg18);
  soap_serialize_PointerTons1__sampleParameter(soap, &this->ns1__dummy::arg19);
  soap_serialize_PointerTons1__shift(soap, &this->ns1__dummy::arg20);
  soap_serialize_PointerTons1__study(soap, &this->ns1__dummy::arg21);
  soap_serialize_PointerTons1__studyInvestigation(soap, &this->ns1__dummy::arg22);
  soap_serialize_PointerTons1__studyStatus(soap, &this->ns1__dummy::arg23);
  soap_serialize_PointerTons1__application(soap, &this->ns1__dummy::arg24);
  soap_serialize_PointerTons1__job(soap, &this->ns1__dummy::arg25);
  soap_serialize_PointerTons1__dataCollection(soap, &this->ns1__dummy::arg26);
  soap_serialize_PointerTons1__dataCollectionParameter(soap, &this->ns1__dummy::arg27);
  soap_serialize_PointerTons1__dataCollectionDataset(soap, &this->ns1__dummy::arg28);
  soap_serialize_PointerTons1__dataCollectionDatafile(soap, &this->ns1__dummy::arg29);
  soap_serialize_PointerTons1__grouping(soap, &this->ns1__dummy::arg30);
  soap_serialize_PointerTons1__userGroup(soap, &this->ns1__dummy::arg31);
  soap_serialize_PointerTons1__log(soap, &this->ns1__dummy::arg32);
  soap_serialize_PointerTons1__publicStep(soap, &this->ns1__dummy::arg33);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__dummy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__dummy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dummy(struct soap *soap, const char *tag, int id, const ns1__dummy *a,
                                              const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__dummy), "ns1:dummy"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTons1__datafile(soap, "arg0", -1, &(a->ns1__dummy::arg0), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafileFormat(soap, "arg1", -1, &(a->ns1__dummy::arg1), ""))
    return soap->error;
  if (soap_out_PointerTons1__datafileParameter(soap, "arg2", -1, &(a->ns1__dummy::arg2), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataset(soap, "arg3", -1, &(a->ns1__dummy::arg3), ""))
    return soap->error;
  if (soap_out_PointerTons1__datasetParameter(soap, "arg4", -1, &(a->ns1__dummy::arg4), ""))
    return soap->error;
  if (soap_out_PointerTons1__datasetType(soap, "arg5", -1, &(a->ns1__dummy::arg5), ""))
    return soap->error;
  if (soap_out_PointerTons1__facility(soap, "arg6", -1, &(a->ns1__dummy::arg6), ""))
    return soap->error;
  if (soap_out_PointerTons1__facilityCycle(soap, "arg7", -1, &(a->ns1__dummy::arg7), ""))
    return soap->error;
  if (soap_out_PointerTons1__instrumentScientist(soap, "arg8", -1, &(a->ns1__dummy::arg8), ""))
    return soap->error;
  if (soap_out_PointerTons1__user(soap, "arg9", -1, &(a->ns1__dummy::arg9), ""))
    return soap->error;
  if (soap_out_PointerTons1__instrument(soap, "arg10", -1, &(a->ns1__dummy::arg10), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigation(soap, "arg11", -1, &(a->ns1__dummy::arg11), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigationType(soap, "arg12", -1, &(a->ns1__dummy::arg12), ""))
    return soap->error;
  if (soap_out_PointerTons1__investigationUser(soap, "arg13", -1, &(a->ns1__dummy::arg13), ""))
    return soap->error;
  if (soap_out_PointerTons1__keyword(soap, "arg14", -1, &(a->ns1__dummy::arg14), ""))
    return soap->error;
  if (soap_out_PointerTons1__parameterType(soap, "arg15", -1, &(a->ns1__dummy::arg15), ""))
    return soap->error;
  if (soap_out_PointerTons1__publication(soap, "arg16", -1, &(a->ns1__dummy::arg16), ""))
    return soap->error;
  if (soap_out_PointerTons1__relatedDatafile(soap, "arg17", -1, &(a->ns1__dummy::arg17), ""))
    return soap->error;
  if (soap_out_PointerTons1__sample(soap, "arg18", -1, &(a->ns1__dummy::arg18), ""))
    return soap->error;
  if (soap_out_PointerTons1__sampleParameter(soap, "arg19", -1, &(a->ns1__dummy::arg19), ""))
    return soap->error;
  if (soap_out_PointerTons1__shift(soap, "arg20", -1, &(a->ns1__dummy::arg20), ""))
    return soap->error;
  if (soap_out_PointerTons1__study(soap, "arg21", -1, &(a->ns1__dummy::arg21), ""))
    return soap->error;
  if (soap_out_PointerTons1__studyInvestigation(soap, "arg22", -1, &(a->ns1__dummy::arg22), ""))
    return soap->error;
  if (soap_out_PointerTons1__studyStatus(soap, "arg23", -1, &(a->ns1__dummy::arg23), ""))
    return soap->error;
  if (soap_out_PointerTons1__application(soap, "arg24", -1, &(a->ns1__dummy::arg24), ""))
    return soap->error;
  if (soap_out_PointerTons1__job(soap, "arg25", -1, &(a->ns1__dummy::arg25), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollection(soap, "arg26", -1, &(a->ns1__dummy::arg26), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollectionParameter(soap, "arg27", -1, &(a->ns1__dummy::arg27), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollectionDataset(soap, "arg28", -1, &(a->ns1__dummy::arg28), ""))
    return soap->error;
  if (soap_out_PointerTons1__dataCollectionDatafile(soap, "arg29", -1, &(a->ns1__dummy::arg29), ""))
    return soap->error;
  if (soap_out_PointerTons1__grouping(soap, "arg30", -1, &(a->ns1__dummy::arg30), ""))
    return soap->error;
  if (soap_out_PointerTons1__userGroup(soap, "arg31", -1, &(a->ns1__dummy::arg31), ""))
    return soap->error;
  if (soap_out_PointerTons1__log(soap, "arg32", -1, &(a->ns1__dummy::arg32), ""))
    return soap->error;
  if (soap_out_PointerTons1__publicStep(soap, "arg33", -1, &(a->ns1__dummy::arg33), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__dummy::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__dummy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dummy *SOAP_FMAC4 soap_in_ns1__dummy(struct soap *soap, const char *tag, ns1__dummy *a,
                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__dummy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__dummy, sizeof(ns1__dummy), soap->type,
                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__dummy) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__dummy *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_arg01 = 1;
  size_t soap_flag_arg11 = 1;
  size_t soap_flag_arg21 = 1;
  size_t soap_flag_arg31 = 1;
  size_t soap_flag_arg41 = 1;
  size_t soap_flag_arg51 = 1;
  size_t soap_flag_arg61 = 1;
  size_t soap_flag_arg71 = 1;
  size_t soap_flag_arg81 = 1;
  size_t soap_flag_arg91 = 1;
  size_t soap_flag_arg101 = 1;
  size_t soap_flag_arg111 = 1;
  size_t soap_flag_arg121 = 1;
  size_t soap_flag_arg131 = 1;
  size_t soap_flag_arg141 = 1;
  size_t soap_flag_arg151 = 1;
  size_t soap_flag_arg161 = 1;
  size_t soap_flag_arg171 = 1;
  size_t soap_flag_arg181 = 1;
  size_t soap_flag_arg191 = 1;
  size_t soap_flag_arg201 = 1;
  size_t soap_flag_arg211 = 1;
  size_t soap_flag_arg221 = 1;
  size_t soap_flag_arg231 = 1;
  size_t soap_flag_arg241 = 1;
  size_t soap_flag_arg251 = 1;
  size_t soap_flag_arg261 = 1;
  size_t soap_flag_arg271 = 1;
  size_t soap_flag_arg281 = 1;
  size_t soap_flag_arg291 = 1;
  size_t soap_flag_arg301 = 1;
  size_t soap_flag_arg311 = 1;
  size_t soap_flag_arg321 = 1;
  size_t soap_flag_arg331 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafile(soap, "arg0", &(a->ns1__dummy::arg0), "ns1:datafile")) {
          soap_flag_arg01--;
          continue;
        }
      if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafileFormat(soap, "arg1", &(a->ns1__dummy::arg1), "ns1:datafileFormat")) {
          soap_flag_arg11--;
          continue;
        }
      if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datafileParameter(soap, "arg2", &(a->ns1__dummy::arg2), "ns1:datafileParameter")) {
          soap_flag_arg21--;
          continue;
        }
      if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataset(soap, "arg3", &(a->ns1__dummy::arg3), "ns1:dataset")) {
          soap_flag_arg31--;
          continue;
        }
      if (soap_flag_arg41 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datasetParameter(soap, "arg4", &(a->ns1__dummy::arg4), "ns1:datasetParameter")) {
          soap_flag_arg41--;
          continue;
        }
      if (soap_flag_arg51 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__datasetType(soap, "arg5", &(a->ns1__dummy::arg5), "ns1:datasetType")) {
          soap_flag_arg51--;
          continue;
        }
      if (soap_flag_arg61 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facility(soap, "arg6", &(a->ns1__dummy::arg6), "ns1:facility")) {
          soap_flag_arg61--;
          continue;
        }
      if (soap_flag_arg71 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__facilityCycle(soap, "arg7", &(a->ns1__dummy::arg7), "ns1:facilityCycle")) {
          soap_flag_arg71--;
          continue;
        }
      if (soap_flag_arg81 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__instrumentScientist(soap, "arg8", &(a->ns1__dummy::arg8),
                                                      "ns1:instrumentScientist")) {
          soap_flag_arg81--;
          continue;
        }
      if (soap_flag_arg91 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__user(soap, "arg9", &(a->ns1__dummy::arg9), "ns1:user")) {
          soap_flag_arg91--;
          continue;
        }
      if (soap_flag_arg101 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__instrument(soap, "arg10", &(a->ns1__dummy::arg10), "ns1:instrument")) {
          soap_flag_arg101--;
          continue;
        }
      if (soap_flag_arg111 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigation(soap, "arg11", &(a->ns1__dummy::arg11), "ns1:investigation")) {
          soap_flag_arg111--;
          continue;
        }
      if (soap_flag_arg121 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigationType(soap, "arg12", &(a->ns1__dummy::arg12), "ns1:investigationType")) {
          soap_flag_arg121--;
          continue;
        }
      if (soap_flag_arg131 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__investigationUser(soap, "arg13", &(a->ns1__dummy::arg13), "ns1:investigationUser")) {
          soap_flag_arg131--;
          continue;
        }
      if (soap_flag_arg141 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__keyword(soap, "arg14", &(a->ns1__dummy::arg14), "ns1:keyword")) {
          soap_flag_arg141--;
          continue;
        }
      if (soap_flag_arg151 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__parameterType(soap, "arg15", &(a->ns1__dummy::arg15), "ns1:parameterType")) {
          soap_flag_arg151--;
          continue;
        }
      if (soap_flag_arg161 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__publication(soap, "arg16", &(a->ns1__dummy::arg16), "ns1:publication")) {
          soap_flag_arg161--;
          continue;
        }
      if (soap_flag_arg171 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__relatedDatafile(soap, "arg17", &(a->ns1__dummy::arg17), "ns1:relatedDatafile")) {
          soap_flag_arg171--;
          continue;
        }
      if (soap_flag_arg181 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__sample(soap, "arg18", &(a->ns1__dummy::arg18), "ns1:sample")) {
          soap_flag_arg181--;
          continue;
        }
      if (soap_flag_arg191 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__sampleParameter(soap, "arg19", &(a->ns1__dummy::arg19), "ns1:sampleParameter")) {
          soap_flag_arg191--;
          continue;
        }
      if (soap_flag_arg201 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__shift(soap, "arg20", &(a->ns1__dummy::arg20), "ns1:shift")) {
          soap_flag_arg201--;
          continue;
        }
      if (soap_flag_arg211 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__study(soap, "arg21", &(a->ns1__dummy::arg21), "ns1:study")) {
          soap_flag_arg211--;
          continue;
        }
      if (soap_flag_arg221 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__studyInvestigation(soap, "arg22", &(a->ns1__dummy::arg22),
                                                     "ns1:studyInvestigation")) {
          soap_flag_arg221--;
          continue;
        }
      if (soap_flag_arg231 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__studyStatus(soap, "arg23", &(a->ns1__dummy::arg23), "ns1:studyStatus")) {
          soap_flag_arg231--;
          continue;
        }
      if (soap_flag_arg241 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__application(soap, "arg24", &(a->ns1__dummy::arg24), "ns1:application")) {
          soap_flag_arg241--;
          continue;
        }
      if (soap_flag_arg251 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__job(soap, "arg25", &(a->ns1__dummy::arg25), "ns1:job")) {
          soap_flag_arg251--;
          continue;
        }
      if (soap_flag_arg261 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollection(soap, "arg26", &(a->ns1__dummy::arg26), "ns1:dataCollection")) {
          soap_flag_arg261--;
          continue;
        }
      if (soap_flag_arg271 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollectionParameter(soap, "arg27", &(a->ns1__dummy::arg27),
                                                          "ns1:dataCollectionParameter")) {
          soap_flag_arg271--;
          continue;
        }
      if (soap_flag_arg281 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollectionDataset(soap, "arg28", &(a->ns1__dummy::arg28),
                                                        "ns1:dataCollectionDataset")) {
          soap_flag_arg281--;
          continue;
        }
      if (soap_flag_arg291 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__dataCollectionDatafile(soap, "arg29", &(a->ns1__dummy::arg29),
                                                         "ns1:dataCollectionDatafile")) {
          soap_flag_arg291--;
          continue;
        }
      if (soap_flag_arg301 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__grouping(soap, "arg30", &(a->ns1__dummy::arg30), "ns1:grouping")) {
          soap_flag_arg301--;
          continue;
        }
      if (soap_flag_arg311 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userGroup(soap, "arg31", &(a->ns1__dummy::arg31), "ns1:userGroup")) {
          soap_flag_arg311--;
          continue;
        }
      if (soap_flag_arg321 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__log(soap, "arg32", &(a->ns1__dummy::arg32), "ns1:log")) {
          soap_flag_arg321--;
          continue;
        }
      if (soap_flag_arg331 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__publicStep(soap, "arg33", &(a->ns1__dummy::arg33), "ns1:publicStep")) {
          soap_flag_arg331--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__dummy *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__dummy, 0, sizeof(ns1__dummy),
                                      0, soap_copy_ns1__dummy);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__dummy::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__dummy);
  if (this->soap_out(soap, tag ? tag : "ns1:dummy", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__dummy::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__dummy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dummy *SOAP_FMAC4 soap_get_ns1__dummy(struct soap *soap, ns1__dummy *p, const char *tag,
                                                      const char *type) {
  if ((p = soap_in_ns1__dummy(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__dummy *SOAP_FMAC2 soap_instantiate_ns1__dummy(struct soap *soap, int n, const char *type,
                                                              const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dummy(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__dummy, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__dummy);
    if (size)
      *size = sizeof(ns1__dummy);
    ((ns1__dummy *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dummy, n);
    if (size)
      *size = n * sizeof(ns1__dummy);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__dummy *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__dummy *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dummy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dummy %p -> %p\n", q, p));
  *(ns1__dummy *)p = *(ns1__dummy *)q;
}

void ns1__loginResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__loginResponse::return_ = nullptr;
}

void ns1__loginResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__loginResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id,
                                                      const ns1__loginResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__loginResponse),
                             "ns1:loginResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__loginResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loginResponse *SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag,
                                                                     ns1__loginResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__loginResponse,
                                                sizeof(ns1__loginResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__loginResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__loginResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__loginResponse::return_), "xsd:string")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__loginResponse *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__loginResponse, 0,
                                              sizeof(ns1__loginResponse), 0, soap_copy_ns1__loginResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__loginResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:loginResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loginResponse *SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, ns1__loginResponse *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__loginResponse *SOAP_FMAC2 soap_instantiate_ns1__loginResponse(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loginResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__loginResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__loginResponse);
    if (size)
      *size = sizeof(ns1__loginResponse);
    ((ns1__loginResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__loginResponse, n);
    if (size)
      *size = n * sizeof(ns1__loginResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__loginResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__loginResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loginResponse %p -> %p\n", q, p));
  *(ns1__loginResponse *)p = *(ns1__loginResponse *)q;
}

void ns1__login::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__login::plugin = nullptr;
  this->ns1__login::credentials._ns1__login_credentials::soap_default(soap);
}

void ns1__login::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__login::plugin);
  this->ns1__login::credentials.soap_serialize(soap);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const ns1__login *a,
                                              const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__login), "ns1:login"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "plugin", -1, &(a->ns1__login::plugin), ""))
    return soap->error;
  if ((a->ns1__login::credentials).soap_out(soap, "credentials", -1, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__login::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 ns1__login *SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, ns1__login *a,
                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__login, sizeof(ns1__login), soap->type,
                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__login) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__login *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_plugin1 = 1;
  size_t soap_flag_credentials1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_plugin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "plugin", &(a->ns1__login::plugin), "xsd:string")) {
          soap_flag_plugin1--;
          continue;
        }
      if (soap_flag_credentials1 && soap->error == SOAP_TAG_MISMATCH)
        if ((a->ns1__login::credentials).soap_in(soap, "credentials", "")) {
          soap_flag_credentials1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__login *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__login, 0, sizeof(ns1__login),
                                      0, soap_copy_ns1__login);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_credentials1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__login::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__login);
  if (this->soap_out(soap, tag ? tag : "ns1:login", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__login::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 ns1__login *SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, ns1__login *p, const char *tag,
                                                      const char *type) {
  if ((p = soap_in_ns1__login(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__login *SOAP_FMAC2 soap_instantiate_ns1__login(struct soap *soap, int n, const char *type,
                                                              const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__login(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__login, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__login);
    if (size)
      *size = sizeof(ns1__login);
    ((ns1__login *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__login, n);
    if (size)
      *size = n * sizeof(ns1__login);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__login *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__login *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__login %p -> %p\n", q, p));
  *(ns1__login *)p = *(ns1__login *)q;
}

void ns1__refreshResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__refreshResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__refreshResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__refreshResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refreshResponse(struct soap *soap, const char *tag, int id,
                                                        const ns1__refreshResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:refreshResponse");
}

void *ns1__refreshResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__refreshResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__refreshResponse *SOAP_FMAC4 soap_in_ns1__refreshResponse(struct soap *soap, const char *tag,
                                                                         ns1__refreshResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__refreshResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__refreshResponse,
                                                        sizeof(ns1__refreshResponse), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__refreshResponse)
      return (ns1__refreshResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__refreshResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__refreshResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:refreshResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__refreshResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__refreshResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__refreshResponse *SOAP_FMAC4 soap_get_ns1__refreshResponse(struct soap *soap, ns1__refreshResponse *p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_ns1__refreshResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__refreshResponse *SOAP_FMAC2 soap_instantiate_ns1__refreshResponse(struct soap *soap, int n,
                                                                                  const char *type,
                                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__refreshResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__refreshResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__refreshResponse);
    if (size)
      *size = sizeof(ns1__refreshResponse);
    ((ns1__refreshResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__refreshResponse, n);
    if (size)
      *size = n * sizeof(ns1__refreshResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__refreshResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__refreshResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__refreshResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__refreshResponse %p -> %p\n", q, p));
  *(ns1__refreshResponse *)p = *(ns1__refreshResponse *)q;
}

void ns1__refresh::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__refresh::sessionId = nullptr;
}

void ns1__refresh::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__refresh::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__refresh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__refresh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refresh(struct soap *soap, const char *tag, int id, const ns1__refresh *a,
                                                const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__refresh), "ns1:refresh"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__refresh::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__refresh::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__refresh(soap, tag, this, type);
}

SOAP_FMAC3 ns1__refresh *SOAP_FMAC4 soap_in_ns1__refresh(struct soap *soap, const char *tag, ns1__refresh *a,
                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__refresh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__refresh, sizeof(ns1__refresh),
                                          soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__refresh) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__refresh *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__refresh::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__refresh *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__refresh, 0,
                                        sizeof(ns1__refresh), 0, soap_copy_ns1__refresh);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__refresh::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__refresh);
  if (this->soap_out(soap, tag ? tag : "ns1:refresh", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__refresh::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__refresh(soap, this, tag, type);
}

SOAP_FMAC3 ns1__refresh *SOAP_FMAC4 soap_get_ns1__refresh(struct soap *soap, ns1__refresh *p, const char *tag,
                                                          const char *type) {
  if ((p = soap_in_ns1__refresh(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__refresh *SOAP_FMAC2 soap_instantiate_ns1__refresh(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__refresh(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__refresh, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__refresh);
    if (size)
      *size = sizeof(ns1__refresh);
    ((ns1__refresh *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__refresh, n);
    if (size)
      *size = n * sizeof(ns1__refresh);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__refresh *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__refresh *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__refresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__refresh %p -> %p\n", q, p));
  *(ns1__refresh *)p = *(ns1__refresh *)q;
}

void ns1__getUserNameResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getUserNameResponse::return_ = nullptr;
}

void ns1__getUserNameResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getUserNameResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getUserNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getUserNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserNameResponse(struct soap *soap, const char *tag, int id,
                                                            const ns1__getUserNameResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getUserNameResponse),
                             "ns1:getUserNameResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getUserNameResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getUserNameResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getUserNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getUserNameResponse *SOAP_FMAC4 soap_in_ns1__getUserNameResponse(struct soap *soap, const char *tag,
                                                                                 ns1__getUserNameResponse *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getUserNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getUserNameResponse,
                                                      sizeof(ns1__getUserNameResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getUserNameResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getUserNameResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getUserNameResponse::return_), "xsd:string")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getUserNameResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getUserNameResponse, 0, sizeof(ns1__getUserNameResponse),
        0, soap_copy_ns1__getUserNameResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getUserNameResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getUserNameResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getUserNameResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getUserNameResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getUserNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getUserNameResponse *SOAP_FMAC4 soap_get_ns1__getUserNameResponse(struct soap *soap,
                                                                                  ns1__getUserNameResponse *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__getUserNameResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getUserNameResponse *SOAP_FMAC2 soap_instantiate_ns1__getUserNameResponse(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserNameResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getUserNameResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getUserNameResponse);
    if (size)
      *size = sizeof(ns1__getUserNameResponse);
    ((ns1__getUserNameResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getUserNameResponse, n);
    if (size)
      *size = n * sizeof(ns1__getUserNameResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getUserNameResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getUserNameResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserNameResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getUserNameResponse %p -> %p\n", q, p));
  *(ns1__getUserNameResponse *)p = *(ns1__getUserNameResponse *)q;
}

void ns1__getUserName::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getUserName::sessionId = nullptr;
}

void ns1__getUserName::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getUserName::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getUserName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getUserName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserName(struct soap *soap, const char *tag, int id,
                                                    const ns1__getUserName *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getUserName),
                             "ns1:getUserName"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getUserName::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getUserName::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getUserName(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getUserName *SOAP_FMAC4 soap_in_ns1__getUserName(struct soap *soap, const char *tag,
                                                                 ns1__getUserName *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getUserName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getUserName,
                                              sizeof(ns1__getUserName), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getUserName) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getUserName *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getUserName::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getUserName *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getUserName, 0,
                                            sizeof(ns1__getUserName), 0, soap_copy_ns1__getUserName);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getUserName::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getUserName);
  if (this->soap_out(soap, tag ? tag : "ns1:getUserName", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getUserName::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getUserName(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getUserName *SOAP_FMAC4 soap_get_ns1__getUserName(struct soap *soap, ns1__getUserName *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__getUserName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getUserName *SOAP_FMAC2 soap_instantiate_ns1__getUserName(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserName(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getUserName, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getUserName);
    if (size)
      *size = sizeof(ns1__getUserName);
    ((ns1__getUserName *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getUserName, n);
    if (size)
      *size = n * sizeof(ns1__getUserName);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getUserName *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getUserName *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserName(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getUserName %p -> %p\n", q, p));
  *(ns1__getUserName *)p = *(ns1__getUserName *)q;
}

void ns1__deleteManyResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__deleteManyResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__deleteManyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__deleteManyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteManyResponse(struct soap *soap, const char *tag, int id,
                                                           const ns1__deleteManyResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:deleteManyResponse");
}

void *ns1__deleteManyResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__deleteManyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteManyResponse *SOAP_FMAC4 soap_in_ns1__deleteManyResponse(struct soap *soap, const char *tag,
                                                                               ns1__deleteManyResponse *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__deleteManyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__deleteManyResponse,
                                                           sizeof(ns1__deleteManyResponse), soap->type,
                                                           soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__deleteManyResponse)
      return (ns1__deleteManyResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__deleteManyResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__deleteManyResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:deleteManyResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__deleteManyResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__deleteManyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteManyResponse *SOAP_FMAC4 soap_get_ns1__deleteManyResponse(struct soap *soap,
                                                                                ns1__deleteManyResponse *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in_ns1__deleteManyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__deleteManyResponse *SOAP_FMAC2 soap_instantiate_ns1__deleteManyResponse(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteManyResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__deleteManyResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__deleteManyResponse);
    if (size)
      *size = sizeof(ns1__deleteManyResponse);
    ((ns1__deleteManyResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteManyResponse, n);
    if (size)
      *size = n * sizeof(ns1__deleteManyResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__deleteManyResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__deleteManyResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteManyResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteManyResponse %p -> %p\n", q, p));
  *(ns1__deleteManyResponse *)p = *(ns1__deleteManyResponse *)q;
}

void ns1__deleteMany::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__deleteMany::sessionId = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, &this->ns1__deleteMany::beans);
}

void ns1__deleteMany::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__deleteMany::sessionId);
  soap_serialize_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, &this->ns1__deleteMany::beans);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__deleteMany::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__deleteMany(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteMany(struct soap *soap, const char *tag, int id, const ns1__deleteMany *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__deleteMany),
                             "ns1:deleteMany"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__deleteMany::sessionId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, "beans", -1, &(a->ns1__deleteMany::beans), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__deleteMany::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__deleteMany(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteMany *SOAP_FMAC4 soap_in_ns1__deleteMany(struct soap *soap, const char *tag, ns1__deleteMany *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__deleteMany *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__deleteMany,
                                             sizeof(ns1__deleteMany), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__deleteMany) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__deleteMany *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__deleteMany::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, "beans", &(a->ns1__deleteMany::beans),
                                                                      "ns1:entityBaseBean"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__deleteMany *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__deleteMany, 0,
                                           sizeof(ns1__deleteMany), 0, soap_copy_ns1__deleteMany);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__deleteMany::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__deleteMany);
  if (this->soap_out(soap, tag ? tag : "ns1:deleteMany", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__deleteMany::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__deleteMany(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteMany *SOAP_FMAC4 soap_get_ns1__deleteMany(struct soap *soap, ns1__deleteMany *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__deleteMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__deleteMany *SOAP_FMAC2 soap_instantiate_ns1__deleteMany(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteMany(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__deleteMany, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__deleteMany);
    if (size)
      *size = sizeof(ns1__deleteMany);
    ((ns1__deleteMany *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteMany, n);
    if (size)
      *size = n * sizeof(ns1__deleteMany);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__deleteMany *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__deleteMany *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteMany(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteMany %p -> %p\n", q, p));
  *(ns1__deleteMany *)p = *(ns1__deleteMany *)q;
}

void ns1__updateResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__updateResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__updateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__updateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateResponse(struct soap *soap, const char *tag, int id,
                                                       const ns1__updateResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:updateResponse");
}

void *ns1__updateResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__updateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateResponse *SOAP_FMAC4 soap_in_ns1__updateResponse(struct soap *soap, const char *tag,
                                                                       ns1__updateResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__updateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__updateResponse,
                                                       sizeof(ns1__updateResponse), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__updateResponse)
      return (ns1__updateResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__updateResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__updateResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:updateResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__updateResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__updateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateResponse *SOAP_FMAC4 soap_get_ns1__updateResponse(struct soap *soap, ns1__updateResponse *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__updateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__updateResponse *SOAP_FMAC2 soap_instantiate_ns1__updateResponse(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__updateResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__updateResponse);
    if (size)
      *size = sizeof(ns1__updateResponse);
    ((ns1__updateResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__updateResponse, n);
    if (size)
      *size = n * sizeof(ns1__updateResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__updateResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__updateResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateResponse %p -> %p\n", q, p));
  *(ns1__updateResponse *)p = *(ns1__updateResponse *)q;
}

void ns1__update::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__update::sessionId = nullptr;
  this->ns1__update::bean = nullptr;
}

void ns1__update::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__update::sessionId);
  soap_serialize_PointerTons1__entityBaseBean(soap, &this->ns1__update::bean);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__update::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__update(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__update(struct soap *soap, const char *tag, int id, const ns1__update *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__update), "ns1:update"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__update::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTons1__entityBaseBean(soap, "bean", -1, &(a->ns1__update::bean), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__update::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__update(soap, tag, this, type);
}

SOAP_FMAC3 ns1__update *SOAP_FMAC4 soap_in_ns1__update(struct soap *soap, const char *tag, ns1__update *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__update *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__update, sizeof(ns1__update),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__update) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__update *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_bean1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__update::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_bean1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityBaseBean(soap, "bean", &(a->ns1__update::bean), "ns1:entityBaseBean")) {
          soap_flag_bean1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__update *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__update, 0,
                                       sizeof(ns1__update), 0, soap_copy_ns1__update);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__update::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__update);
  if (this->soap_out(soap, tag ? tag : "ns1:update", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__update::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__update(soap, this, tag, type);
}

SOAP_FMAC3 ns1__update *SOAP_FMAC4 soap_get_ns1__update(struct soap *soap, ns1__update *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__update(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__update *SOAP_FMAC2 soap_instantiate_ns1__update(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__update(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__update, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__update);
    if (size)
      *size = sizeof(ns1__update);
    ((ns1__update *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__update, n);
    if (size)
      *size = n * sizeof(ns1__update);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__update *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__update *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__update(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__update %p -> %p\n", q, p));
  *(ns1__update *)p = *(ns1__update *)q;
}

void ns1__luceneGetPopulatingResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__luceneGetPopulatingResponse::return_);
}

void ns1__luceneGetPopulatingResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__luceneGetPopulatingResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneGetPopulatingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneGetPopulatingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneGetPopulatingResponse(struct soap *soap, const char *tag, int id,
                                                                    const ns1__luceneGetPopulatingResponse *a,
                                                                    const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse),
                             "ns1:luceneGetPopulatingResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__luceneGetPopulatingResponse::return_),
                                                ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneGetPopulatingResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneGetPopulatingResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneGetPopulatingResponse *SOAP_FMAC4 soap_in_ns1__luceneGetPopulatingResponse(
    struct soap *soap, const char *tag, ns1__luceneGetPopulatingResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneGetPopulatingResponse *)soap_class_id_enter(
      soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse, sizeof(ns1__luceneGetPopulatingResponse),
      soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneGetPopulatingResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__luceneGetPopulatingResponse::return_),
                                                     "xsd:string"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneGetPopulatingResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse, 0,
        sizeof(ns1__luceneGetPopulatingResponse), 0, soap_copy_ns1__luceneGetPopulatingResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__luceneGetPopulatingResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneGetPopulatingResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneGetPopulatingResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneGetPopulatingResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneGetPopulatingResponse *SOAP_FMAC4 soap_get_ns1__luceneGetPopulatingResponse(
    struct soap *soap, ns1__luceneGetPopulatingResponse *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneGetPopulatingResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneGetPopulatingResponse *SOAP_FMAC2 soap_instantiate_ns1__luceneGetPopulatingResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneGetPopulatingResponse(%d, %s, %s)\n", n,
                            type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneGetPopulatingResponse);
    if (size)
      *size = sizeof(ns1__luceneGetPopulatingResponse);
    ((ns1__luceneGetPopulatingResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneGetPopulatingResponse, n);
    if (size)
      *size = n * sizeof(ns1__luceneGetPopulatingResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneGetPopulatingResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneGetPopulatingResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneGetPopulatingResponse(struct soap *soap, int st, int tt, void *p,
                                                                      size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneGetPopulatingResponse %p -> %p\n", q, p));
  *(ns1__luceneGetPopulatingResponse *)p = *(ns1__luceneGetPopulatingResponse *)q;
}

void ns1__luceneGetPopulating::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__luceneGetPopulating::sessionId = nullptr;
}

void ns1__luceneGetPopulating::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneGetPopulating::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneGetPopulating::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneGetPopulating(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneGetPopulating(struct soap *soap, const char *tag, int id,
                                                            const ns1__luceneGetPopulating *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneGetPopulating),
                             "ns1:luceneGetPopulating"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__luceneGetPopulating::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneGetPopulating::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneGetPopulating(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneGetPopulating *SOAP_FMAC4 soap_in_ns1__luceneGetPopulating(struct soap *soap, const char *tag,
                                                                                 ns1__luceneGetPopulating *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneGetPopulating *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneGetPopulating,
                                                      sizeof(ns1__luceneGetPopulating), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneGetPopulating) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneGetPopulating *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__luceneGetPopulating::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneGetPopulating *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneGetPopulating, 0, sizeof(ns1__luceneGetPopulating),
        0, soap_copy_ns1__luceneGetPopulating);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__luceneGetPopulating::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneGetPopulating);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneGetPopulating", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneGetPopulating::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneGetPopulating(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneGetPopulating *SOAP_FMAC4 soap_get_ns1__luceneGetPopulating(struct soap *soap,
                                                                                  ns1__luceneGetPopulating *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneGetPopulating(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneGetPopulating *SOAP_FMAC2 soap_instantiate_ns1__luceneGetPopulating(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneGetPopulating(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneGetPopulating, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneGetPopulating);
    if (size)
      *size = sizeof(ns1__luceneGetPopulating);
    ((ns1__luceneGetPopulating *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneGetPopulating, n);
    if (size)
      *size = n * sizeof(ns1__luceneGetPopulating);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneGetPopulating *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneGetPopulating *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneGetPopulating(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneGetPopulating %p -> %p\n", q, p));
  *(ns1__luceneGetPopulating *)p = *(ns1__luceneGetPopulating *)q;
}

void ns1__getApiVersionResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getApiVersionResponse::return_ = nullptr;
}

void ns1__getApiVersionResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getApiVersionResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getApiVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getApiVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getApiVersionResponse(struct soap *soap, const char *tag, int id,
                                                              const ns1__getApiVersionResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getApiVersionResponse),
                             "ns1:getApiVersionResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getApiVersionResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getApiVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getApiVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getApiVersionResponse *SOAP_FMAC4 soap_in_ns1__getApiVersionResponse(struct soap *soap, const char *tag,
                                                                                     ns1__getApiVersionResponse *a,
                                                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getApiVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getApiVersionResponse,
                                                        sizeof(ns1__getApiVersionResponse), soap->type,
                                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getApiVersionResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getApiVersionResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getApiVersionResponse::return_), "xsd:string")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getApiVersionResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getApiVersionResponse, 0,
        sizeof(ns1__getApiVersionResponse), 0, soap_copy_ns1__getApiVersionResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getApiVersionResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getApiVersionResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getApiVersionResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getApiVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getApiVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getApiVersionResponse *SOAP_FMAC4 soap_get_ns1__getApiVersionResponse(struct soap *soap,
                                                                                      ns1__getApiVersionResponse *p,
                                                                                      const char *tag,
                                                                                      const char *type) {
  if ((p = soap_in_ns1__getApiVersionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getApiVersionResponse *SOAP_FMAC2 soap_instantiate_ns1__getApiVersionResponse(struct soap *soap, int n,
                                                                                              const char *type,
                                                                                              const char *arrayType,
                                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getApiVersionResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getApiVersionResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getApiVersionResponse);
    if (size)
      *size = sizeof(ns1__getApiVersionResponse);
    ((ns1__getApiVersionResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getApiVersionResponse, n);
    if (size)
      *size = n * sizeof(ns1__getApiVersionResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getApiVersionResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getApiVersionResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getApiVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getApiVersionResponse %p -> %p\n", q, p));
  *(ns1__getApiVersionResponse *)p = *(ns1__getApiVersionResponse *)q;
}

void ns1__getApiVersion::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__getApiVersion::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getApiVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getApiVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getApiVersion(struct soap *soap, const char *tag, int id,
                                                      const ns1__getApiVersion *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:getApiVersion");
}

void *ns1__getApiVersion::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getApiVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getApiVersion *SOAP_FMAC4 soap_in_ns1__getApiVersion(struct soap *soap, const char *tag,
                                                                     ns1__getApiVersion *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__getApiVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getApiVersion,
                                                      sizeof(ns1__getApiVersion), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getApiVersion)
      return (ns1__getApiVersion *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__getApiVersion::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getApiVersion);
  if (this->soap_out(soap, tag ? tag : "ns1:getApiVersion", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getApiVersion::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getApiVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getApiVersion *SOAP_FMAC4 soap_get_ns1__getApiVersion(struct soap *soap, ns1__getApiVersion *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__getApiVersion(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getApiVersion *SOAP_FMAC2 soap_instantiate_ns1__getApiVersion(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getApiVersion(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getApiVersion, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getApiVersion);
    if (size)
      *size = sizeof(ns1__getApiVersion);
    ((ns1__getApiVersion *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getApiVersion, n);
    if (size)
      *size = n * sizeof(ns1__getApiVersion);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getApiVersion *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getApiVersion *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getApiVersion(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getApiVersion %p -> %p\n", q, p));
  *(ns1__getApiVersion *)p = *(ns1__getApiVersion *)q;
}

void ns1__getEntityNamesResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getEntityNamesResponse::return_);
}

void ns1__getEntityNamesResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getEntityNamesResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getEntityNamesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getEntityNamesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityNamesResponse(struct soap *soap, const char *tag, int id,
                                                               const ns1__getEntityNamesResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse),
                             "ns1:getEntityNamesResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getEntityNamesResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getEntityNamesResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getEntityNamesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityNamesResponse *SOAP_FMAC4 soap_in_ns1__getEntityNamesResponse(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__getEntityNamesResponse *a,
                                                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getEntityNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse,
                                                         sizeof(ns1__getEntityNamesResponse), soap->type,
                                                         soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getEntityNamesResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getEntityNamesResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getEntityNamesResponse::return_),
                                                     "xsd:string"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getEntityNamesResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse, 0,
        sizeof(ns1__getEntityNamesResponse), 0, soap_copy_ns1__getEntityNamesResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getEntityNamesResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getEntityNamesResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getEntityNamesResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getEntityNamesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityNamesResponse *SOAP_FMAC4 soap_get_ns1__getEntityNamesResponse(struct soap *soap,
                                                                                        ns1__getEntityNamesResponse *p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_ns1__getEntityNamesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getEntityNamesResponse *SOAP_FMAC2 soap_instantiate_ns1__getEntityNamesResponse(struct soap *soap,
                                                                                                int n, const char *type,
                                                                                                const char *arrayType,
                                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityNamesResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getEntityNamesResponse);
    if (size)
      *size = sizeof(ns1__getEntityNamesResponse);
    ((ns1__getEntityNamesResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityNamesResponse, n);
    if (size)
      *size = n * sizeof(ns1__getEntityNamesResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getEntityNamesResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getEntityNamesResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityNamesResponse %p -> %p\n", q, p));
  *(ns1__getEntityNamesResponse *)p = *(ns1__getEntityNamesResponse *)q;
}

void ns1__getEntityNames::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__getEntityNames::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getEntityNames::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getEntityNames(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityNames(struct soap *soap, const char *tag, int id,
                                                       const ns1__getEntityNames *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:getEntityNames");
}

void *ns1__getEntityNames::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getEntityNames(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityNames *SOAP_FMAC4 soap_in_ns1__getEntityNames(struct soap *soap, const char *tag,
                                                                       ns1__getEntityNames *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__getEntityNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getEntityNames,
                                                       sizeof(ns1__getEntityNames), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getEntityNames)
      return (ns1__getEntityNames *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__getEntityNames::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getEntityNames);
  if (this->soap_out(soap, tag ? tag : "ns1:getEntityNames", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getEntityNames::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getEntityNames(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityNames *SOAP_FMAC4 soap_get_ns1__getEntityNames(struct soap *soap, ns1__getEntityNames *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__getEntityNames(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getEntityNames *SOAP_FMAC2 soap_instantiate_ns1__getEntityNames(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityNames(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getEntityNames, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getEntityNames);
    if (size)
      *size = sizeof(ns1__getEntityNames);
    ((ns1__getEntityNames *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityNames, n);
    if (size)
      *size = n * sizeof(ns1__getEntityNames);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getEntityNames *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getEntityNames *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityNames(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityNames %p -> %p\n", q, p));
  *(ns1__getEntityNames *)p = *(ns1__getEntityNames *)q;
}

void ns1__getResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getResponse::return_ = nullptr;
}

void ns1__getResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__entityBaseBean(soap, &this->ns1__getResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getResponse(struct soap *soap, const char *tag, int id,
                                                    const ns1__getResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getResponse),
                             "ns1:getResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTons1__entityBaseBean(soap, "return", -1, &(a->ns1__getResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getResponse *SOAP_FMAC4 soap_in_ns1__getResponse(struct soap *soap, const char *tag,
                                                                 ns1__getResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getResponse,
                                              sizeof(ns1__getResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityBaseBean(soap, "return", &(a->ns1__getResponse::return_),
                                                 "ns1:entityBaseBean")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getResponse *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getResponse, 0,
                                            sizeof(ns1__getResponse), 0, soap_copy_ns1__getResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getResponse *SOAP_FMAC4 soap_get_ns1__getResponse(struct soap *soap, ns1__getResponse *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__getResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getResponse *SOAP_FMAC2 soap_instantiate_ns1__getResponse(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getResponse);
    if (size)
      *size = sizeof(ns1__getResponse);
    ((ns1__getResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getResponse, n);
    if (size)
      *size = n * sizeof(ns1__getResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getResponse %p -> %p\n", q, p));
  *(ns1__getResponse *)p = *(ns1__getResponse *)q;
}

void ns1__get::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__get::sessionId = nullptr;
  this->ns1__get::query = nullptr;
  soap_default_LONG64(soap, &this->ns1__get::primaryKey);
}

void ns1__get::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__get::sessionId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__get::query);
  soap_embedded(soap, &this->ns1__get::primaryKey, SOAP_TYPE_ICat4_LONG64);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__get::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__get(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get(struct soap *soap, const char *tag, int id, const ns1__get *a,
                                            const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__get), "ns1:get"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__get::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "query", -1, &(a->ns1__get::query), ""))
    return soap->error;
  if (soap_out_LONG64(soap, "primaryKey", -1, &(a->ns1__get::primaryKey), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__get::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__get(soap, tag, this, type);
}

SOAP_FMAC3 ns1__get *SOAP_FMAC4 soap_in_ns1__get(struct soap *soap, const char *tag, ns1__get *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__get *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__get, sizeof(ns1__get), soap->type,
                                      soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__get) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__get *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_query1 = 1;
  size_t soap_flag_primaryKey1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__get::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "query", &(a->ns1__get::query), "xsd:string")) {
          soap_flag_query1--;
          continue;
        }
      if (soap_flag_primaryKey1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "primaryKey", &(a->ns1__get::primaryKey), "xsd:long")) {
          soap_flag_primaryKey1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__get *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__get, 0, sizeof(ns1__get), 0,
                                    soap_copy_ns1__get);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_primaryKey1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__get::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__get);
  if (this->soap_out(soap, tag ? tag : "ns1:get", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__get::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__get(soap, this, tag, type);
}

SOAP_FMAC3 ns1__get *SOAP_FMAC4 soap_get_ns1__get(struct soap *soap, ns1__get *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__get(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__get *SOAP_FMAC2 soap_instantiate_ns1__get(struct soap *soap, int n, const char *type,
                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__get, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__get);
    if (size)
      *size = sizeof(ns1__get);
    ((ns1__get *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__get, n);
    if (size)
      *size = n * sizeof(ns1__get);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__get *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__get *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__get %p -> %p\n", q, p));
  *(ns1__get *)p = *(ns1__get *)q;
}

void ns1__lucenePopulateResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__lucenePopulateResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__lucenePopulateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__lucenePopulateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lucenePopulateResponse(struct soap *soap, const char *tag, int id,
                                                               const ns1__lucenePopulateResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:lucenePopulateResponse");
}

void *ns1__lucenePopulateResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__lucenePopulateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lucenePopulateResponse *SOAP_FMAC4 soap_in_ns1__lucenePopulateResponse(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__lucenePopulateResponse *a,
                                                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__lucenePopulateResponse *)soap_class_id_enter(
            soap, soap->id, a, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse, sizeof(ns1__lucenePopulateResponse),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__lucenePopulateResponse)
      return (ns1__lucenePopulateResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__lucenePopulateResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:lucenePopulateResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__lucenePopulateResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__lucenePopulateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lucenePopulateResponse *SOAP_FMAC4 soap_get_ns1__lucenePopulateResponse(struct soap *soap,
                                                                                        ns1__lucenePopulateResponse *p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_ns1__lucenePopulateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__lucenePopulateResponse *SOAP_FMAC2 soap_instantiate_ns1__lucenePopulateResponse(struct soap *soap,
                                                                                                int n, const char *type,
                                                                                                const char *arrayType,
                                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lucenePopulateResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__lucenePopulateResponse);
    if (size)
      *size = sizeof(ns1__lucenePopulateResponse);
    ((ns1__lucenePopulateResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__lucenePopulateResponse, n);
    if (size)
      *size = n * sizeof(ns1__lucenePopulateResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__lucenePopulateResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__lucenePopulateResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lucenePopulateResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lucenePopulateResponse %p -> %p\n", q, p));
  *(ns1__lucenePopulateResponse *)p = *(ns1__lucenePopulateResponse *)q;
}

void ns1__lucenePopulate::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__lucenePopulate::sessionId = nullptr;
  this->ns1__lucenePopulate::entityName = nullptr;
}

void ns1__lucenePopulate::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__lucenePopulate::sessionId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__lucenePopulate::entityName);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__lucenePopulate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__lucenePopulate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lucenePopulate(struct soap *soap, const char *tag, int id,
                                                       const ns1__lucenePopulate *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__lucenePopulate),
                             "ns1:lucenePopulate"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__lucenePopulate::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "entityName", -1, &(a->ns1__lucenePopulate::entityName), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__lucenePopulate::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__lucenePopulate(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lucenePopulate *SOAP_FMAC4 soap_in_ns1__lucenePopulate(struct soap *soap, const char *tag,
                                                                       ns1__lucenePopulate *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__lucenePopulate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__lucenePopulate,
                                                 sizeof(ns1__lucenePopulate), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__lucenePopulate) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__lucenePopulate *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_entityName1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__lucenePopulate::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_entityName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "entityName", &(a->ns1__lucenePopulate::entityName), "xsd:string")) {
          soap_flag_entityName1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__lucenePopulate *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__lucenePopulate, 0,
                                               sizeof(ns1__lucenePopulate), 0, soap_copy_ns1__lucenePopulate);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__lucenePopulate::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__lucenePopulate);
  if (this->soap_out(soap, tag ? tag : "ns1:lucenePopulate", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__lucenePopulate::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__lucenePopulate(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lucenePopulate *SOAP_FMAC4 soap_get_ns1__lucenePopulate(struct soap *soap, ns1__lucenePopulate *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__lucenePopulate(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__lucenePopulate *SOAP_FMAC2 soap_instantiate_ns1__lucenePopulate(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lucenePopulate(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__lucenePopulate, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__lucenePopulate);
    if (size)
      *size = sizeof(ns1__lucenePopulate);
    ((ns1__lucenePopulate *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__lucenePopulate, n);
    if (size)
      *size = n * sizeof(ns1__lucenePopulate);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__lucenePopulate *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__lucenePopulate *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lucenePopulate(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lucenePopulate %p -> %p\n", q, p));
  *(ns1__lucenePopulate *)p = *(ns1__lucenePopulate *)q;
}

void ns1__luceneSearchResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__luceneSearchResponse::return_);
}

void ns1__luceneSearchResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__luceneSearchResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneSearchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneSearchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneSearchResponse(struct soap *soap, const char *tag, int id,
                                                             const ns1__luceneSearchResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneSearchResponse),
                             "ns1:luceneSearchResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__luceneSearchResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneSearchResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneSearchResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneSearchResponse *SOAP_FMAC4 soap_in_ns1__luceneSearchResponse(struct soap *soap, const char *tag,
                                                                                   ns1__luceneSearchResponse *a,
                                                                                   const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneSearchResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneSearchResponse,
                                                       sizeof(ns1__luceneSearchResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneSearchResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneSearchResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__luceneSearchResponse::return_),
                                                     "xsd:string"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneSearchResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneSearchResponse, 0, sizeof(ns1__luceneSearchResponse),
        0, soap_copy_ns1__luceneSearchResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__luceneSearchResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneSearchResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneSearchResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneSearchResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneSearchResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneSearchResponse *SOAP_FMAC4 soap_get_ns1__luceneSearchResponse(struct soap *soap,
                                                                                    ns1__luceneSearchResponse *p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneSearchResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneSearchResponse *SOAP_FMAC2 soap_instantiate_ns1__luceneSearchResponse(struct soap *soap, int n,
                                                                                            const char *type,
                                                                                            const char *arrayType,
                                                                                            size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneSearchResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneSearchResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneSearchResponse);
    if (size)
      *size = sizeof(ns1__luceneSearchResponse);
    ((ns1__luceneSearchResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneSearchResponse, n);
    if (size)
      *size = n * sizeof(ns1__luceneSearchResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneSearchResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneSearchResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneSearchResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                               const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneSearchResponse %p -> %p\n", q, p));
  *(ns1__luceneSearchResponse *)p = *(ns1__luceneSearchResponse *)q;
}

void ns1__luceneSearch::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__luceneSearch::sessionId = nullptr;
  this->ns1__luceneSearch::query = nullptr;
  soap_default_int(soap, &this->ns1__luceneSearch::maxCount);
  this->ns1__luceneSearch::entityName = nullptr;
}

void ns1__luceneSearch::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneSearch::sessionId);
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneSearch::query);
  soap_embedded(soap, &this->ns1__luceneSearch::maxCount, SOAP_TYPE_ICat4_int);
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneSearch::entityName);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneSearch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneSearch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneSearch(struct soap *soap, const char *tag, int id,
                                                     const ns1__luceneSearch *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneSearch),
                             "ns1:luceneSearch"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__luceneSearch::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "query", -1, &(a->ns1__luceneSearch::query), ""))
    return soap->error;
  if (soap_out_int(soap, "maxCount", -1, &(a->ns1__luceneSearch::maxCount), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "entityName", -1, &(a->ns1__luceneSearch::entityName), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneSearch::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneSearch(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneSearch *SOAP_FMAC4 soap_in_ns1__luceneSearch(struct soap *soap, const char *tag,
                                                                   ns1__luceneSearch *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneSearch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneSearch,
                                               sizeof(ns1__luceneSearch), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneSearch) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneSearch *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_query1 = 1;
  size_t soap_flag_maxCount1 = 1;
  size_t soap_flag_entityName1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__luceneSearch::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "query", &(a->ns1__luceneSearch::query), "xsd:string")) {
          soap_flag_query1--;
          continue;
        }
      if (soap_flag_maxCount1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "maxCount", &(a->ns1__luceneSearch::maxCount), "xsd:int")) {
          soap_flag_maxCount1--;
          continue;
        }
      if (soap_flag_entityName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "entityName", &(a->ns1__luceneSearch::entityName), "xsd:string")) {
          soap_flag_entityName1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneSearch *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneSearch, 0,
                                             sizeof(ns1__luceneSearch), 0, soap_copy_ns1__luceneSearch);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxCount1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__luceneSearch::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneSearch);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneSearch", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneSearch::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneSearch(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneSearch *SOAP_FMAC4 soap_get_ns1__luceneSearch(struct soap *soap, ns1__luceneSearch *p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneSearch(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneSearch *SOAP_FMAC2 soap_instantiate_ns1__luceneSearch(struct soap *soap, int n, const char *type,
                                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneSearch(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneSearch, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneSearch);
    if (size)
      *size = sizeof(ns1__luceneSearch);
    ((ns1__luceneSearch *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneSearch, n);
    if (size)
      *size = n * sizeof(ns1__luceneSearch);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneSearch *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneSearch *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneSearch(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneSearch %p -> %p\n", q, p));
  *(ns1__luceneSearch *)p = *(ns1__luceneSearch *)q;
}

void ns1__getPropertiesResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getPropertiesResponse::return_);
}

void ns1__getPropertiesResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getPropertiesResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPropertiesResponse(struct soap *soap, const char *tag, int id,
                                                              const ns1__getPropertiesResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getPropertiesResponse),
                             "ns1:getPropertiesResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getPropertiesResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPropertiesResponse *SOAP_FMAC4 soap_in_ns1__getPropertiesResponse(struct soap *soap, const char *tag,
                                                                                     ns1__getPropertiesResponse *a,
                                                                                     const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getPropertiesResponse,
                                                        sizeof(ns1__getPropertiesResponse), soap->type,
                                                        soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getPropertiesResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getPropertiesResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getPropertiesResponse::return_),
                                                     "xsd:string"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getPropertiesResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getPropertiesResponse, 0,
        sizeof(ns1__getPropertiesResponse), 0, soap_copy_ns1__getPropertiesResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getPropertiesResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getPropertiesResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:getPropertiesResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPropertiesResponse *SOAP_FMAC4 soap_get_ns1__getPropertiesResponse(struct soap *soap,
                                                                                      ns1__getPropertiesResponse *p,
                                                                                      const char *tag,
                                                                                      const char *type) {
  if ((p = soap_in_ns1__getPropertiesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getPropertiesResponse *SOAP_FMAC2 soap_instantiate_ns1__getPropertiesResponse(struct soap *soap, int n,
                                                                                              const char *type,
                                                                                              const char *arrayType,
                                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPropertiesResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getPropertiesResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getPropertiesResponse);
    if (size)
      *size = sizeof(ns1__getPropertiesResponse);
    ((ns1__getPropertiesResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getPropertiesResponse, n);
    if (size)
      *size = n * sizeof(ns1__getPropertiesResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getPropertiesResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getPropertiesResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPropertiesResponse %p -> %p\n", q, p));
  *(ns1__getPropertiesResponse *)p = *(ns1__getPropertiesResponse *)q;
}

void ns1__getProperties::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__getProperties::sessionId = nullptr;
}

void ns1__getProperties::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__getProperties::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__getProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProperties(struct soap *soap, const char *tag, int id,
                                                      const ns1__getProperties *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__getProperties),
                             "ns1:getProperties"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__getProperties::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__getProperties::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__getProperties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProperties *SOAP_FMAC4 soap_in_ns1__getProperties(struct soap *soap, const char *tag,
                                                                     ns1__getProperties *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__getProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__getProperties,
                                                sizeof(ns1__getProperties), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__getProperties) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__getProperties *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__getProperties::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__getProperties *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__getProperties, 0,
                                              sizeof(ns1__getProperties), 0, soap_copy_ns1__getProperties);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__getProperties::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__getProperties);
  if (this->soap_out(soap, tag ? tag : "ns1:getProperties", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__getProperties::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__getProperties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProperties *SOAP_FMAC4 soap_get_ns1__getProperties(struct soap *soap, ns1__getProperties *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__getProperties(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__getProperties *SOAP_FMAC2 soap_instantiate_ns1__getProperties(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProperties(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__getProperties, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__getProperties);
    if (size)
      *size = sizeof(ns1__getProperties);
    ((ns1__getProperties *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getProperties, n);
    if (size)
      *size = n * sizeof(ns1__getProperties);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__getProperties *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__getProperties *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProperties(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProperties %p -> %p\n", q, p));
  *(ns1__getProperties *)p = *(ns1__getProperties *)q;
}

void ns1__createResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_LONG64(soap, &this->ns1__createResponse::return_);
}

void ns1__createResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->ns1__createResponse::return_, SOAP_TYPE_ICat4_LONG64);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__createResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__createResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createResponse(struct soap *soap, const char *tag, int id,
                                                       const ns1__createResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__createResponse),
                             "ns1:createResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_LONG64(soap, "return", -1, &(a->ns1__createResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__createResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__createResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createResponse *SOAP_FMAC4 soap_in_ns1__createResponse(struct soap *soap, const char *tag,
                                                                       ns1__createResponse *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__createResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__createResponse,
                                                 sizeof(ns1__createResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__createResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__createResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_return_1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "return", &(a->ns1__createResponse::return_), "xsd:long")) {
          soap_flag_return_1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__createResponse *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__createResponse, 0,
                                               sizeof(ns1__createResponse), 0, soap_copy_ns1__createResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__createResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__createResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:createResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__createResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__createResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createResponse *SOAP_FMAC4 soap_get_ns1__createResponse(struct soap *soap, ns1__createResponse *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__createResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__createResponse *SOAP_FMAC2 soap_instantiate_ns1__createResponse(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__createResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__createResponse);
    if (size)
      *size = sizeof(ns1__createResponse);
    ((ns1__createResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createResponse, n);
    if (size)
      *size = n * sizeof(ns1__createResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__createResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__createResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createResponse %p -> %p\n", q, p));
  *(ns1__createResponse *)p = *(ns1__createResponse *)q;
}

void ns1__create::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__create::sessionId = nullptr;
  this->ns1__create::bean = nullptr;
}

void ns1__create::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__create::sessionId);
  soap_serialize_PointerTons1__entityBaseBean(soap, &this->ns1__create::bean);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__create::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__create(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create(struct soap *soap, const char *tag, int id, const ns1__create *a,
                                               const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__create), "ns1:create"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__create::sessionId), ""))
    return soap->error;
  if (soap_out_PointerTons1__entityBaseBean(soap, "bean", -1, &(a->ns1__create::bean), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__create::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__create(soap, tag, this, type);
}

SOAP_FMAC3 ns1__create *SOAP_FMAC4 soap_in_ns1__create(struct soap *soap, const char *tag, ns1__create *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__create *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__create, sizeof(ns1__create),
                                         soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__create) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__create *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  size_t soap_flag_bean1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__create::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag_bean1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__entityBaseBean(soap, "bean", &(a->ns1__create::bean), "ns1:entityBaseBean")) {
          soap_flag_bean1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__create *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__create, 0,
                                       sizeof(ns1__create), 0, soap_copy_ns1__create);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__create::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__create);
  if (this->soap_out(soap, tag ? tag : "ns1:create", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__create::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__create(soap, this, tag, type);
}

SOAP_FMAC3 ns1__create *SOAP_FMAC4 soap_get_ns1__create(struct soap *soap, ns1__create *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_ns1__create(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__create *SOAP_FMAC2 soap_instantiate_ns1__create(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__create(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__create, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__create);
    if (size)
      *size = sizeof(ns1__create);
    ((ns1__create *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__create, n);
    if (size)
      *size = n * sizeof(ns1__create);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__create *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__create *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__create(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__create %p -> %p\n", q, p));
  *(ns1__create *)p = *(ns1__create *)q;
}

void ns1__createManyResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__vectorTemplateOfLONG64(soap, &this->ns1__createManyResponse::return_);
}

void ns1__createManyResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfLONG64(soap, &this->ns1__createManyResponse::return_);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__createManyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__createManyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createManyResponse(struct soap *soap, const char *tag, int id,
                                                           const ns1__createManyResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__createManyResponse),
                             "ns1:createManyResponse"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_std__vectorTemplateOfLONG64(soap, "return", -1, &(a->ns1__createManyResponse::return_), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__createManyResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__createManyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createManyResponse *SOAP_FMAC4 soap_in_ns1__createManyResponse(struct soap *soap, const char *tag,
                                                                               ns1__createManyResponse *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__createManyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__createManyResponse,
                                                     sizeof(ns1__createManyResponse), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__createManyResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__createManyResponse *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfLONG64(soap, "return", &(a->ns1__createManyResponse::return_), "xsd:long"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__createManyResponse *)soap_id_forward(
        soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__createManyResponse, 0, sizeof(ns1__createManyResponse), 0,
        soap_copy_ns1__createManyResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__createManyResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__createManyResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:createManyResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__createManyResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__createManyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createManyResponse *SOAP_FMAC4 soap_get_ns1__createManyResponse(struct soap *soap,
                                                                                ns1__createManyResponse *p,
                                                                                const char *tag, const char *type) {
  if ((p = soap_in_ns1__createManyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__createManyResponse *SOAP_FMAC2 soap_instantiate_ns1__createManyResponse(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createManyResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__createManyResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__createManyResponse);
    if (size)
      *size = sizeof(ns1__createManyResponse);
    ((ns1__createManyResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createManyResponse, n);
    if (size)
      *size = n * sizeof(ns1__createManyResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__createManyResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__createManyResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createManyResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                             const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createManyResponse %p -> %p\n", q, p));
  *(ns1__createManyResponse *)p = *(ns1__createManyResponse *)q;
}

void ns1__entityBaseBean::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__entityBaseBean::createId = nullptr;
  this->ns1__entityBaseBean::createTime = nullptr;
  this->ns1__entityBaseBean::modTime = nullptr;
  this->ns1__entityBaseBean::id = nullptr;
  this->ns1__entityBaseBean::modId = nullptr;
}

void ns1__entityBaseBean::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::createId);
  soap_serialize_PointerTotime(soap, &this->ns1__entityBaseBean::createTime);
  soap_serialize_PointerTotime(soap, &this->ns1__entityBaseBean::modTime);
  soap_serialize_PointerToLONG64(soap, &this->ns1__entityBaseBean::id);
  soap_serialize_PointerTostd__string(soap, &this->ns1__entityBaseBean::modId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__entityBaseBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__entityBaseBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityBaseBean(struct soap *soap, const char *tag, int id,
                                                       const ns1__entityBaseBean *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__entityBaseBean),
                             "ns1:entityBaseBean"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "createId", -1, &(a->ns1__entityBaseBean::createId), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "createTime", -1, &(a->ns1__entityBaseBean::createTime), ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "modTime", -1, &(a->ns1__entityBaseBean::modTime), ""))
    return soap->error;
  if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__entityBaseBean::id), ""))
    return soap->error;
  if (soap_out_PointerTostd__string(soap, "modId", -1, &(a->ns1__entityBaseBean::modId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__entityBaseBean::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__entityBaseBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__entityBaseBean *SOAP_FMAC4 soap_in_ns1__entityBaseBean(struct soap *soap, const char *tag,
                                                                       ns1__entityBaseBean *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__entityBaseBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__entityBaseBean,
                                                 sizeof(ns1__entityBaseBean), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__entityBaseBean) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__entityBaseBean *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_createId1 = 1;
  size_t soap_flag_createTime1 = 1;
  size_t soap_flag_modTime1 = 1;
  size_t soap_flag_id1 = 1;
  size_t soap_flag_modId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_createId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "createId", &(a->ns1__entityBaseBean::createId), "xsd:string")) {
          soap_flag_createId1--;
          continue;
        }
      if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "createTime", &(a->ns1__entityBaseBean::createTime), "xsd:dateTime")) {
          soap_flag_createTime1--;
          continue;
        }
      if (soap_flag_modTime1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "modTime", &(a->ns1__entityBaseBean::modTime), "xsd:dateTime")) {
          soap_flag_modTime1--;
          continue;
        }
      if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__entityBaseBean::id), "xsd:long")) {
          soap_flag_id1--;
          continue;
        }
      if (soap_flag_modId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "modId", &(a->ns1__entityBaseBean::modId), "xsd:string")) {
          soap_flag_modId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__entityBaseBean *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__entityBaseBean, 0,
                                               sizeof(ns1__entityBaseBean), 0, soap_copy_ns1__entityBaseBean);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__entityBaseBean::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__entityBaseBean);
  if (this->soap_out(soap, tag ? tag : "ns1:entityBaseBean", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__entityBaseBean::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__entityBaseBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__entityBaseBean *SOAP_FMAC4 soap_get_ns1__entityBaseBean(struct soap *soap, ns1__entityBaseBean *p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_ns1__entityBaseBean(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__entityBaseBean *SOAP_FMAC2 soap_instantiate_ns1__entityBaseBean(struct soap *soap, int n,
                                                                                const char *type, const char *arrayType,
                                                                                size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__entityBaseBean(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__entityBaseBean, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (type && !soap_match_tag(soap, type, "ns1:datafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafile);
      if (size)
        *size = sizeof(ns1__datafile);
      ((ns1__datafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafile, n);
      if (size)
        *size = n * sizeof(ns1__datafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionDatafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionDatafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDatafile);
      if (size)
        *size = sizeof(ns1__dataCollectionDatafile);
      ((ns1__dataCollectionDatafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDatafile, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionDatafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionDatafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionDatafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollection")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollection;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollection);
      if (size)
        *size = sizeof(ns1__dataCollection);
      ((ns1__dataCollection *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollection, n);
      if (size)
        *size = n * sizeof(ns1__dataCollection);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollection *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollection *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionDataset")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionDataset;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDataset);
      if (size)
        *size = sizeof(ns1__dataCollectionDataset);
      ((ns1__dataCollectionDataset *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDataset, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionDataset);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionDataset *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionDataset *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataset")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataset;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataset);
      if (size)
        *size = sizeof(ns1__dataset);
      ((ns1__dataset *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataset, n);
      if (size)
        *size = n * sizeof(ns1__dataset);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataset *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataset *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigation")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigation;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigation);
      if (size)
        *size = sizeof(ns1__investigation);
      ((ns1__investigation *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigation, n);
      if (size)
        *size = n * sizeof(ns1__investigation);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigation *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigation *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:facility")) {
    cp->type = SOAP_TYPE_ICat4_ns1__facility;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__facility);
      if (size)
        *size = sizeof(ns1__facility);
      ((ns1__facility *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facility, n);
      if (size)
        *size = n * sizeof(ns1__facility);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__facility *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__facility *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:application")) {
    cp->type = SOAP_TYPE_ICat4_ns1__application;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__application);
      if (size)
        *size = sizeof(ns1__application);
      ((ns1__application *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__application, n);
      if (size)
        *size = n * sizeof(ns1__application);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__application *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__application *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:job")) {
    cp->type = SOAP_TYPE_ICat4_ns1__job;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__job);
      if (size)
        *size = sizeof(ns1__job);
      ((ns1__job *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__job, n);
      if (size)
        *size = n * sizeof(ns1__job);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__job *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__job *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafileFormat")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafileFormat;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafileFormat);
      if (size)
        *size = sizeof(ns1__datafileFormat);
      ((ns1__datafileFormat *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileFormat, n);
      if (size)
        *size = n * sizeof(ns1__datafileFormat);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafileFormat *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafileFormat *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datasetType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datasetType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datasetType);
      if (size)
        *size = sizeof(ns1__datasetType);
      ((ns1__datasetType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetType, n);
      if (size)
        *size = n * sizeof(ns1__datasetType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datasetType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datasetType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:facilityCycle")) {
    cp->type = SOAP_TYPE_ICat4_ns1__facilityCycle;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__facilityCycle);
      if (size)
        *size = sizeof(ns1__facilityCycle);
      ((ns1__facilityCycle *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facilityCycle, n);
      if (size)
        *size = n * sizeof(ns1__facilityCycle);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__facilityCycle *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__facilityCycle *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:instrument")) {
    cp->type = SOAP_TYPE_ICat4_ns1__instrument;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__instrument);
      if (size)
        *size = sizeof(ns1__instrument);
      ((ns1__instrument *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrument, n);
      if (size)
        *size = n * sizeof(ns1__instrument);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__instrument *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__instrument *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:instrumentScientist")) {
    cp->type = SOAP_TYPE_ICat4_ns1__instrumentScientist;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__instrumentScientist);
      if (size)
        *size = sizeof(ns1__instrumentScientist);
      ((ns1__instrumentScientist *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrumentScientist, n);
      if (size)
        *size = n * sizeof(ns1__instrumentScientist);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__instrumentScientist *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__instrumentScientist *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:user")) {
    cp->type = SOAP_TYPE_ICat4_ns1__user;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__user);
      if (size)
        *size = sizeof(ns1__user);
      ((ns1__user *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__user, n);
      if (size)
        *size = n * sizeof(ns1__user);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__user *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__user *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationUser")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationUser;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationUser);
      if (size)
        *size = sizeof(ns1__investigationUser);
      ((ns1__investigationUser *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationUser, n);
      if (size)
        *size = n * sizeof(ns1__investigationUser);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationUser *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationUser *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:study")) {
    cp->type = SOAP_TYPE_ICat4_ns1__study;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__study);
      if (size)
        *size = sizeof(ns1__study);
      ((ns1__study *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__study, n);
      if (size)
        *size = n * sizeof(ns1__study);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__study *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__study *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:studyInvestigation")) {
    cp->type = SOAP_TYPE_ICat4_ns1__studyInvestigation;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__studyInvestigation);
      if (size)
        *size = sizeof(ns1__studyInvestigation);
      ((ns1__studyInvestigation *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__studyInvestigation, n);
      if (size)
        *size = n * sizeof(ns1__studyInvestigation);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__studyInvestigation *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__studyInvestigation *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:userGroup")) {
    cp->type = SOAP_TYPE_ICat4_ns1__userGroup;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__userGroup);
      if (size)
        *size = sizeof(ns1__userGroup);
      ((ns1__userGroup *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__userGroup, n);
      if (size)
        *size = n * sizeof(ns1__userGroup);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__userGroup *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__userGroup *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:grouping")) {
    cp->type = SOAP_TYPE_ICat4_ns1__grouping;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__grouping);
      if (size)
        *size = sizeof(ns1__grouping);
      ((ns1__grouping *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__grouping, n);
      if (size)
        *size = n * sizeof(ns1__grouping);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__grouping *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__grouping *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:rule")) {
    cp->type = SOAP_TYPE_ICat4_ns1__rule;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__rule);
      if (size)
        *size = sizeof(ns1__rule);
      ((ns1__rule *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__rule, n);
      if (size)
        *size = n * sizeof(ns1__rule);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__rule *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__rule *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationInstrument")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationInstrument;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationInstrument);
      if (size)
        *size = sizeof(ns1__investigationInstrument);
      ((ns1__investigationInstrument *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationInstrument, n);
      if (size)
        *size = n * sizeof(ns1__investigationInstrument);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationInstrument *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationInstrument *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationType);
      if (size)
        *size = sizeof(ns1__investigationType);
      ((ns1__investigationType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationType, n);
      if (size)
        *size = n * sizeof(ns1__investigationType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:parameterType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__parameterType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__parameterType);
      if (size)
        *size = sizeof(ns1__parameterType);
      ((ns1__parameterType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameterType, n);
      if (size)
        *size = n * sizeof(ns1__parameterType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__parameterType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__parameterType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:parameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__parameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__parameter);
      if (size)
        *size = sizeof(ns1__parameter);
      ((ns1__parameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameter, n);
      if (size)
        *size = n * sizeof(ns1__parameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__parameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__parameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:permissibleStringValue")) {
    cp->type = SOAP_TYPE_ICat4_ns1__permissibleStringValue;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__permissibleStringValue);
      if (size)
        *size = sizeof(ns1__permissibleStringValue);
      ((ns1__permissibleStringValue *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__permissibleStringValue, n);
      if (size)
        *size = n * sizeof(ns1__permissibleStringValue);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__permissibleStringValue *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__permissibleStringValue *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sample")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sample;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sample);
      if (size)
        *size = sizeof(ns1__sample);
      ((ns1__sample *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sample, n);
      if (size)
        *size = n * sizeof(ns1__sample);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sample *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sample *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sampleType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sampleType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sampleType);
      if (size)
        *size = sizeof(ns1__sampleType);
      ((ns1__sampleType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleType, n);
      if (size)
        *size = n * sizeof(ns1__sampleType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sampleType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sampleType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:keyword")) {
    cp->type = SOAP_TYPE_ICat4_ns1__keyword;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__keyword);
      if (size)
        *size = sizeof(ns1__keyword);
      ((ns1__keyword *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__keyword, n);
      if (size)
        *size = n * sizeof(ns1__keyword);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__keyword *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__keyword *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:publication")) {
    cp->type = SOAP_TYPE_ICat4_ns1__publication;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__publication);
      if (size)
        *size = sizeof(ns1__publication);
      ((ns1__publication *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publication, n);
      if (size)
        *size = n * sizeof(ns1__publication);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__publication *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__publication *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:shift")) {
    cp->type = SOAP_TYPE_ICat4_ns1__shift;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__shift);
      if (size)
        *size = sizeof(ns1__shift);
      ((ns1__shift *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__shift, n);
      if (size)
        *size = n * sizeof(ns1__shift);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__shift *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__shift *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:relatedDatafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__relatedDatafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__relatedDatafile);
      if (size)
        *size = sizeof(ns1__relatedDatafile);
      ((ns1__relatedDatafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__relatedDatafile, n);
      if (size)
        *size = n * sizeof(ns1__relatedDatafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__relatedDatafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__relatedDatafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:log")) {
    cp->type = SOAP_TYPE_ICat4_ns1__log;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__log);
      if (size)
        *size = sizeof(ns1__log);
      ((ns1__log *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__log, n);
      if (size)
        *size = n * sizeof(ns1__log);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__log *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__log *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:publicStep")) {
    cp->type = SOAP_TYPE_ICat4_ns1__publicStep;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__publicStep);
      if (size)
        *size = sizeof(ns1__publicStep);
      ((ns1__publicStep *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publicStep, n);
      if (size)
        *size = n * sizeof(ns1__publicStep);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__publicStep *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__publicStep *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionParameter);
      if (size)
        *size = sizeof(ns1__dataCollectionParameter);
      ((ns1__dataCollectionParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionParameter, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafileParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafileParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafileParameter);
      if (size)
        *size = sizeof(ns1__datafileParameter);
      ((ns1__datafileParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileParameter, n);
      if (size)
        *size = n * sizeof(ns1__datafileParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafileParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafileParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datasetParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datasetParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datasetParameter);
      if (size)
        *size = sizeof(ns1__datasetParameter);
      ((ns1__datasetParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetParameter, n);
      if (size)
        *size = n * sizeof(ns1__datasetParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datasetParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datasetParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationParameter);
      if (size)
        *size = sizeof(ns1__investigationParameter);
      ((ns1__investigationParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationParameter, n);
      if (size)
        *size = n * sizeof(ns1__investigationParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sampleParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sampleParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sampleParameter);
      if (size)
        *size = sizeof(ns1__sampleParameter);
      ((ns1__sampleParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleParameter, n);
      if (size)
        *size = n * sizeof(ns1__sampleParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sampleParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sampleParameter *)cp->ptr;
  }
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__entityBaseBean);
    if (size)
      *size = sizeof(ns1__entityBaseBean);
    ((ns1__entityBaseBean *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityBaseBean, n);
    if (size)
      *size = n * sizeof(ns1__entityBaseBean);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__entityBaseBean *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__entityBaseBean *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__entityBaseBean(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__entityBaseBean %p -> %p\n", q, p));
  *(ns1__entityBaseBean *)p = *(ns1__entityBaseBean *)q;
}

void ns1__createMany::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__createMany::sessionId = nullptr;
  soap_default_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, &this->ns1__createMany::beans);
}

void ns1__createMany::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__createMany::sessionId);
  soap_serialize_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, &this->ns1__createMany::beans);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__createMany::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__createMany(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createMany(struct soap *soap, const char *tag, int id, const ns1__createMany *a,
                                                   const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__createMany),
                             "ns1:createMany"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__createMany::sessionId), ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, "beans", -1, &(a->ns1__createMany::beans), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__createMany::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__createMany(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createMany *SOAP_FMAC4 soap_in_ns1__createMany(struct soap *soap, const char *tag, ns1__createMany *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__createMany *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__createMany,
                                             sizeof(ns1__createMany), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__createMany) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__createMany *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__createMany::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, "beans", &(a->ns1__createMany::beans),
                                                                      "ns1:entityBaseBean"))
          continue;
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__createMany *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__createMany, 0,
                                           sizeof(ns1__createMany), 0, soap_copy_ns1__createMany);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__createMany::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__createMany);
  if (this->soap_out(soap, tag ? tag : "ns1:createMany", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__createMany::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__createMany(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createMany *SOAP_FMAC4 soap_get_ns1__createMany(struct soap *soap, ns1__createMany *p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_ns1__createMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__createMany *SOAP_FMAC2 soap_instantiate_ns1__createMany(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createMany(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__createMany, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__createMany);
    if (size)
      *size = sizeof(ns1__createMany);
    ((ns1__createMany *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createMany, n);
    if (size)
      *size = n * sizeof(ns1__createMany);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__createMany *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__createMany *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createMany(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createMany %p -> %p\n", q, p));
  *(ns1__createMany *)p = *(ns1__createMany *)q;
}

void ns1__IcatException::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__IcatException::message = nullptr;
  soap_default_int(soap, &this->ns1__IcatException::offset);
  this->ns1__IcatException::type = nullptr;
}

void ns1__IcatException::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__IcatException::message);
  soap_embedded(soap, &this->ns1__IcatException::offset, SOAP_TYPE_ICat4_int);
  soap_serialize_PointerTons1__icatExceptionType(soap, &this->ns1__IcatException::type);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__IcatException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__IcatException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IcatException(struct soap *soap, const char *tag, int id,
                                                      const ns1__IcatException *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__IcatException),
                             "ns1:IcatException"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__IcatException::message), ""))
    return soap->error;
  if (soap_out_int(soap, "offset", -1, &(a->ns1__IcatException::offset), ""))
    return soap->error;
  if (soap_out_PointerTons1__icatExceptionType(soap, "type", -1, &(a->ns1__IcatException::type), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__IcatException::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__IcatException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__IcatException *SOAP_FMAC4 soap_in_ns1__IcatException(struct soap *soap, const char *tag,
                                                                     ns1__IcatException *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__IcatException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__IcatException,
                                                sizeof(ns1__IcatException), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__IcatException) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__IcatException *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_message1 = 1;
  size_t soap_flag_offset1 = 1;
  size_t soap_flag_type1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__IcatException::message), "xsd:string")) {
          soap_flag_message1--;
          continue;
        }
      if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "offset", &(a->ns1__IcatException::offset), "xsd:int")) {
          soap_flag_offset1--;
          continue;
        }
      if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__icatExceptionType(soap, "type", &(a->ns1__IcatException::type),
                                                    "ns1:icatExceptionType")) {
          soap_flag_type1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__IcatException *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__IcatException, 0,
                                              sizeof(ns1__IcatException), 0, soap_copy_ns1__IcatException);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset1 > 0)) {
    soap->error = SOAP_OCCURS;
    return nullptr;
  }
  return a;
}

int ns1__IcatException::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__IcatException);
  if (this->soap_out(soap, tag ? tag : "ns1:IcatException", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__IcatException::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__IcatException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__IcatException *SOAP_FMAC4 soap_get_ns1__IcatException(struct soap *soap, ns1__IcatException *p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_ns1__IcatException(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__IcatException *SOAP_FMAC2 soap_instantiate_ns1__IcatException(struct soap *soap, int n,
                                                                              const char *type, const char *arrayType,
                                                                              size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__IcatException(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__IcatException, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__IcatException);
    if (size)
      *size = sizeof(ns1__IcatException);
    ((ns1__IcatException *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__IcatException, n);
    if (size)
      *size = n * sizeof(ns1__IcatException);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__IcatException *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__IcatException *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__IcatException(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__IcatException %p -> %p\n", q, p));
  *(ns1__IcatException *)p = *(ns1__IcatException *)q;
}

void ns1__luceneClearResponse::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
}

void ns1__luceneClearResponse::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneClearResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneClearResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneClearResponse(struct soap *soap, const char *tag, int id,
                                                            const ns1__luceneClearResponse *a, const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:luceneClearResponse");
}

void *ns1__luceneClearResponse::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneClearResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneClearResponse *SOAP_FMAC4 soap_in_ns1__luceneClearResponse(struct soap *soap, const char *tag,
                                                                                 ns1__luceneClearResponse *a,
                                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (ns1__luceneClearResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneClearResponse,
                                                            sizeof(ns1__luceneClearResponse), soap->type,
                                                            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneClearResponse)
      return (ns1__luceneClearResponse *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int ns1__luceneClearResponse::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneClearResponse);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneClearResponse", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneClearResponse::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneClearResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneClearResponse *SOAP_FMAC4 soap_get_ns1__luceneClearResponse(struct soap *soap,
                                                                                  ns1__luceneClearResponse *p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneClearResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneClearResponse *SOAP_FMAC2 soap_instantiate_ns1__luceneClearResponse(struct soap *soap, int n,
                                                                                          const char *type,
                                                                                          const char *arrayType,
                                                                                          size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneClearResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneClearResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneClearResponse);
    if (size)
      *size = sizeof(ns1__luceneClearResponse);
    ((ns1__luceneClearResponse *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneClearResponse, n);
    if (size)
      *size = n * sizeof(ns1__luceneClearResponse);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneClearResponse *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneClearResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneClearResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                              const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneClearResponse %p -> %p\n", q, p));
  *(ns1__luceneClearResponse *)p = *(ns1__luceneClearResponse *)q;
}

void ns1__luceneClear::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  this->ns1__luceneClear::sessionId = nullptr;
}

void ns1__luceneClear::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &this->ns1__luceneClear::sessionId);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__luceneClear::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_ns1__luceneClear(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__luceneClear(struct soap *soap, const char *tag, int id,
                                                    const ns1__luceneClear *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_ns1__luceneClear),
                             "ns1:luceneClear"))
    return soap->error;
  /* transient soap skipped */
  if (soap_out_PointerTostd__string(soap, "sessionId", -1, &(a->ns1__luceneClear::sessionId), ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

void *ns1__luceneClear::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_ns1__luceneClear(soap, tag, this, type);
}

SOAP_FMAC3 ns1__luceneClear *SOAP_FMAC4 soap_in_ns1__luceneClear(struct soap *soap, const char *tag,
                                                                 ns1__luceneClear *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, nullptr))
    return nullptr;
  a = (ns1__luceneClear *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_ns1__luceneClear,
                                              sizeof(ns1__luceneClear), soap->type, soap->arrayType);
  if (!a)
    return nullptr;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_ns1__luceneClear) {
      soap_revert(soap);
      *soap->id = '\0';
      return (ns1__luceneClear *)a->soap_in(soap, tag, type);
    }
  }
  size_t soap_flag___item2 = 1;
  size_t soap_flag_sessionId1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "sessionId", &(a->ns1__luceneClear::sessionId), "xsd:string")) {
          soap_flag_sessionId1--;
          continue;
        }
      if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return nullptr;
    }
    if (soap_element_end_in(soap, tag))
      return nullptr;
  } else {
    a = (ns1__luceneClear *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_ns1__luceneClear, 0,
                                            sizeof(ns1__luceneClear), 0, soap_copy_ns1__luceneClear);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

int ns1__luceneClear::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_ns1__luceneClear);
  if (this->soap_out(soap, tag ? tag : "ns1:luceneClear", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *ns1__luceneClear::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_ns1__luceneClear(soap, this, tag, type);
}

SOAP_FMAC3 ns1__luceneClear *SOAP_FMAC4 soap_get_ns1__luceneClear(struct soap *soap, ns1__luceneClear *p,
                                                                  const char *tag, const char *type) {
  if ((p = soap_in_ns1__luceneClear(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 ns1__luceneClear *SOAP_FMAC2 soap_instantiate_ns1__luceneClear(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__luceneClear(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_ns1__luceneClear, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(ns1__luceneClear);
    if (size)
      *size = sizeof(ns1__luceneClear);
    ((ns1__luceneClear *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneClear, n);
    if (size)
      *size = n * sizeof(ns1__luceneClear);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((ns1__luceneClear *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (ns1__luceneClear *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__luceneClear(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__luceneClear %p -> %p\n", q, p));
  *(ns1__luceneClear *)p = *(ns1__luceneClear *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p) {
  (void)soap; /* appease -Wall -Werror */
  p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s,
                                               const char *type) {
  if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
    return soap_element_null(soap, tag, id, type);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ICat4_std__string), type) ||
      soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 std::string *SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!s)
    s = soap_new_std__string(soap, -1);
  if (soap->null)
    if (s)
      s->erase();
  if (soap->body && !*soap->href) {
    char *t;
    s = (std::string *)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ICat4_std__string, sizeof(std::string),
                                           soap->type, soap->arrayType);
    if (s) {
      if (!(t = soap_string_in(soap, 1, 0, -1)))
        return nullptr;
      s->assign(t);
    }
  } else
    s = (std::string *)soap_id_forward(soap, soap->href,
                                       soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ICat4_std__string,
                                                           sizeof(std::string), soap->type, soap->arrayType),
                                       0, SOAP_TYPE_ICat4_std__string, 0, sizeof(std::string), 0,
                                       soap_copy_std__string);
  if (soap->body && soap_element_end_in(soap, tag))
    return nullptr;
  return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag,
                                               const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_std__string);
  if (soap_out_std__string(soap, tag ? tag : "string", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 std::string *SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_std__string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 std::string *SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__string, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::string);
    if (size)
      *size = sizeof(std::string);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::string, n);
    if (size)
      *size = n * sizeof(std::string);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::string *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
  *(std::string *)p = *(std::string *)q;
}

void xsd__string::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_std__string(soap, &this->xsd__string::__item);
}

void xsd__string::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_ICat4_std__string);
  soap_serialize_std__string(soap, &this->xsd__string::__item);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a,
                                               const char *type) {
  return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string *SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__string, sizeof(xsd__string),
                                               soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__string)
      return (xsd__string *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
    return nullptr;
  return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__string);
  if (this->soap_out(soap, tag ? tag : "xsd:string", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string *SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_xsd__string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__string *SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__string, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__string);
    if (size)
      *size = sizeof(xsd__string);
    ((xsd__string *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__string, n);
    if (size)
      *size = n * sizeof(xsd__string);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__string *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__string *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
  *(xsd__string *)p = *(xsd__string *)q;
}

void xsd__long::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_LONG64(soap, &this->xsd__long::__item);
}

void xsd__long::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->xsd__long::__item, SOAP_TYPE_ICat4_LONG64);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a,
                                             const char *type) {
  return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long *SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__long, sizeof(xsd__long),
                                             soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__long)
      return (xsd__long *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
    return nullptr;
  return a;
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__long);
  if (this->soap_out(soap, tag ? tag : "xsd:long", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long *SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag,
                                                    const char *type) {
  if ((p = soap_in_xsd__long(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__long *SOAP_FMAC2 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type,
                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__long, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__long);
    if (size)
      *size = sizeof(xsd__long);
    ((xsd__long *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__long, n);
    if (size)
      *size = n * sizeof(xsd__long);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__long *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__long *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                               size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
  *(xsd__long *)p = *(xsd__long *)q;
}

void xsd__int::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_int(soap, &this->xsd__int::__item);
}

void xsd__int::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_ICat4_int);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a,
                                            const char *type) {
  return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int *SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__int, sizeof(xsd__int), soap->type,
                                            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__int)
      return (xsd__int *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
    return nullptr;
  return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__int);
  if (this->soap_out(soap, tag ? tag : "xsd:int", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int *SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type) {
  if ((p = soap_in_xsd__int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__int *SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type,
                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__int, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__int);
    if (size)
      *size = sizeof(xsd__int);
    ((xsd__int *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__int, n);
    if (size)
      *size = n * sizeof(xsd__int);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__int *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__int *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
  *(xsd__int *)p = *(xsd__int *)q;
}

void xsd__double::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_double(soap, &this->xsd__double::__item);
}

void xsd__double::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->xsd__double::__item, SOAP_TYPE_ICat4_double);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a,
                                               const char *type) {
  return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double *SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a,
                                                       const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__double, sizeof(xsd__double),
                                               soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__double)
      return (xsd__double *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
    return nullptr;
  return a;
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__double);
  if (this->soap_out(soap, tag ? tag : "xsd:double", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double *SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_xsd__double(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__double *SOAP_FMAC2 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type,
                                                                const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__double, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__double);
    if (size)
      *size = sizeof(xsd__double);
    ((xsd__double *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__double, n);
    if (size)
      *size = n * sizeof(xsd__double);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__double *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__double *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
  *(xsd__double *)p = *(xsd__double *)q;
}

void xsd__dateTime::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_time(soap, &this->xsd__dateTime::__item);
}

void xsd__dateTime::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_ICat4_time);
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a,
                                                 const char *type) {
  return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime *SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__dateTime,
                                                 sizeof(xsd__dateTime), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__dateTime)
      return (xsd__dateTime *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
    return nullptr;
  return a;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__dateTime);
  if (this->soap_out(soap, tag ? tag : "xsd:dateTime", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime *SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__dateTime *SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__dateTime, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__dateTime);
    if (size)
      *size = sizeof(xsd__dateTime);
    ((xsd__dateTime *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__dateTime, n);
    if (size)
      *size = n * sizeof(xsd__dateTime);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__dateTime *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__dateTime *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
  *(xsd__dateTime *)p = *(xsd__dateTime *)q;
}

void xsd__boolean::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::soap_default(soap);
  soap_default_bool(soap, &this->xsd__boolean::__item);
}

void xsd__boolean::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
  this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a,
                                                const char *type) {
  return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean *SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a,
                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__boolean, sizeof(xsd__boolean),
                                                soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__boolean)
      return (xsd__boolean *)a->soap_in(soap, tag, type);
  }
  if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
    return nullptr;
  return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__boolean);
  if (this->soap_out(soap, tag ? tag : "xsd:boolean", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean *SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag,
                                                          const char *type) {
  if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__boolean *SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__boolean, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__boolean);
    if (size)
      *size = sizeof(xsd__boolean);
    ((xsd__boolean *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__boolean, n);
    if (size)
      *size = n * sizeof(xsd__boolean);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__boolean *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__boolean *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
  *(xsd__boolean *)p = *(xsd__boolean *)q;
}

void xsd__anyType::soap_default(struct soap *soap) {
  this->soap = soap;
  this->xsd__anyType::__item = nullptr;
  /* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const {
#ifndef WITH_NOIDREF
  (void)soap; /* appease -Wall -Werror */
              /* transient soap skipped */
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const {
  return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a,
                                                const char *type) {
  return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), nullptr);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type) {
  return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType *SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a,
                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_xsd__anyType, sizeof(xsd__anyType),
                                                soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return nullptr;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_ICat4_xsd__anyType)
      return (xsd__anyType *)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
    return nullptr;
  return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const char *type) const {
  int id = soap_embed(soap, (void *)this, nullptr, 0, tag, SOAP_TYPE_ICat4_xsd__anyType);
  if (this->soap_out(soap, tag ? tag : "xsd:anyType", id, type))
    return soap->error;
  return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type) {
  return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType *SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag,
                                                          const char *type) {
  if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 xsd__anyType *SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_xsd__anyType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (type && !soap_match_tag(soap, type, "xsd:boolean")) {
    cp->type = SOAP_TYPE_ICat4_xsd__boolean;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__boolean);
      if (size)
        *size = sizeof(xsd__boolean);
      ((xsd__boolean *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__boolean, n);
      if (size)
        *size = n * sizeof(xsd__boolean);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__boolean *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__boolean *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:dateTime")) {
    cp->type = SOAP_TYPE_ICat4_xsd__dateTime;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__dateTime);
      if (size)
        *size = sizeof(xsd__dateTime);
      ((xsd__dateTime *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__dateTime, n);
      if (size)
        *size = n * sizeof(xsd__dateTime);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__dateTime *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__dateTime *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:double")) {
    cp->type = SOAP_TYPE_ICat4_xsd__double;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__double);
      if (size)
        *size = sizeof(xsd__double);
      ((xsd__double *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__double, n);
      if (size)
        *size = n * sizeof(xsd__double);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__double *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__double *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:int")) {
    cp->type = SOAP_TYPE_ICat4_xsd__int;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__int);
      if (size)
        *size = sizeof(xsd__int);
      ((xsd__int *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__int, n);
      if (size)
        *size = n * sizeof(xsd__int);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__int *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__int *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:long")) {
    cp->type = SOAP_TYPE_ICat4_xsd__long;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__long);
      if (size)
        *size = sizeof(xsd__long);
      ((xsd__long *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__long, n);
      if (size)
        *size = n * sizeof(xsd__long);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__long *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__long *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:string")) {
    cp->type = SOAP_TYPE_ICat4_xsd__string;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(xsd__string);
      if (size)
        *size = sizeof(xsd__string);
      ((xsd__string *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__string, n);
      if (size)
        *size = n * sizeof(xsd__string);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((xsd__string *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (xsd__string *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:icatExceptionType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__icatExceptionType_;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__icatExceptionType_);
      if (size)
        *size = sizeof(ns1__icatExceptionType_);
      ((ns1__icatExceptionType_ *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__icatExceptionType_, n);
      if (size)
        *size = n * sizeof(ns1__icatExceptionType_);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__icatExceptionType_ *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__icatExceptionType_ *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:studyStatus")) {
    cp->type = SOAP_TYPE_ICat4_ns1__studyStatus_;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__studyStatus_);
      if (size)
        *size = sizeof(ns1__studyStatus_);
      ((ns1__studyStatus_ *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__studyStatus_, n);
      if (size)
        *size = n * sizeof(ns1__studyStatus_);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__studyStatus_ *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__studyStatus_ *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:parameterValueType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__parameterValueType_;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__parameterValueType_);
      if (size)
        *size = sizeof(ns1__parameterValueType_);
      ((ns1__parameterValueType_ *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameterValueType_, n);
      if (size)
        *size = n * sizeof(ns1__parameterValueType_);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__parameterValueType_ *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__parameterValueType_ *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:relType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__relType_;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__relType_);
      if (size)
        *size = sizeof(ns1__relType_);
      ((ns1__relType_ *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__relType_, n);
      if (size)
        *size = n * sizeof(ns1__relType_);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__relType_ *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__relType_ *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:accessType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__accessType_;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__accessType_);
      if (size)
        *size = sizeof(ns1__accessType_);
      ((ns1__accessType_ *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__accessType_, n);
      if (size)
        *size = n * sizeof(ns1__accessType_);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__accessType_ *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__accessType_ *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneClear")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneClear;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneClear);
      if (size)
        *size = sizeof(ns1__luceneClear);
      ((ns1__luceneClear *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneClear, n);
      if (size)
        *size = n * sizeof(ns1__luceneClear);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneClear *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneClear *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneClearResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneClearResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneClearResponse);
      if (size)
        *size = sizeof(ns1__luceneClearResponse);
      ((ns1__luceneClearResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneClearResponse, n);
      if (size)
        *size = n * sizeof(ns1__luceneClearResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneClearResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneClearResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:IcatException")) {
    cp->type = SOAP_TYPE_ICat4_ns1__IcatException;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__IcatException);
      if (size)
        *size = sizeof(ns1__IcatException);
      ((ns1__IcatException *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__IcatException, n);
      if (size)
        *size = n * sizeof(ns1__IcatException);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__IcatException *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__IcatException *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:createMany")) {
    cp->type = SOAP_TYPE_ICat4_ns1__createMany;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__createMany);
      if (size)
        *size = sizeof(ns1__createMany);
      ((ns1__createMany *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createMany, n);
      if (size)
        *size = n * sizeof(ns1__createMany);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__createMany *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__createMany *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:entityBaseBean")) {
    cp->type = SOAP_TYPE_ICat4_ns1__entityBaseBean;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__entityBaseBean);
      if (size)
        *size = sizeof(ns1__entityBaseBean);
      ((ns1__entityBaseBean *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityBaseBean, n);
      if (size)
        *size = n * sizeof(ns1__entityBaseBean);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__entityBaseBean *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__entityBaseBean *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:createManyResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__createManyResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__createManyResponse);
      if (size)
        *size = sizeof(ns1__createManyResponse);
      ((ns1__createManyResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createManyResponse, n);
      if (size)
        *size = n * sizeof(ns1__createManyResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__createManyResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__createManyResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:create")) {
    cp->type = SOAP_TYPE_ICat4_ns1__create;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__create);
      if (size)
        *size = sizeof(ns1__create);
      ((ns1__create *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__create, n);
      if (size)
        *size = n * sizeof(ns1__create);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__create *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__create *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:createResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__createResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__createResponse);
      if (size)
        *size = sizeof(ns1__createResponse);
      ((ns1__createResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__createResponse, n);
      if (size)
        *size = n * sizeof(ns1__createResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__createResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__createResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getProperties")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getProperties;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getProperties);
      if (size)
        *size = sizeof(ns1__getProperties);
      ((ns1__getProperties *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getProperties, n);
      if (size)
        *size = n * sizeof(ns1__getProperties);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getProperties *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getProperties *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getPropertiesResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getPropertiesResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getPropertiesResponse);
      if (size)
        *size = sizeof(ns1__getPropertiesResponse);
      ((ns1__getPropertiesResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getPropertiesResponse, n);
      if (size)
        *size = n * sizeof(ns1__getPropertiesResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getPropertiesResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getPropertiesResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneSearch")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneSearch;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneSearch);
      if (size)
        *size = sizeof(ns1__luceneSearch);
      ((ns1__luceneSearch *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneSearch, n);
      if (size)
        *size = n * sizeof(ns1__luceneSearch);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneSearch *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneSearch *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneSearchResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneSearchResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneSearchResponse);
      if (size)
        *size = sizeof(ns1__luceneSearchResponse);
      ((ns1__luceneSearchResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneSearchResponse, n);
      if (size)
        *size = n * sizeof(ns1__luceneSearchResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneSearchResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneSearchResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:lucenePopulate")) {
    cp->type = SOAP_TYPE_ICat4_ns1__lucenePopulate;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__lucenePopulate);
      if (size)
        *size = sizeof(ns1__lucenePopulate);
      ((ns1__lucenePopulate *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__lucenePopulate, n);
      if (size)
        *size = n * sizeof(ns1__lucenePopulate);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__lucenePopulate *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__lucenePopulate *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:lucenePopulateResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__lucenePopulateResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__lucenePopulateResponse);
      if (size)
        *size = sizeof(ns1__lucenePopulateResponse);
      ((ns1__lucenePopulateResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__lucenePopulateResponse, n);
      if (size)
        *size = n * sizeof(ns1__lucenePopulateResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__lucenePopulateResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__lucenePopulateResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:get")) {
    cp->type = SOAP_TYPE_ICat4_ns1__get;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__get);
      if (size)
        *size = sizeof(ns1__get);
      ((ns1__get *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__get, n);
      if (size)
        *size = n * sizeof(ns1__get);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__get *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__get *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getResponse);
      if (size)
        *size = sizeof(ns1__getResponse);
      ((ns1__getResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getResponse, n);
      if (size)
        *size = n * sizeof(ns1__getResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getEntityNames")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getEntityNames;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getEntityNames);
      if (size)
        *size = sizeof(ns1__getEntityNames);
      ((ns1__getEntityNames *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityNames, n);
      if (size)
        *size = n * sizeof(ns1__getEntityNames);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getEntityNames *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getEntityNames *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getEntityNamesResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getEntityNamesResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getEntityNamesResponse);
      if (size)
        *size = sizeof(ns1__getEntityNamesResponse);
      ((ns1__getEntityNamesResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityNamesResponse, n);
      if (size)
        *size = n * sizeof(ns1__getEntityNamesResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getEntityNamesResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getEntityNamesResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getApiVersion")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getApiVersion;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getApiVersion);
      if (size)
        *size = sizeof(ns1__getApiVersion);
      ((ns1__getApiVersion *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getApiVersion, n);
      if (size)
        *size = n * sizeof(ns1__getApiVersion);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getApiVersion *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getApiVersion *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getApiVersionResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getApiVersionResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getApiVersionResponse);
      if (size)
        *size = sizeof(ns1__getApiVersionResponse);
      ((ns1__getApiVersionResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getApiVersionResponse, n);
      if (size)
        *size = n * sizeof(ns1__getApiVersionResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getApiVersionResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getApiVersionResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneGetPopulating")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneGetPopulating;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneGetPopulating);
      if (size)
        *size = sizeof(ns1__luceneGetPopulating);
      ((ns1__luceneGetPopulating *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneGetPopulating, n);
      if (size)
        *size = n * sizeof(ns1__luceneGetPopulating);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneGetPopulating *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneGetPopulating *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneGetPopulatingResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneGetPopulatingResponse);
      if (size)
        *size = sizeof(ns1__luceneGetPopulatingResponse);
      ((ns1__luceneGetPopulatingResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneGetPopulatingResponse, n);
      if (size)
        *size = n * sizeof(ns1__luceneGetPopulatingResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneGetPopulatingResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneGetPopulatingResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:update")) {
    cp->type = SOAP_TYPE_ICat4_ns1__update;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__update);
      if (size)
        *size = sizeof(ns1__update);
      ((ns1__update *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__update, n);
      if (size)
        *size = n * sizeof(ns1__update);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__update *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__update *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:updateResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__updateResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__updateResponse);
      if (size)
        *size = sizeof(ns1__updateResponse);
      ((ns1__updateResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__updateResponse, n);
      if (size)
        *size = n * sizeof(ns1__updateResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__updateResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__updateResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:deleteMany")) {
    cp->type = SOAP_TYPE_ICat4_ns1__deleteMany;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__deleteMany);
      if (size)
        *size = sizeof(ns1__deleteMany);
      ((ns1__deleteMany *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteMany, n);
      if (size)
        *size = n * sizeof(ns1__deleteMany);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__deleteMany *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__deleteMany *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:deleteManyResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__deleteManyResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__deleteManyResponse);
      if (size)
        *size = sizeof(ns1__deleteManyResponse);
      ((ns1__deleteManyResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteManyResponse, n);
      if (size)
        *size = n * sizeof(ns1__deleteManyResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__deleteManyResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__deleteManyResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getUserName")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getUserName;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getUserName);
      if (size)
        *size = sizeof(ns1__getUserName);
      ((ns1__getUserName *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getUserName, n);
      if (size)
        *size = n * sizeof(ns1__getUserName);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getUserName *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getUserName *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getUserNameResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getUserNameResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getUserNameResponse);
      if (size)
        *size = sizeof(ns1__getUserNameResponse);
      ((ns1__getUserNameResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getUserNameResponse, n);
      if (size)
        *size = n * sizeof(ns1__getUserNameResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getUserNameResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getUserNameResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:refresh")) {
    cp->type = SOAP_TYPE_ICat4_ns1__refresh;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__refresh);
      if (size)
        *size = sizeof(ns1__refresh);
      ((ns1__refresh *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__refresh, n);
      if (size)
        *size = n * sizeof(ns1__refresh);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__refresh *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__refresh *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:refreshResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__refreshResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__refreshResponse);
      if (size)
        *size = sizeof(ns1__refreshResponse);
      ((ns1__refreshResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__refreshResponse, n);
      if (size)
        *size = n * sizeof(ns1__refreshResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__refreshResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__refreshResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:login")) {
    cp->type = SOAP_TYPE_ICat4_ns1__login;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__login);
      if (size)
        *size = sizeof(ns1__login);
      ((ns1__login *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__login, n);
      if (size)
        *size = n * sizeof(ns1__login);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__login *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__login *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:loginResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__loginResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__loginResponse);
      if (size)
        *size = sizeof(ns1__loginResponse);
      ((ns1__loginResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__loginResponse, n);
      if (size)
        *size = n * sizeof(ns1__loginResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__loginResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__loginResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dummy")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dummy;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dummy);
      if (size)
        *size = sizeof(ns1__dummy);
      ((ns1__dummy *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dummy, n);
      if (size)
        *size = n * sizeof(ns1__dummy);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dummy *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dummy *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dummyResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dummyResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dummyResponse);
      if (size)
        *size = sizeof(ns1__dummyResponse);
      ((ns1__dummyResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dummyResponse, n);
      if (size)
        *size = n * sizeof(ns1__dummyResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dummyResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dummyResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getEntityInfo")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getEntityInfo;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getEntityInfo);
      if (size)
        *size = sizeof(ns1__getEntityInfo);
      ((ns1__getEntityInfo *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityInfo, n);
      if (size)
        *size = n * sizeof(ns1__getEntityInfo);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getEntityInfo *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getEntityInfo *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getEntityInfoResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getEntityInfoResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getEntityInfoResponse);
      if (size)
        *size = sizeof(ns1__getEntityInfoResponse);
      ((ns1__getEntityInfoResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getEntityInfoResponse, n);
      if (size)
        *size = n * sizeof(ns1__getEntityInfoResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getEntityInfoResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getEntityInfoResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:entityInfo")) {
    cp->type = SOAP_TYPE_ICat4_ns1__entityInfo;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__entityInfo);
      if (size)
        *size = sizeof(ns1__entityInfo);
      ((ns1__entityInfo *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityInfo, n);
      if (size)
        *size = n * sizeof(ns1__entityInfo);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__entityInfo *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__entityInfo *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:constraint")) {
    cp->type = SOAP_TYPE_ICat4_ns1__constraint;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__constraint);
      if (size)
        *size = sizeof(ns1__constraint);
      ((ns1__constraint *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__constraint, n);
      if (size)
        *size = n * sizeof(ns1__constraint);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__constraint *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__constraint *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:entityField")) {
    cp->type = SOAP_TYPE_ICat4_ns1__entityField;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__entityField);
      if (size)
        *size = sizeof(ns1__entityField);
      ((ns1__entityField *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__entityField, n);
      if (size)
        *size = n * sizeof(ns1__entityField);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__entityField *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__entityField *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneCommit")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneCommit;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneCommit);
      if (size)
        *size = sizeof(ns1__luceneCommit);
      ((ns1__luceneCommit *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneCommit, n);
      if (size)
        *size = n * sizeof(ns1__luceneCommit);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneCommit *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneCommit *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:luceneCommitResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__luceneCommitResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__luceneCommitResponse);
      if (size)
        *size = sizeof(ns1__luceneCommitResponse);
      ((ns1__luceneCommitResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__luceneCommitResponse, n);
      if (size)
        *size = n * sizeof(ns1__luceneCommitResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__luceneCommitResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__luceneCommitResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:searchText")) {
    cp->type = SOAP_TYPE_ICat4_ns1__searchText;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__searchText);
      if (size)
        *size = sizeof(ns1__searchText);
      ((ns1__searchText *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchText, n);
      if (size)
        *size = n * sizeof(ns1__searchText);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__searchText *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__searchText *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:searchTextResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__searchTextResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__searchTextResponse);
      if (size)
        *size = sizeof(ns1__searchTextResponse);
      ((ns1__searchTextResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchTextResponse, n);
      if (size)
        *size = n * sizeof(ns1__searchTextResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__searchTextResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__searchTextResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:delete")) {
    cp->type = SOAP_TYPE_ICat4_ns1__delete;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__delete);
      if (size)
        *size = sizeof(ns1__delete);
      ((ns1__delete *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__delete, n);
      if (size)
        *size = n * sizeof(ns1__delete);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__delete *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__delete *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:deleteResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__deleteResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__deleteResponse);
      if (size)
        *size = sizeof(ns1__deleteResponse);
      ((ns1__deleteResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__deleteResponse, n);
      if (size)
        *size = n * sizeof(ns1__deleteResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__deleteResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__deleteResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:isAccessAllowed")) {
    cp->type = SOAP_TYPE_ICat4_ns1__isAccessAllowed;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__isAccessAllowed);
      if (size)
        *size = sizeof(ns1__isAccessAllowed);
      ((ns1__isAccessAllowed *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__isAccessAllowed, n);
      if (size)
        *size = n * sizeof(ns1__isAccessAllowed);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__isAccessAllowed *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__isAccessAllowed *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:isAccessAllowedResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__isAccessAllowedResponse);
      if (size)
        *size = sizeof(ns1__isAccessAllowedResponse);
      ((ns1__isAccessAllowedResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__isAccessAllowedResponse, n);
      if (size)
        *size = n * sizeof(ns1__isAccessAllowedResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__isAccessAllowedResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__isAccessAllowedResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:search")) {
    cp->type = SOAP_TYPE_ICat4_ns1__search;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__search);
      if (size)
        *size = sizeof(ns1__search);
      ((ns1__search *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__search, n);
      if (size)
        *size = n * sizeof(ns1__search);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__search *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__search *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:searchResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__searchResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__searchResponse);
      if (size)
        *size = sizeof(ns1__searchResponse);
      ((ns1__searchResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__searchResponse, n);
      if (size)
        *size = n * sizeof(ns1__searchResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__searchResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__searchResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:logout")) {
    cp->type = SOAP_TYPE_ICat4_ns1__logout;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__logout);
      if (size)
        *size = sizeof(ns1__logout);
      ((ns1__logout *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__logout, n);
      if (size)
        *size = n * sizeof(ns1__logout);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__logout *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__logout *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:logoutResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__logoutResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__logoutResponse);
      if (size)
        *size = sizeof(ns1__logoutResponse);
      ((ns1__logoutResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__logoutResponse, n);
      if (size)
        *size = n * sizeof(ns1__logoutResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__logoutResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__logoutResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getRemainingMinutes")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getRemainingMinutes;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getRemainingMinutes);
      if (size)
        *size = sizeof(ns1__getRemainingMinutes);
      ((ns1__getRemainingMinutes *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getRemainingMinutes, n);
      if (size)
        *size = n * sizeof(ns1__getRemainingMinutes);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getRemainingMinutes *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getRemainingMinutes *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:getRemainingMinutesResponse")) {
    cp->type = SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__getRemainingMinutesResponse);
      if (size)
        *size = sizeof(ns1__getRemainingMinutesResponse);
      ((ns1__getRemainingMinutesResponse *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__getRemainingMinutesResponse, n);
      if (size)
        *size = n * sizeof(ns1__getRemainingMinutesResponse);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__getRemainingMinutesResponse *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__getRemainingMinutesResponse *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafile);
      if (size)
        *size = sizeof(ns1__datafile);
      ((ns1__datafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafile, n);
      if (size)
        *size = n * sizeof(ns1__datafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionDatafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionDatafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDatafile);
      if (size)
        *size = sizeof(ns1__dataCollectionDatafile);
      ((ns1__dataCollectionDatafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDatafile, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionDatafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionDatafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionDatafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollection")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollection;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollection);
      if (size)
        *size = sizeof(ns1__dataCollection);
      ((ns1__dataCollection *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollection, n);
      if (size)
        *size = n * sizeof(ns1__dataCollection);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollection *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollection *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionDataset")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionDataset;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionDataset);
      if (size)
        *size = sizeof(ns1__dataCollectionDataset);
      ((ns1__dataCollectionDataset *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionDataset, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionDataset);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionDataset *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionDataset *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataset")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataset;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataset);
      if (size)
        *size = sizeof(ns1__dataset);
      ((ns1__dataset *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataset, n);
      if (size)
        *size = n * sizeof(ns1__dataset);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataset *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataset *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigation")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigation;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigation);
      if (size)
        *size = sizeof(ns1__investigation);
      ((ns1__investigation *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigation, n);
      if (size)
        *size = n * sizeof(ns1__investigation);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigation *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigation *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:facility")) {
    cp->type = SOAP_TYPE_ICat4_ns1__facility;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__facility);
      if (size)
        *size = sizeof(ns1__facility);
      ((ns1__facility *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facility, n);
      if (size)
        *size = n * sizeof(ns1__facility);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__facility *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__facility *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:application")) {
    cp->type = SOAP_TYPE_ICat4_ns1__application;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__application);
      if (size)
        *size = sizeof(ns1__application);
      ((ns1__application *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__application, n);
      if (size)
        *size = n * sizeof(ns1__application);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__application *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__application *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:job")) {
    cp->type = SOAP_TYPE_ICat4_ns1__job;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__job);
      if (size)
        *size = sizeof(ns1__job);
      ((ns1__job *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__job, n);
      if (size)
        *size = n * sizeof(ns1__job);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__job *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__job *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafileFormat")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafileFormat;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafileFormat);
      if (size)
        *size = sizeof(ns1__datafileFormat);
      ((ns1__datafileFormat *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileFormat, n);
      if (size)
        *size = n * sizeof(ns1__datafileFormat);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafileFormat *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafileFormat *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datasetType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datasetType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datasetType);
      if (size)
        *size = sizeof(ns1__datasetType);
      ((ns1__datasetType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetType, n);
      if (size)
        *size = n * sizeof(ns1__datasetType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datasetType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datasetType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:facilityCycle")) {
    cp->type = SOAP_TYPE_ICat4_ns1__facilityCycle;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__facilityCycle);
      if (size)
        *size = sizeof(ns1__facilityCycle);
      ((ns1__facilityCycle *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__facilityCycle, n);
      if (size)
        *size = n * sizeof(ns1__facilityCycle);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__facilityCycle *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__facilityCycle *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:instrument")) {
    cp->type = SOAP_TYPE_ICat4_ns1__instrument;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__instrument);
      if (size)
        *size = sizeof(ns1__instrument);
      ((ns1__instrument *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrument, n);
      if (size)
        *size = n * sizeof(ns1__instrument);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__instrument *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__instrument *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:instrumentScientist")) {
    cp->type = SOAP_TYPE_ICat4_ns1__instrumentScientist;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__instrumentScientist);
      if (size)
        *size = sizeof(ns1__instrumentScientist);
      ((ns1__instrumentScientist *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__instrumentScientist, n);
      if (size)
        *size = n * sizeof(ns1__instrumentScientist);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__instrumentScientist *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__instrumentScientist *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:user")) {
    cp->type = SOAP_TYPE_ICat4_ns1__user;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__user);
      if (size)
        *size = sizeof(ns1__user);
      ((ns1__user *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__user, n);
      if (size)
        *size = n * sizeof(ns1__user);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__user *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__user *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationUser")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationUser;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationUser);
      if (size)
        *size = sizeof(ns1__investigationUser);
      ((ns1__investigationUser *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationUser, n);
      if (size)
        *size = n * sizeof(ns1__investigationUser);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationUser *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationUser *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:study")) {
    cp->type = SOAP_TYPE_ICat4_ns1__study;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__study);
      if (size)
        *size = sizeof(ns1__study);
      ((ns1__study *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__study, n);
      if (size)
        *size = n * sizeof(ns1__study);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__study *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__study *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:studyInvestigation")) {
    cp->type = SOAP_TYPE_ICat4_ns1__studyInvestigation;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__studyInvestigation);
      if (size)
        *size = sizeof(ns1__studyInvestigation);
      ((ns1__studyInvestigation *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__studyInvestigation, n);
      if (size)
        *size = n * sizeof(ns1__studyInvestigation);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__studyInvestigation *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__studyInvestigation *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:userGroup")) {
    cp->type = SOAP_TYPE_ICat4_ns1__userGroup;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__userGroup);
      if (size)
        *size = sizeof(ns1__userGroup);
      ((ns1__userGroup *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__userGroup, n);
      if (size)
        *size = n * sizeof(ns1__userGroup);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__userGroup *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__userGroup *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:grouping")) {
    cp->type = SOAP_TYPE_ICat4_ns1__grouping;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__grouping);
      if (size)
        *size = sizeof(ns1__grouping);
      ((ns1__grouping *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__grouping, n);
      if (size)
        *size = n * sizeof(ns1__grouping);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__grouping *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__grouping *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:rule")) {
    cp->type = SOAP_TYPE_ICat4_ns1__rule;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__rule);
      if (size)
        *size = sizeof(ns1__rule);
      ((ns1__rule *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__rule, n);
      if (size)
        *size = n * sizeof(ns1__rule);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__rule *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__rule *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationInstrument")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationInstrument;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationInstrument);
      if (size)
        *size = sizeof(ns1__investigationInstrument);
      ((ns1__investigationInstrument *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationInstrument, n);
      if (size)
        *size = n * sizeof(ns1__investigationInstrument);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationInstrument *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationInstrument *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationType);
      if (size)
        *size = sizeof(ns1__investigationType);
      ((ns1__investigationType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationType, n);
      if (size)
        *size = n * sizeof(ns1__investigationType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:parameterType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__parameterType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__parameterType);
      if (size)
        *size = sizeof(ns1__parameterType);
      ((ns1__parameterType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameterType, n);
      if (size)
        *size = n * sizeof(ns1__parameterType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__parameterType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__parameterType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:parameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__parameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__parameter);
      if (size)
        *size = sizeof(ns1__parameter);
      ((ns1__parameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__parameter, n);
      if (size)
        *size = n * sizeof(ns1__parameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__parameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__parameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:permissibleStringValue")) {
    cp->type = SOAP_TYPE_ICat4_ns1__permissibleStringValue;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__permissibleStringValue);
      if (size)
        *size = sizeof(ns1__permissibleStringValue);
      ((ns1__permissibleStringValue *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__permissibleStringValue, n);
      if (size)
        *size = n * sizeof(ns1__permissibleStringValue);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__permissibleStringValue *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__permissibleStringValue *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sample")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sample;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sample);
      if (size)
        *size = sizeof(ns1__sample);
      ((ns1__sample *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sample, n);
      if (size)
        *size = n * sizeof(ns1__sample);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sample *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sample *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sampleType")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sampleType;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sampleType);
      if (size)
        *size = sizeof(ns1__sampleType);
      ((ns1__sampleType *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleType, n);
      if (size)
        *size = n * sizeof(ns1__sampleType);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sampleType *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sampleType *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:keyword")) {
    cp->type = SOAP_TYPE_ICat4_ns1__keyword;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__keyword);
      if (size)
        *size = sizeof(ns1__keyword);
      ((ns1__keyword *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__keyword, n);
      if (size)
        *size = n * sizeof(ns1__keyword);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__keyword *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__keyword *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:publication")) {
    cp->type = SOAP_TYPE_ICat4_ns1__publication;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__publication);
      if (size)
        *size = sizeof(ns1__publication);
      ((ns1__publication *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publication, n);
      if (size)
        *size = n * sizeof(ns1__publication);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__publication *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__publication *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:shift")) {
    cp->type = SOAP_TYPE_ICat4_ns1__shift;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__shift);
      if (size)
        *size = sizeof(ns1__shift);
      ((ns1__shift *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__shift, n);
      if (size)
        *size = n * sizeof(ns1__shift);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__shift *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__shift *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:relatedDatafile")) {
    cp->type = SOAP_TYPE_ICat4_ns1__relatedDatafile;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__relatedDatafile);
      if (size)
        *size = sizeof(ns1__relatedDatafile);
      ((ns1__relatedDatafile *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__relatedDatafile, n);
      if (size)
        *size = n * sizeof(ns1__relatedDatafile);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__relatedDatafile *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__relatedDatafile *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:log")) {
    cp->type = SOAP_TYPE_ICat4_ns1__log;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__log);
      if (size)
        *size = sizeof(ns1__log);
      ((ns1__log *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__log, n);
      if (size)
        *size = n * sizeof(ns1__log);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__log *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__log *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:publicStep")) {
    cp->type = SOAP_TYPE_ICat4_ns1__publicStep;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__publicStep);
      if (size)
        *size = sizeof(ns1__publicStep);
      ((ns1__publicStep *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__publicStep, n);
      if (size)
        *size = n * sizeof(ns1__publicStep);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__publicStep *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__publicStep *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:dataCollectionParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__dataCollectionParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__dataCollectionParameter);
      if (size)
        *size = sizeof(ns1__dataCollectionParameter);
      ((ns1__dataCollectionParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__dataCollectionParameter, n);
      if (size)
        *size = n * sizeof(ns1__dataCollectionParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__dataCollectionParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__dataCollectionParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datafileParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datafileParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datafileParameter);
      if (size)
        *size = sizeof(ns1__datafileParameter);
      ((ns1__datafileParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datafileParameter, n);
      if (size)
        *size = n * sizeof(ns1__datafileParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datafileParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datafileParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:datasetParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__datasetParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__datasetParameter);
      if (size)
        *size = sizeof(ns1__datasetParameter);
      ((ns1__datasetParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__datasetParameter, n);
      if (size)
        *size = n * sizeof(ns1__datasetParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__datasetParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__datasetParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:investigationParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__investigationParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__investigationParameter);
      if (size)
        *size = sizeof(ns1__investigationParameter);
      ((ns1__investigationParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__investigationParameter, n);
      if (size)
        *size = n * sizeof(ns1__investigationParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__investigationParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__investigationParameter *)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "ns1:sampleParameter")) {
    cp->type = SOAP_TYPE_ICat4_ns1__sampleParameter;
    if (n < 0) {
      cp->ptr = (void *)SOAP_NEW(ns1__sampleParameter);
      if (size)
        *size = sizeof(ns1__sampleParameter);
      ((ns1__sampleParameter *)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void *)SOAP_NEW_ARRAY(ns1__sampleParameter, n);
      if (size)
        *size = n * sizeof(ns1__sampleParameter);
      if (cp->ptr)
        for (int i = 0; i < n; i++)
          ((ns1__sampleParameter *)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    if (!cp->ptr)
      soap->error = SOAP_EOM;
    return (ns1__sampleParameter *)cp->ptr;
  }
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(xsd__anyType);
    if (size)
      *size = sizeof(xsd__anyType);
    ((xsd__anyType *)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(xsd__anyType, n);
    if (size)
      *size = n * sizeof(xsd__anyType);
    if (cp->ptr)
      for (int i = 0; i < n; i++)
        ((xsd__anyType *)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (xsd__anyType *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
  *(xsd__anyType *)p = *(xsd__anyType *)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = NULL;
  a->SOAP_ENV__Code = NULL;
  a->SOAP_ENV__Reason = NULL;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id,
                                                   const struct SOAP_ENV__Fault *a, const char *type) {
  const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_SOAP_ENV__Fault), type))
    return soap->error;
  if (soap_out__QName(soap, "faultcode", -1, (char *const *)&soap_tmp_faultcode, ""))
    return soap->error;
  if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
    return soap->error;
  if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault *SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag,
                                                                      struct SOAP_ENV__Fault *a, const char *type) {
  size_t soap_flag_faultcode = 1;
  size_t soap_flag_faultstring = 1;
  size_t soap_flag_faultactor = 1;
  size_t soap_flag_detail = 1;
  size_t soap_flag_SOAP_ENV__Code = 1;
  size_t soap_flag_SOAP_ENV__Reason = 1;
  size_t soap_flag_SOAP_ENV__Node = 1;
  size_t soap_flag_SOAP_ENV__Role = 1;
  size_t soap_flag_SOAP_ENV__Detail = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_SOAP_ENV__Fault,
                                              sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Fault(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "faultcode", &a->faultcode, "")) {
          soap_flag_faultcode--;
          continue;
        }
      if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string")) {
          soap_flag_faultstring--;
          continue;
        }
      if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string")) {
          soap_flag_faultactor--;
          continue;
        }
      if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "")) {
          soap_flag_detail--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, "")) {
          soap_flag_SOAP_ENV__Code--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, "")) {
          soap_flag_SOAP_ENV__Reason--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string")) {
          soap_flag_SOAP_ENV__Node--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string")) {
          soap_flag_SOAP_ENV__Role--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, "")) {
          soap_flag_SOAP_ENV__Detail--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_SOAP_ENV__Fault, 0,
                                                  sizeof(struct SOAP_ENV__Fault), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag,
                                                   const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_SOAP_ENV__Fault);
  if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault *SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p,
                                                                       const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault *SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n,
                                                                               const char *type, const char *arrayType,
                                                                               size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ICat4_SOAP_ENV__Fault, n, ICat4_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Fault);
    if (size)
      *size = sizeof(struct SOAP_ENV__Fault);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Fault);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Fault *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len,
                                                     const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
  *(struct SOAP_ENV__Fault *)p = *(struct SOAP_ENV__Fault *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id,
                                                    const struct SOAP_ENV__Reason *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_SOAP_ENV__Reason), type))
    return soap->error;
  if (soap->lang)
    soap_set_attr(soap, "xml:lang", soap->lang, 1);
  if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason *SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag,
                                                                        struct SOAP_ENV__Reason *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Text = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_SOAP_ENV__Reason,
                                               sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Reason(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string")) {
          soap_flag_SOAP_ENV__Text--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_SOAP_ENV__Reason, 0,
                                                   sizeof(struct SOAP_ENV__Reason), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a,
                                                    const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_SOAP_ENV__Reason);
  if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason *SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p,
                                                                         const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason *SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n,
                                                                                 const char *type,
                                                                                 const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ICat4_SOAP_ENV__Reason, n, ICat4_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Reason);
    if (size)
      *size = sizeof(struct SOAP_ENV__Reason);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Reason);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Reason *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
  *(struct SOAP_ENV__Reason *)p = *(struct SOAP_ENV__Reason *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id,
                                                  const struct SOAP_ENV__Code *a, const char *type) {
  const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_SOAP_ENV__Code), type))
    return soap->error;
  if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char *const *)&soap_tmp_SOAP_ENV__Value, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code *SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag,
                                                                    struct SOAP_ENV__Code *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Value = 1;
  size_t soap_flag_SOAP_ENV__Subcode = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_SOAP_ENV__Code,
                                             sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Code(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, "")) {
          soap_flag_SOAP_ENV__Value--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, "")) {
          soap_flag_SOAP_ENV__Subcode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_SOAP_ENV__Code, 0,
                                                 sizeof(struct SOAP_ENV__Code), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag,
                                                  const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_SOAP_ENV__Code);
  if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code *SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p,
                                                                     const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code *SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type,
                                                                             const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ICat4_SOAP_ENV__Code, n, ICat4_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Code);
    if (size)
      *size = sizeof(struct SOAP_ENV__Code);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Code);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Code *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len,
                                                    const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
  *(struct SOAP_ENV__Code *)p = *(struct SOAP_ENV__Code *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id,
                                                    const struct SOAP_ENV__Header *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_SOAP_ENV__Header), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header *SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag,
                                                                        struct SOAP_ENV__Header *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_SOAP_ENV__Header,
                                               sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Header(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_SOAP_ENV__Header, 0,
                                                   sizeof(struct SOAP_ENV__Header), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a,
                                                    const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_SOAP_ENV__Header);
  if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header *SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p,
                                                                         const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header *SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n,
                                                                                 const char *type,
                                                                                 const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ICat4_SOAP_ENV__Header, n, ICat4_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Header);
    if (size)
      *size = sizeof(struct SOAP_ENV__Header);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Header);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Header *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
  *(struct SOAP_ENV__Header *)p = *(struct SOAP_ENV__Header *)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityInfo(struct soap *soap, struct __ns1__getEntityInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getEntityInfo_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityInfo(struct soap *soap,
                                                               const struct __ns1__getEntityInfo *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getEntityInfo(soap, &a->ns1__getEntityInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityInfo(struct soap *soap, const char *tag, int id,
                                                        const struct __ns1__getEntityInfo *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getEntityInfo(soap, "ns1:getEntityInfo", -1, &a->ns1__getEntityInfo_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityInfo *SOAP_FMAC4 soap_in___ns1__getEntityInfo(struct soap *soap, const char *tag,
                                                                                struct __ns1__getEntityInfo *a,
                                                                                const char *type) {
  size_t soap_flag_ns1__getEntityInfo_ = 1;
  short soap_flag;
  a = (struct __ns1__getEntityInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getEntityInfo,
                                                   sizeof(struct __ns1__getEntityInfo), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getEntityInfo(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getEntityInfo_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getEntityInfo(soap, "ns1:getEntityInfo", &a->ns1__getEntityInfo_,
                                              "ns1:getEntityInfo")) {
        soap_flag_ns1__getEntityInfo_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityInfo(struct soap *soap, const struct __ns1__getEntityInfo *a,
                                                        const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getEntityInfo(soap, tag ? tag : "-ns1:getEntityInfo", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityInfo *SOAP_FMAC4 soap_get___ns1__getEntityInfo(struct soap *soap,
                                                                                 struct __ns1__getEntityInfo *p,
                                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__getEntityInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getEntityInfo *SOAP_FMAC2 soap_instantiate___ns1__getEntityInfo(struct soap *soap, int n,
                                                                                         const char *type,
                                                                                         const char *arrayType,
                                                                                         size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityInfo(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getEntityInfo, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getEntityInfo);
    if (size)
      *size = sizeof(struct __ns1__getEntityInfo);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getEntityInfo, n);
    if (size)
      *size = n * sizeof(struct __ns1__getEntityInfo);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getEntityInfo *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEntityInfo(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEntityInfo %p -> %p\n", q, p));
  *(struct __ns1__getEntityInfo *)p = *(struct __ns1__getEntityInfo *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteMany(struct soap *soap, struct __ns1__deleteMany *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__deleteMany_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteMany(struct soap *soap, const struct __ns1__deleteMany *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__deleteMany(soap, &a->ns1__deleteMany_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteMany(struct soap *soap, const char *tag, int id,
                                                     const struct __ns1__deleteMany *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__deleteMany(soap, "ns1:deleteMany", -1, &a->ns1__deleteMany_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMany *SOAP_FMAC4 soap_in___ns1__deleteMany(struct soap *soap, const char *tag,
                                                                          struct __ns1__deleteMany *a,
                                                                          const char *type) {
  size_t soap_flag_ns1__deleteMany_ = 1;
  short soap_flag;
  a = (struct __ns1__deleteMany *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__deleteMany,
                                                sizeof(struct __ns1__deleteMany), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__deleteMany(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__deleteMany_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__deleteMany(soap, "ns1:deleteMany", &a->ns1__deleteMany_, "ns1:deleteMany")) {
        soap_flag_ns1__deleteMany_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteMany(struct soap *soap, const struct __ns1__deleteMany *a,
                                                     const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__deleteMany(soap, tag ? tag : "-ns1:deleteMany", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMany *SOAP_FMAC4 soap_get___ns1__deleteMany(struct soap *soap,
                                                                           struct __ns1__deleteMany *p, const char *tag,
                                                                           const char *type) {
  if ((p = soap_in___ns1__deleteMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__deleteMany *SOAP_FMAC2 soap_instantiate___ns1__deleteMany(struct soap *soap, int n,
                                                                                   const char *type,
                                                                                   const char *arrayType,
                                                                                   size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteMany(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__deleteMany, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__deleteMany);
    if (size)
      *size = sizeof(struct __ns1__deleteMany);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__deleteMany, n);
    if (size)
      *size = n * sizeof(struct __ns1__deleteMany);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__deleteMany *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteMany(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteMany %p -> %p\n", q, p));
  *(struct __ns1__deleteMany *)p = *(struct __ns1__deleteMany *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteManyResponse(struct soap *soap,
                                                                  struct __ns1__deleteManyResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__deleteManyResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteManyResponse(struct soap *soap,
                                                                    const struct __ns1__deleteManyResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__deleteManyResponse(soap, &a->ns1__deleteManyResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteManyResponse(struct soap *soap, const char *tag, int id,
                                                             const struct __ns1__deleteManyResponse *a,
                                                             const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__deleteManyResponse_)
    soap_element_result(soap, "ns1:deleteManyResponse");
  if (soap_out_PointerTons1__deleteManyResponse(soap, "ns1:deleteManyResponse", -1, &a->ns1__deleteManyResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteManyResponse *SOAP_FMAC4 soap_in___ns1__deleteManyResponse(
    struct soap *soap, const char *tag, struct __ns1__deleteManyResponse *a, const char *type) {
  size_t soap_flag_ns1__deleteManyResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__deleteManyResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__deleteManyResponse,
                                                        sizeof(struct __ns1__deleteManyResponse), 0, nullptr, nullptr,
                                                        nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__deleteManyResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__deleteManyResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__deleteManyResponse(soap, "ns1:deleteManyResponse", &a->ns1__deleteManyResponse_,
                                                   "ns1:deleteManyResponse")) {
        soap_flag_ns1__deleteManyResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:deleteManyResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteManyResponse(struct soap *soap,
                                                             const struct __ns1__deleteManyResponse *a, const char *tag,
                                                             const char *type) {
  int id = 0;
  if (soap_out___ns1__deleteManyResponse(soap, tag ? tag : "-ns1:deleteManyResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteManyResponse *SOAP_FMAC4 soap_get___ns1__deleteManyResponse(
    struct soap *soap, struct __ns1__deleteManyResponse *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__deleteManyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__deleteManyResponse *SOAP_FMAC2 soap_instantiate___ns1__deleteManyResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteManyResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__deleteManyResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__deleteManyResponse);
    if (size)
      *size = sizeof(struct __ns1__deleteManyResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__deleteManyResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__deleteManyResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__deleteManyResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteManyResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                               const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteManyResponse %p -> %p\n", q, p));
  *(struct __ns1__deleteManyResponse *)p = *(struct __ns1__deleteManyResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createMany(struct soap *soap, struct __ns1__createMany *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__createMany_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createMany(struct soap *soap, const struct __ns1__createMany *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__createMany(soap, &a->ns1__createMany_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createMany(struct soap *soap, const char *tag, int id,
                                                     const struct __ns1__createMany *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__createMany(soap, "ns1:createMany", -1, &a->ns1__createMany_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createMany *SOAP_FMAC4 soap_in___ns1__createMany(struct soap *soap, const char *tag,
                                                                          struct __ns1__createMany *a,
                                                                          const char *type) {
  size_t soap_flag_ns1__createMany_ = 1;
  short soap_flag;
  a = (struct __ns1__createMany *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__createMany,
                                                sizeof(struct __ns1__createMany), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__createMany(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__createMany_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__createMany(soap, "ns1:createMany", &a->ns1__createMany_, "ns1:createMany")) {
        soap_flag_ns1__createMany_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createMany(struct soap *soap, const struct __ns1__createMany *a,
                                                     const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__createMany(soap, tag ? tag : "-ns1:createMany", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createMany *SOAP_FMAC4 soap_get___ns1__createMany(struct soap *soap,
                                                                           struct __ns1__createMany *p, const char *tag,
                                                                           const char *type) {
  if ((p = soap_in___ns1__createMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__createMany *SOAP_FMAC2 soap_instantiate___ns1__createMany(struct soap *soap, int n,
                                                                                   const char *type,
                                                                                   const char *arrayType,
                                                                                   size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createMany(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__createMany, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__createMany);
    if (size)
      *size = sizeof(struct __ns1__createMany);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__createMany, n);
    if (size)
      *size = n * sizeof(struct __ns1__createMany);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__createMany *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createMany(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createMany %p -> %p\n", q, p));
  *(struct __ns1__createMany *)p = *(struct __ns1__createMany *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneGetPopulating(struct soap *soap,
                                                                   struct __ns1__luceneGetPopulating *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneGetPopulating_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneGetPopulating(struct soap *soap,
                                                                     const struct __ns1__luceneGetPopulating *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneGetPopulating(soap, &a->ns1__luceneGetPopulating_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneGetPopulating(struct soap *soap, const char *tag, int id,
                                                              const struct __ns1__luceneGetPopulating *a,
                                                              const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__luceneGetPopulating(soap, "ns1:luceneGetPopulating", -1, &a->ns1__luceneGetPopulating_,
                                                 ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneGetPopulating *SOAP_FMAC4 soap_in___ns1__luceneGetPopulating(
    struct soap *soap, const char *tag, struct __ns1__luceneGetPopulating *a, const char *type) {
  size_t soap_flag_ns1__luceneGetPopulating_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneGetPopulating *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneGetPopulating,
                                                         sizeof(struct __ns1__luceneGetPopulating), 0, nullptr, nullptr,
                                                         nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneGetPopulating(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneGetPopulating_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneGetPopulating(soap, "ns1:luceneGetPopulating", &a->ns1__luceneGetPopulating_,
                                                    "ns1:luceneGetPopulating")) {
        soap_flag_ns1__luceneGetPopulating_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneGetPopulating(struct soap *soap,
                                                              const struct __ns1__luceneGetPopulating *a,
                                                              const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneGetPopulating(soap, tag ? tag : "-ns1:luceneGetPopulating", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneGetPopulating *SOAP_FMAC4 soap_get___ns1__luceneGetPopulating(
    struct soap *soap, struct __ns1__luceneGetPopulating *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneGetPopulating(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneGetPopulating *SOAP_FMAC2 soap_instantiate___ns1__luceneGetPopulating(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneGetPopulating(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneGetPopulating, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneGetPopulating);
    if (size)
      *size = sizeof(struct __ns1__luceneGetPopulating);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneGetPopulating, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneGetPopulating);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneGetPopulating *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneGetPopulating(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneGetPopulating %p -> %p\n", q, p));
  *(struct __ns1__luceneGetPopulating *)p = *(struct __ns1__luceneGetPopulating *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneSearch(struct soap *soap, struct __ns1__luceneSearch *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneSearch_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneSearch(struct soap *soap, const struct __ns1__luceneSearch *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneSearch(soap, &a->ns1__luceneSearch_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneSearch(struct soap *soap, const char *tag, int id,
                                                       const struct __ns1__luceneSearch *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__luceneSearch(soap, "ns1:luceneSearch", -1, &a->ns1__luceneSearch_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneSearch *SOAP_FMAC4 soap_in___ns1__luceneSearch(struct soap *soap, const char *tag,
                                                                              struct __ns1__luceneSearch *a,
                                                                              const char *type) {
  size_t soap_flag_ns1__luceneSearch_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneSearch *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneSearch,
                                                  sizeof(struct __ns1__luceneSearch), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneSearch(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneSearch_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneSearch(soap, "ns1:luceneSearch", &a->ns1__luceneSearch_, "ns1:luceneSearch")) {
        soap_flag_ns1__luceneSearch_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneSearch(struct soap *soap, const struct __ns1__luceneSearch *a,
                                                       const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneSearch(soap, tag ? tag : "-ns1:luceneSearch", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneSearch *SOAP_FMAC4 soap_get___ns1__luceneSearch(struct soap *soap,
                                                                               struct __ns1__luceneSearch *p,
                                                                               const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneSearch(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneSearch *SOAP_FMAC2 soap_instantiate___ns1__luceneSearch(struct soap *soap, int n,
                                                                                       const char *type,
                                                                                       const char *arrayType,
                                                                                       size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneSearch(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneSearch, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneSearch);
    if (size)
      *size = sizeof(struct __ns1__luceneSearch);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneSearch, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneSearch);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneSearch *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneSearch(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneSearch %p -> %p\n", q, p));
  *(struct __ns1__luceneSearch *)p = *(struct __ns1__luceneSearch *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneCommit(struct soap *soap, struct __ns1__luceneCommit *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneCommit_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneCommit(struct soap *soap, const struct __ns1__luceneCommit *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneCommit(soap, &a->ns1__luceneCommit_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneCommit(struct soap *soap, const char *tag, int id,
                                                       const struct __ns1__luceneCommit *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__luceneCommit(soap, "ns1:luceneCommit", -1, &a->ns1__luceneCommit_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneCommit *SOAP_FMAC4 soap_in___ns1__luceneCommit(struct soap *soap, const char *tag,
                                                                              struct __ns1__luceneCommit *a,
                                                                              const char *type) {
  size_t soap_flag_ns1__luceneCommit_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneCommit *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneCommit,
                                                  sizeof(struct __ns1__luceneCommit), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneCommit(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneCommit_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneCommit(soap, "ns1:luceneCommit", &a->ns1__luceneCommit_, "ns1:luceneCommit")) {
        soap_flag_ns1__luceneCommit_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneCommit(struct soap *soap, const struct __ns1__luceneCommit *a,
                                                       const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneCommit(soap, tag ? tag : "-ns1:luceneCommit", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneCommit *SOAP_FMAC4 soap_get___ns1__luceneCommit(struct soap *soap,
                                                                               struct __ns1__luceneCommit *p,
                                                                               const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneCommit(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneCommit *SOAP_FMAC2 soap_instantiate___ns1__luceneCommit(struct soap *soap, int n,
                                                                                       const char *type,
                                                                                       const char *arrayType,
                                                                                       size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneCommit(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneCommit, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneCommit);
    if (size)
      *size = sizeof(struct __ns1__luceneCommit);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneCommit, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneCommit);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneCommit *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneCommit(struct soap *soap, int st, int tt, void *p, size_t len,
                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneCommit %p -> %p\n", q, p));
  *(struct __ns1__luceneCommit *)p = *(struct __ns1__luceneCommit *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneCommitResponse(struct soap *soap,
                                                                    struct __ns1__luceneCommitResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneCommitResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneCommitResponse(struct soap *soap,
                                                                      const struct __ns1__luceneCommitResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneCommitResponse(soap, &a->ns1__luceneCommitResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneCommitResponse(struct soap *soap, const char *tag, int id,
                                                               const struct __ns1__luceneCommitResponse *a,
                                                               const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__luceneCommitResponse_)
    soap_element_result(soap, "ns1:luceneCommitResponse");
  if (soap_out_PointerTons1__luceneCommitResponse(soap, "ns1:luceneCommitResponse", -1, &a->ns1__luceneCommitResponse_,
                                                  ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneCommitResponse *SOAP_FMAC4 soap_in___ns1__luceneCommitResponse(
    struct soap *soap, const char *tag, struct __ns1__luceneCommitResponse *a, const char *type) {
  size_t soap_flag_ns1__luceneCommitResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneCommitResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneCommitResponse,
                                                          sizeof(struct __ns1__luceneCommitResponse), 0, nullptr,
                                                          nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneCommitResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneCommitResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneCommitResponse(soap, "ns1:luceneCommitResponse", &a->ns1__luceneCommitResponse_,
                                                     "ns1:luceneCommitResponse")) {
        soap_flag_ns1__luceneCommitResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:luceneCommitResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneCommitResponse(struct soap *soap,
                                                               const struct __ns1__luceneCommitResponse *a,
                                                               const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneCommitResponse(soap, tag ? tag : "-ns1:luceneCommitResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneCommitResponse *SOAP_FMAC4 soap_get___ns1__luceneCommitResponse(
    struct soap *soap, struct __ns1__luceneCommitResponse *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneCommitResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneCommitResponse *SOAP_FMAC2 soap_instantiate___ns1__luceneCommitResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneCommitResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneCommitResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneCommitResponse);
    if (size)
      *size = sizeof(struct __ns1__luceneCommitResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneCommitResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneCommitResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneCommitResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneCommitResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneCommitResponse %p -> %p\n", q, p));
  *(struct __ns1__luceneCommitResponse *)p = *(struct __ns1__luceneCommitResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneClear(struct soap *soap, struct __ns1__luceneClear *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneClear_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneClear(struct soap *soap, const struct __ns1__luceneClear *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneClear(soap, &a->ns1__luceneClear_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneClear(struct soap *soap, const char *tag, int id,
                                                      const struct __ns1__luceneClear *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__luceneClear(soap, "ns1:luceneClear", -1, &a->ns1__luceneClear_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneClear *SOAP_FMAC4 soap_in___ns1__luceneClear(struct soap *soap, const char *tag,
                                                                            struct __ns1__luceneClear *a,
                                                                            const char *type) {
  size_t soap_flag_ns1__luceneClear_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneClear *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneClear,
                                                 sizeof(struct __ns1__luceneClear), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneClear(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneClear_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneClear(soap, "ns1:luceneClear", &a->ns1__luceneClear_, "ns1:luceneClear")) {
        soap_flag_ns1__luceneClear_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneClear(struct soap *soap, const struct __ns1__luceneClear *a,
                                                      const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneClear(soap, tag ? tag : "-ns1:luceneClear", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneClear *SOAP_FMAC4 soap_get___ns1__luceneClear(struct soap *soap,
                                                                             struct __ns1__luceneClear *p,
                                                                             const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneClear(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneClear *SOAP_FMAC2 soap_instantiate___ns1__luceneClear(struct soap *soap, int n,
                                                                                     const char *type,
                                                                                     const char *arrayType,
                                                                                     size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneClear(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneClear, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneClear);
    if (size)
      *size = sizeof(struct __ns1__luceneClear);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneClear, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneClear);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneClear *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneClear(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneClear %p -> %p\n", q, p));
  *(struct __ns1__luceneClear *)p = *(struct __ns1__luceneClear *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__luceneClearResponse(struct soap *soap,
                                                                   struct __ns1__luceneClearResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__luceneClearResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__luceneClearResponse(struct soap *soap,
                                                                     const struct __ns1__luceneClearResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__luceneClearResponse(soap, &a->ns1__luceneClearResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__luceneClearResponse(struct soap *soap, const char *tag, int id,
                                                              const struct __ns1__luceneClearResponse *a,
                                                              const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__luceneClearResponse_)
    soap_element_result(soap, "ns1:luceneClearResponse");
  if (soap_out_PointerTons1__luceneClearResponse(soap, "ns1:luceneClearResponse", -1, &a->ns1__luceneClearResponse_,
                                                 ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneClearResponse *SOAP_FMAC4 soap_in___ns1__luceneClearResponse(
    struct soap *soap, const char *tag, struct __ns1__luceneClearResponse *a, const char *type) {
  size_t soap_flag_ns1__luceneClearResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__luceneClearResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__luceneClearResponse,
                                                         sizeof(struct __ns1__luceneClearResponse), 0, nullptr, nullptr,
                                                         nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__luceneClearResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__luceneClearResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__luceneClearResponse(soap, "ns1:luceneClearResponse", &a->ns1__luceneClearResponse_,
                                                    "ns1:luceneClearResponse")) {
        soap_flag_ns1__luceneClearResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:luceneClearResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__luceneClearResponse(struct soap *soap,
                                                              const struct __ns1__luceneClearResponse *a,
                                                              const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__luceneClearResponse(soap, tag ? tag : "-ns1:luceneClearResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__luceneClearResponse *SOAP_FMAC4 soap_get___ns1__luceneClearResponse(
    struct soap *soap, struct __ns1__luceneClearResponse *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__luceneClearResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__luceneClearResponse *SOAP_FMAC2 soap_instantiate___ns1__luceneClearResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__luceneClearResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__luceneClearResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__luceneClearResponse);
    if (size)
      *size = sizeof(struct __ns1__luceneClearResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__luceneClearResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__luceneClearResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__luceneClearResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__luceneClearResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__luceneClearResponse %p -> %p\n", q, p));
  *(struct __ns1__luceneClearResponse *)p = *(struct __ns1__luceneClearResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lucenePopulate(struct soap *soap, struct __ns1__lucenePopulate *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__lucenePopulate_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lucenePopulate(struct soap *soap,
                                                                const struct __ns1__lucenePopulate *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__lucenePopulate(soap, &a->ns1__lucenePopulate_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lucenePopulate(struct soap *soap, const char *tag, int id,
                                                         const struct __ns1__lucenePopulate *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__lucenePopulate(soap, "ns1:lucenePopulate", -1, &a->ns1__lucenePopulate_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lucenePopulate *SOAP_FMAC4 soap_in___ns1__lucenePopulate(struct soap *soap, const char *tag,
                                                                                  struct __ns1__lucenePopulate *a,
                                                                                  const char *type) {
  size_t soap_flag_ns1__lucenePopulate_ = 1;
  short soap_flag;
  a = (struct __ns1__lucenePopulate *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__lucenePopulate,
                                                    sizeof(struct __ns1__lucenePopulate), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__lucenePopulate(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__lucenePopulate_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__lucenePopulate(soap, "ns1:lucenePopulate", &a->ns1__lucenePopulate_,
                                               "ns1:lucenePopulate")) {
        soap_flag_ns1__lucenePopulate_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lucenePopulate(struct soap *soap, const struct __ns1__lucenePopulate *a,
                                                         const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__lucenePopulate(soap, tag ? tag : "-ns1:lucenePopulate", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lucenePopulate *SOAP_FMAC4 soap_get___ns1__lucenePopulate(struct soap *soap,
                                                                                   struct __ns1__lucenePopulate *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__lucenePopulate(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__lucenePopulate *SOAP_FMAC2 soap_instantiate___ns1__lucenePopulate(struct soap *soap, int n,
                                                                                           const char *type,
                                                                                           const char *arrayType,
                                                                                           size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lucenePopulate(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__lucenePopulate, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__lucenePopulate);
    if (size)
      *size = sizeof(struct __ns1__lucenePopulate);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__lucenePopulate, n);
    if (size)
      *size = n * sizeof(struct __ns1__lucenePopulate);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__lucenePopulate *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lucenePopulate(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lucenePopulate %p -> %p\n", q, p));
  *(struct __ns1__lucenePopulate *)p = *(struct __ns1__lucenePopulate *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lucenePopulateResponse(struct soap *soap,
                                                                      struct __ns1__lucenePopulateResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__lucenePopulateResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lucenePopulateResponse(struct soap *soap,
                                                                        const struct __ns1__lucenePopulateResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__lucenePopulateResponse(soap, &a->ns1__lucenePopulateResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lucenePopulateResponse(struct soap *soap, const char *tag, int id,
                                                                 const struct __ns1__lucenePopulateResponse *a,
                                                                 const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__lucenePopulateResponse_)
    soap_element_result(soap, "ns1:lucenePopulateResponse");
  if (soap_out_PointerTons1__lucenePopulateResponse(soap, "ns1:lucenePopulateResponse", -1,
                                                    &a->ns1__lucenePopulateResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lucenePopulateResponse *SOAP_FMAC4 soap_in___ns1__lucenePopulateResponse(
    struct soap *soap, const char *tag, struct __ns1__lucenePopulateResponse *a, const char *type) {
  size_t soap_flag_ns1__lucenePopulateResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__lucenePopulateResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__lucenePopulateResponse,
                                                            sizeof(struct __ns1__lucenePopulateResponse), 0, nullptr,
                                                            nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__lucenePopulateResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__lucenePopulateResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__lucenePopulateResponse(
              soap, "ns1:lucenePopulateResponse", &a->ns1__lucenePopulateResponse_, "ns1:lucenePopulateResponse")) {
        soap_flag_ns1__lucenePopulateResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:lucenePopulateResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lucenePopulateResponse(struct soap *soap,
                                                                 const struct __ns1__lucenePopulateResponse *a,
                                                                 const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__lucenePopulateResponse(soap, tag ? tag : "-ns1:lucenePopulateResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lucenePopulateResponse *SOAP_FMAC4 soap_get___ns1__lucenePopulateResponse(
    struct soap *soap, struct __ns1__lucenePopulateResponse *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__lucenePopulateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__lucenePopulateResponse *SOAP_FMAC2 soap_instantiate___ns1__lucenePopulateResponse(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lucenePopulateResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__lucenePopulateResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__lucenePopulateResponse);
    if (size)
      *size = sizeof(struct __ns1__lucenePopulateResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__lucenePopulateResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__lucenePopulateResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__lucenePopulateResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lucenePopulateResponse(struct soap *soap, int st, int tt, void *p,
                                                                   size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lucenePopulateResponse %p -> %p\n", q, p));
  *(struct __ns1__lucenePopulateResponse *)p = *(struct __ns1__lucenePopulateResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isAccessAllowed(struct soap *soap, struct __ns1__isAccessAllowed *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__isAccessAllowed_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isAccessAllowed(struct soap *soap,
                                                                 const struct __ns1__isAccessAllowed *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__isAccessAllowed(soap, &a->ns1__isAccessAllowed_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isAccessAllowed(struct soap *soap, const char *tag, int id,
                                                          const struct __ns1__isAccessAllowed *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__isAccessAllowed(soap, "ns1:isAccessAllowed", -1, &a->ns1__isAccessAllowed_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAccessAllowed *SOAP_FMAC4 soap_in___ns1__isAccessAllowed(struct soap *soap, const char *tag,
                                                                                    struct __ns1__isAccessAllowed *a,
                                                                                    const char *type) {
  size_t soap_flag_ns1__isAccessAllowed_ = 1;
  short soap_flag;
  a = (struct __ns1__isAccessAllowed *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__isAccessAllowed,
                                                     sizeof(struct __ns1__isAccessAllowed), 0, nullptr, nullptr,
                                                     nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__isAccessAllowed(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__isAccessAllowed_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__isAccessAllowed(soap, "ns1:isAccessAllowed", &a->ns1__isAccessAllowed_,
                                                "ns1:isAccessAllowed")) {
        soap_flag_ns1__isAccessAllowed_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isAccessAllowed(struct soap *soap, const struct __ns1__isAccessAllowed *a,
                                                          const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__isAccessAllowed(soap, tag ? tag : "-ns1:isAccessAllowed", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isAccessAllowed *SOAP_FMAC4 soap_get___ns1__isAccessAllowed(struct soap *soap,
                                                                                     struct __ns1__isAccessAllowed *p,
                                                                                     const char *tag,
                                                                                     const char *type) {
  if ((p = soap_in___ns1__isAccessAllowed(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__isAccessAllowed *SOAP_FMAC2 soap_instantiate___ns1__isAccessAllowed(struct soap *soap, int n,
                                                                                             const char *type,
                                                                                             const char *arrayType,
                                                                                             size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isAccessAllowed(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__isAccessAllowed, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__isAccessAllowed);
    if (size)
      *size = sizeof(struct __ns1__isAccessAllowed);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__isAccessAllowed, n);
    if (size)
      *size = n * sizeof(struct __ns1__isAccessAllowed);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__isAccessAllowed *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isAccessAllowed(struct soap *soap, int st, int tt, void *p, size_t len,
                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isAccessAllowed %p -> %p\n", q, p));
  *(struct __ns1__isAccessAllowed *)p = *(struct __ns1__isAccessAllowed *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchText(struct soap *soap, struct __ns1__searchText *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__searchText_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchText(struct soap *soap, const struct __ns1__searchText *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__searchText(soap, &a->ns1__searchText_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchText(struct soap *soap, const char *tag, int id,
                                                     const struct __ns1__searchText *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__searchText(soap, "ns1:searchText", -1, &a->ns1__searchText_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchText *SOAP_FMAC4 soap_in___ns1__searchText(struct soap *soap, const char *tag,
                                                                          struct __ns1__searchText *a,
                                                                          const char *type) {
  size_t soap_flag_ns1__searchText_ = 1;
  short soap_flag;
  a = (struct __ns1__searchText *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__searchText,
                                                sizeof(struct __ns1__searchText), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__searchText(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__searchText_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__searchText(soap, "ns1:searchText", &a->ns1__searchText_, "ns1:searchText")) {
        soap_flag_ns1__searchText_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchText(struct soap *soap, const struct __ns1__searchText *a,
                                                     const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__searchText(soap, tag ? tag : "-ns1:searchText", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchText *SOAP_FMAC4 soap_get___ns1__searchText(struct soap *soap,
                                                                           struct __ns1__searchText *p, const char *tag,
                                                                           const char *type) {
  if ((p = soap_in___ns1__searchText(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__searchText *SOAP_FMAC2 soap_instantiate___ns1__searchText(struct soap *soap, int n,
                                                                                   const char *type,
                                                                                   const char *arrayType,
                                                                                   size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchText(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__searchText, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__searchText);
    if (size)
      *size = sizeof(struct __ns1__searchText);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__searchText, n);
    if (size)
      *size = n * sizeof(struct __ns1__searchText);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__searchText *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchText(struct soap *soap, int st, int tt, void *p, size_t len,
                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchText %p -> %p\n", q, p));
  *(struct __ns1__searchText *)p = *(struct __ns1__searchText *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRemainingMinutes(struct soap *soap,
                                                                   struct __ns1__getRemainingMinutes *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getRemainingMinutes_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRemainingMinutes(struct soap *soap,
                                                                     const struct __ns1__getRemainingMinutes *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getRemainingMinutes(soap, &a->ns1__getRemainingMinutes_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRemainingMinutes(struct soap *soap, const char *tag, int id,
                                                              const struct __ns1__getRemainingMinutes *a,
                                                              const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getRemainingMinutes(soap, "ns1:getRemainingMinutes", -1, &a->ns1__getRemainingMinutes_,
                                                 ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRemainingMinutes *SOAP_FMAC4 soap_in___ns1__getRemainingMinutes(
    struct soap *soap, const char *tag, struct __ns1__getRemainingMinutes *a, const char *type) {
  size_t soap_flag_ns1__getRemainingMinutes_ = 1;
  short soap_flag;
  a = (struct __ns1__getRemainingMinutes *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getRemainingMinutes,
                                                         sizeof(struct __ns1__getRemainingMinutes), 0, nullptr, nullptr,
                                                         nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getRemainingMinutes(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getRemainingMinutes_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getRemainingMinutes(soap, "ns1:getRemainingMinutes", &a->ns1__getRemainingMinutes_,
                                                    "ns1:getRemainingMinutes")) {
        soap_flag_ns1__getRemainingMinutes_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRemainingMinutes(struct soap *soap,
                                                              const struct __ns1__getRemainingMinutes *a,
                                                              const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getRemainingMinutes(soap, tag ? tag : "-ns1:getRemainingMinutes", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRemainingMinutes *SOAP_FMAC4 soap_get___ns1__getRemainingMinutes(
    struct soap *soap, struct __ns1__getRemainingMinutes *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__getRemainingMinutes(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getRemainingMinutes *SOAP_FMAC2 soap_instantiate___ns1__getRemainingMinutes(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRemainingMinutes(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getRemainingMinutes, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getRemainingMinutes);
    if (size)
      *size = sizeof(struct __ns1__getRemainingMinutes);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getRemainingMinutes, n);
    if (size)
      *size = n * sizeof(struct __ns1__getRemainingMinutes);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getRemainingMinutes *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRemainingMinutes(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRemainingMinutes %p -> %p\n", q, p));
  *(struct __ns1__getRemainingMinutes *)p = *(struct __ns1__getRemainingMinutes *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__logout_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__logout(soap, &a->ns1__logout_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id,
                                                 const struct __ns1__logout *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__logout(soap, "ns1:logout", -1, &a->ns1__logout_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout *SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag,
                                                                  struct __ns1__logout *a, const char *type) {
  size_t soap_flag_ns1__logout_ = 1;
  short soap_flag;
  a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__logout, sizeof(struct __ns1__logout), 0,
                                            nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__logout(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__logout_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__logout(soap, "ns1:logout", &a->ns1__logout_, "ns1:logout")) {
        soap_flag_ns1__logout_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag,
                                                 const char *type) {
  int id = 0;
  if (soap_out___ns1__logout(soap, tag ? tag : "-ns1:logout", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout *SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p,
                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__logout(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__logout *SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__logout, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__logout);
    if (size)
      *size = sizeof(struct __ns1__logout);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__logout, n);
    if (size)
      *size = n * sizeof(struct __ns1__logout);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__logout *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logout %p -> %p\n", q, p));
  *(struct __ns1__logout *)p = *(struct __ns1__logout *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logoutResponse(struct soap *soap, struct __ns1__logoutResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__logoutResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logoutResponse(struct soap *soap,
                                                                const struct __ns1__logoutResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__logoutResponse(soap, &a->ns1__logoutResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logoutResponse(struct soap *soap, const char *tag, int id,
                                                         const struct __ns1__logoutResponse *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__logoutResponse_)
    soap_element_result(soap, "ns1:logoutResponse");
  if (soap_out_PointerTons1__logoutResponse(soap, "ns1:logoutResponse", -1, &a->ns1__logoutResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logoutResponse *SOAP_FMAC4 soap_in___ns1__logoutResponse(struct soap *soap, const char *tag,
                                                                                  struct __ns1__logoutResponse *a,
                                                                                  const char *type) {
  size_t soap_flag_ns1__logoutResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__logoutResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__logoutResponse,
                                                    sizeof(struct __ns1__logoutResponse), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__logoutResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__logoutResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__logoutResponse(soap, "ns1:logoutResponse", &a->ns1__logoutResponse_,
                                               "ns1:logoutResponse")) {
        soap_flag_ns1__logoutResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:logoutResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logoutResponse(struct soap *soap, const struct __ns1__logoutResponse *a,
                                                         const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__logoutResponse(soap, tag ? tag : "-ns1:logoutResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logoutResponse *SOAP_FMAC4 soap_get___ns1__logoutResponse(struct soap *soap,
                                                                                   struct __ns1__logoutResponse *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__logoutResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__logoutResponse *SOAP_FMAC2 soap_instantiate___ns1__logoutResponse(struct soap *soap, int n,
                                                                                           const char *type,
                                                                                           const char *arrayType,
                                                                                           size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logoutResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__logoutResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__logoutResponse);
    if (size)
      *size = sizeof(struct __ns1__logoutResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__logoutResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__logoutResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__logoutResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logoutResponse %p -> %p\n", q, p));
  *(struct __ns1__logoutResponse *)p = *(struct __ns1__logoutResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dummy(struct soap *soap, struct __ns1__dummy *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__dummy_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dummy(struct soap *soap, const struct __ns1__dummy *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dummy(soap, &a->ns1__dummy_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dummy(struct soap *soap, const char *tag, int id,
                                                const struct __ns1__dummy *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__dummy(soap, "ns1:dummy", -1, &a->ns1__dummy_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dummy *SOAP_FMAC4 soap_in___ns1__dummy(struct soap *soap, const char *tag,
                                                                struct __ns1__dummy *a, const char *type) {
  size_t soap_flag_ns1__dummy_ = 1;
  short soap_flag;
  a = (struct __ns1__dummy *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__dummy, sizeof(struct __ns1__dummy), 0,
                                           nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__dummy(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__dummy_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__dummy(soap, "ns1:dummy", &a->ns1__dummy_, "ns1:dummy")) {
        soap_flag_ns1__dummy_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dummy(struct soap *soap, const struct __ns1__dummy *a, const char *tag,
                                                const char *type) {
  int id = 0;
  if (soap_out___ns1__dummy(soap, tag ? tag : "-ns1:dummy", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dummy *SOAP_FMAC4 soap_get___ns1__dummy(struct soap *soap, struct __ns1__dummy *p,
                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__dummy(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__dummy *SOAP_FMAC2 soap_instantiate___ns1__dummy(struct soap *soap, int n, const char *type,
                                                                         const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dummy(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__dummy, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__dummy);
    if (size)
      *size = sizeof(struct __ns1__dummy);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__dummy, n);
    if (size)
      *size = n * sizeof(struct __ns1__dummy);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__dummy *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dummy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dummy %p -> %p\n", q, p));
  *(struct __ns1__dummy *)p = *(struct __ns1__dummy *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dummyResponse(struct soap *soap, struct __ns1__dummyResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__dummyResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dummyResponse(struct soap *soap,
                                                               const struct __ns1__dummyResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__dummyResponse(soap, &a->ns1__dummyResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dummyResponse(struct soap *soap, const char *tag, int id,
                                                        const struct __ns1__dummyResponse *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__dummyResponse_)
    soap_element_result(soap, "ns1:dummyResponse");
  if (soap_out_PointerTons1__dummyResponse(soap, "ns1:dummyResponse", -1, &a->ns1__dummyResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dummyResponse *SOAP_FMAC4 soap_in___ns1__dummyResponse(struct soap *soap, const char *tag,
                                                                                struct __ns1__dummyResponse *a,
                                                                                const char *type) {
  size_t soap_flag_ns1__dummyResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__dummyResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__dummyResponse,
                                                   sizeof(struct __ns1__dummyResponse), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__dummyResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__dummyResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__dummyResponse(soap, "ns1:dummyResponse", &a->ns1__dummyResponse_,
                                              "ns1:dummyResponse")) {
        soap_flag_ns1__dummyResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:dummyResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dummyResponse(struct soap *soap, const struct __ns1__dummyResponse *a,
                                                        const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__dummyResponse(soap, tag ? tag : "-ns1:dummyResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dummyResponse *SOAP_FMAC4 soap_get___ns1__dummyResponse(struct soap *soap,
                                                                                 struct __ns1__dummyResponse *p,
                                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__dummyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__dummyResponse *SOAP_FMAC2 soap_instantiate___ns1__dummyResponse(struct soap *soap, int n,
                                                                                         const char *type,
                                                                                         const char *arrayType,
                                                                                         size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dummyResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__dummyResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__dummyResponse);
    if (size)
      *size = sizeof(struct __ns1__dummyResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__dummyResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__dummyResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__dummyResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dummyResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dummyResponse %p -> %p\n", q, p));
  *(struct __ns1__dummyResponse *)p = *(struct __ns1__dummyResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__refresh(struct soap *soap, struct __ns1__refresh *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__refresh_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__refresh(struct soap *soap, const struct __ns1__refresh *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__refresh(soap, &a->ns1__refresh_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__refresh(struct soap *soap, const char *tag, int id,
                                                  const struct __ns1__refresh *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__refresh(soap, "ns1:refresh", -1, &a->ns1__refresh_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refresh *SOAP_FMAC4 soap_in___ns1__refresh(struct soap *soap, const char *tag,
                                                                    struct __ns1__refresh *a, const char *type) {
  size_t soap_flag_ns1__refresh_ = 1;
  short soap_flag;
  a = (struct __ns1__refresh *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__refresh, sizeof(struct __ns1__refresh),
                                             0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__refresh(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__refresh_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__refresh(soap, "ns1:refresh", &a->ns1__refresh_, "ns1:refresh")) {
        soap_flag_ns1__refresh_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__refresh(struct soap *soap, const struct __ns1__refresh *a, const char *tag,
                                                  const char *type) {
  int id = 0;
  if (soap_out___ns1__refresh(soap, tag ? tag : "-ns1:refresh", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refresh *SOAP_FMAC4 soap_get___ns1__refresh(struct soap *soap, struct __ns1__refresh *p,
                                                                     const char *tag, const char *type) {
  if ((p = soap_in___ns1__refresh(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__refresh *SOAP_FMAC2 soap_instantiate___ns1__refresh(struct soap *soap, int n, const char *type,
                                                                             const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__refresh(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__refresh, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__refresh);
    if (size)
      *size = sizeof(struct __ns1__refresh);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__refresh, n);
    if (size)
      *size = n * sizeof(struct __ns1__refresh);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__refresh *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__refresh(struct soap *soap, int st, int tt, void *p, size_t len,
                                                    const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__refresh %p -> %p\n", q, p));
  *(struct __ns1__refresh *)p = *(struct __ns1__refresh *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__refreshResponse(struct soap *soap, struct __ns1__refreshResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__refreshResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__refreshResponse(struct soap *soap,
                                                                 const struct __ns1__refreshResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__refreshResponse(soap, &a->ns1__refreshResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__refreshResponse(struct soap *soap, const char *tag, int id,
                                                          const struct __ns1__refreshResponse *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__refreshResponse_)
    soap_element_result(soap, "ns1:refreshResponse");
  if (soap_out_PointerTons1__refreshResponse(soap, "ns1:refreshResponse", -1, &a->ns1__refreshResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshResponse *SOAP_FMAC4 soap_in___ns1__refreshResponse(struct soap *soap, const char *tag,
                                                                                    struct __ns1__refreshResponse *a,
                                                                                    const char *type) {
  size_t soap_flag_ns1__refreshResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__refreshResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__refreshResponse,
                                                     sizeof(struct __ns1__refreshResponse), 0, nullptr, nullptr,
                                                     nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__refreshResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__refreshResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__refreshResponse(soap, "ns1:refreshResponse", &a->ns1__refreshResponse_,
                                                "ns1:refreshResponse")) {
        soap_flag_ns1__refreshResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:refreshResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__refreshResponse(struct soap *soap, const struct __ns1__refreshResponse *a,
                                                          const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__refreshResponse(soap, tag ? tag : "-ns1:refreshResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshResponse *SOAP_FMAC4 soap_get___ns1__refreshResponse(struct soap *soap,
                                                                                     struct __ns1__refreshResponse *p,
                                                                                     const char *tag,
                                                                                     const char *type) {
  if ((p = soap_in___ns1__refreshResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__refreshResponse *SOAP_FMAC2 soap_instantiate___ns1__refreshResponse(struct soap *soap, int n,
                                                                                             const char *type,
                                                                                             const char *arrayType,
                                                                                             size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__refreshResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__refreshResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__refreshResponse);
    if (size)
      *size = sizeof(struct __ns1__refreshResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__refreshResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__refreshResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__refreshResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__refreshResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__refreshResponse %p -> %p\n", q, p));
  *(struct __ns1__refreshResponse *)p = *(struct __ns1__refreshResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityNames(struct soap *soap, struct __ns1__getEntityNames *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getEntityNames_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityNames(struct soap *soap,
                                                                const struct __ns1__getEntityNames *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getEntityNames(soap, &a->ns1__getEntityNames_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityNames(struct soap *soap, const char *tag, int id,
                                                         const struct __ns1__getEntityNames *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getEntityNames(soap, "ns1:getEntityNames", -1, &a->ns1__getEntityNames_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityNames *SOAP_FMAC4 soap_in___ns1__getEntityNames(struct soap *soap, const char *tag,
                                                                                  struct __ns1__getEntityNames *a,
                                                                                  const char *type) {
  size_t soap_flag_ns1__getEntityNames_ = 1;
  short soap_flag;
  a = (struct __ns1__getEntityNames *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getEntityNames,
                                                    sizeof(struct __ns1__getEntityNames), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getEntityNames(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getEntityNames_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getEntityNames(soap, "ns1:getEntityNames", &a->ns1__getEntityNames_,
                                               "ns1:getEntityNames")) {
        soap_flag_ns1__getEntityNames_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityNames(struct soap *soap, const struct __ns1__getEntityNames *a,
                                                         const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getEntityNames(soap, tag ? tag : "-ns1:getEntityNames", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityNames *SOAP_FMAC4 soap_get___ns1__getEntityNames(struct soap *soap,
                                                                                   struct __ns1__getEntityNames *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__getEntityNames(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getEntityNames *SOAP_FMAC2 soap_instantiate___ns1__getEntityNames(struct soap *soap, int n,
                                                                                           const char *type,
                                                                                           const char *arrayType,
                                                                                           size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityNames(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getEntityNames, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getEntityNames);
    if (size)
      *size = sizeof(struct __ns1__getEntityNames);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getEntityNames, n);
    if (size)
      *size = n * sizeof(struct __ns1__getEntityNames);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getEntityNames *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEntityNames(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEntityNames %p -> %p\n", q, p));
  *(struct __ns1__getEntityNames *)p = *(struct __ns1__getEntityNames *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getApiVersion(struct soap *soap, struct __ns1__getApiVersion *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getApiVersion_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getApiVersion(struct soap *soap,
                                                               const struct __ns1__getApiVersion *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getApiVersion(soap, &a->ns1__getApiVersion_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getApiVersion(struct soap *soap, const char *tag, int id,
                                                        const struct __ns1__getApiVersion *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getApiVersion(soap, "ns1:getApiVersion", -1, &a->ns1__getApiVersion_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getApiVersion *SOAP_FMAC4 soap_in___ns1__getApiVersion(struct soap *soap, const char *tag,
                                                                                struct __ns1__getApiVersion *a,
                                                                                const char *type) {
  size_t soap_flag_ns1__getApiVersion_ = 1;
  short soap_flag;
  a = (struct __ns1__getApiVersion *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getApiVersion,
                                                   sizeof(struct __ns1__getApiVersion), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getApiVersion(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getApiVersion_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getApiVersion(soap, "ns1:getApiVersion", &a->ns1__getApiVersion_,
                                              "ns1:getApiVersion")) {
        soap_flag_ns1__getApiVersion_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getApiVersion(struct soap *soap, const struct __ns1__getApiVersion *a,
                                                        const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getApiVersion(soap, tag ? tag : "-ns1:getApiVersion", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getApiVersion *SOAP_FMAC4 soap_get___ns1__getApiVersion(struct soap *soap,
                                                                                 struct __ns1__getApiVersion *p,
                                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__getApiVersion(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getApiVersion *SOAP_FMAC2 soap_instantiate___ns1__getApiVersion(struct soap *soap, int n,
                                                                                         const char *type,
                                                                                         const char *arrayType,
                                                                                         size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getApiVersion(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getApiVersion, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getApiVersion);
    if (size)
      *size = sizeof(struct __ns1__getApiVersion);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getApiVersion, n);
    if (size)
      *size = n * sizeof(struct __ns1__getApiVersion);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getApiVersion *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getApiVersion(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getApiVersion %p -> %p\n", q, p));
  *(struct __ns1__getApiVersion *)p = *(struct __ns1__getApiVersion *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__update(struct soap *soap, struct __ns1__update *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__update_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__update(struct soap *soap, const struct __ns1__update *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__update(soap, &a->ns1__update_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__update(struct soap *soap, const char *tag, int id,
                                                 const struct __ns1__update *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__update(soap, "ns1:update", -1, &a->ns1__update_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update *SOAP_FMAC4 soap_in___ns1__update(struct soap *soap, const char *tag,
                                                                  struct __ns1__update *a, const char *type) {
  size_t soap_flag_ns1__update_ = 1;
  short soap_flag;
  a = (struct __ns1__update *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__update, sizeof(struct __ns1__update), 0,
                                            nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__update(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__update_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__update(soap, "ns1:update", &a->ns1__update_, "ns1:update")) {
        soap_flag_ns1__update_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__update(struct soap *soap, const struct __ns1__update *a, const char *tag,
                                                 const char *type) {
  int id = 0;
  if (soap_out___ns1__update(soap, tag ? tag : "-ns1:update", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__update *SOAP_FMAC4 soap_get___ns1__update(struct soap *soap, struct __ns1__update *p,
                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__update(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__update *SOAP_FMAC2 soap_instantiate___ns1__update(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__update(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__update, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__update);
    if (size)
      *size = sizeof(struct __ns1__update);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__update, n);
    if (size)
      *size = n * sizeof(struct __ns1__update);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__update *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__update(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__update %p -> %p\n", q, p));
  *(struct __ns1__update *)p = *(struct __ns1__update *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateResponse(struct soap *soap, struct __ns1__updateResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__updateResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateResponse(struct soap *soap,
                                                                const struct __ns1__updateResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__updateResponse(soap, &a->ns1__updateResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateResponse(struct soap *soap, const char *tag, int id,
                                                         const struct __ns1__updateResponse *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__updateResponse_)
    soap_element_result(soap, "ns1:updateResponse");
  if (soap_out_PointerTons1__updateResponse(soap, "ns1:updateResponse", -1, &a->ns1__updateResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateResponse *SOAP_FMAC4 soap_in___ns1__updateResponse(struct soap *soap, const char *tag,
                                                                                  struct __ns1__updateResponse *a,
                                                                                  const char *type) {
  size_t soap_flag_ns1__updateResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__updateResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__updateResponse,
                                                    sizeof(struct __ns1__updateResponse), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__updateResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__updateResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__updateResponse(soap, "ns1:updateResponse", &a->ns1__updateResponse_,
                                               "ns1:updateResponse")) {
        soap_flag_ns1__updateResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:updateResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateResponse(struct soap *soap, const struct __ns1__updateResponse *a,
                                                         const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__updateResponse(soap, tag ? tag : "-ns1:updateResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateResponse *SOAP_FMAC4 soap_get___ns1__updateResponse(struct soap *soap,
                                                                                   struct __ns1__updateResponse *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__updateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__updateResponse *SOAP_FMAC2 soap_instantiate___ns1__updateResponse(struct soap *soap, int n,
                                                                                           const char *type,
                                                                                           const char *arrayType,
                                                                                           size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__updateResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__updateResponse);
    if (size)
      *size = sizeof(struct __ns1__updateResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__updateResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__updateResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__updateResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateResponse %p -> %p\n", q, p));
  *(struct __ns1__updateResponse *)p = *(struct __ns1__updateResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create(struct soap *soap, struct __ns1__create *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__create_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create(struct soap *soap, const struct __ns1__create *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__create(soap, &a->ns1__create_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create(struct soap *soap, const char *tag, int id,
                                                 const struct __ns1__create *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__create(soap, "ns1:create", -1, &a->ns1__create_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create *SOAP_FMAC4 soap_in___ns1__create(struct soap *soap, const char *tag,
                                                                  struct __ns1__create *a, const char *type) {
  size_t soap_flag_ns1__create_ = 1;
  short soap_flag;
  a = (struct __ns1__create *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__create, sizeof(struct __ns1__create), 0,
                                            nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__create(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__create_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__create(soap, "ns1:create", &a->ns1__create_, "ns1:create")) {
        soap_flag_ns1__create_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create(struct soap *soap, const struct __ns1__create *a, const char *tag,
                                                 const char *type) {
  int id = 0;
  if (soap_out___ns1__create(soap, tag ? tag : "-ns1:create", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create *SOAP_FMAC4 soap_get___ns1__create(struct soap *soap, struct __ns1__create *p,
                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__create(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__create *SOAP_FMAC2 soap_instantiate___ns1__create(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__create, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__create);
    if (size)
      *size = sizeof(struct __ns1__create);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__create, n);
    if (size)
      *size = n * sizeof(struct __ns1__create);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__create *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create %p -> %p\n", q, p));
  *(struct __ns1__create *)p = *(struct __ns1__create *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__search(struct soap *soap, struct __ns1__search *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__search_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__search(struct soap *soap, const struct __ns1__search *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__search(soap, &a->ns1__search_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__search(struct soap *soap, const char *tag, int id,
                                                 const struct __ns1__search *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__search(soap, "ns1:search", -1, &a->ns1__search_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__search *SOAP_FMAC4 soap_in___ns1__search(struct soap *soap, const char *tag,
                                                                  struct __ns1__search *a, const char *type) {
  size_t soap_flag_ns1__search_ = 1;
  short soap_flag;
  a = (struct __ns1__search *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__search, sizeof(struct __ns1__search), 0,
                                            nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__search(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__search_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__search(soap, "ns1:search", &a->ns1__search_, "ns1:search")) {
        soap_flag_ns1__search_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__search(struct soap *soap, const struct __ns1__search *a, const char *tag,
                                                 const char *type) {
  int id = 0;
  if (soap_out___ns1__search(soap, tag ? tag : "-ns1:search", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__search *SOAP_FMAC4 soap_get___ns1__search(struct soap *soap, struct __ns1__search *p,
                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__search(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__search *SOAP_FMAC2 soap_instantiate___ns1__search(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__search(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__search, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__search);
    if (size)
      *size = sizeof(struct __ns1__search);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__search, n);
    if (size)
      *size = n * sizeof(struct __ns1__search);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__search *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__search(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__search %p -> %p\n", q, p));
  *(struct __ns1__search *)p = *(struct __ns1__search *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__delete(struct soap *soap, struct __ns1__delete *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__delete_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__delete(struct soap *soap, const struct __ns1__delete *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__delete(soap, &a->ns1__delete_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__delete(struct soap *soap, const char *tag, int id,
                                                 const struct __ns1__delete *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__delete(soap, "ns1:delete", -1, &a->ns1__delete_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delete *SOAP_FMAC4 soap_in___ns1__delete(struct soap *soap, const char *tag,
                                                                  struct __ns1__delete *a, const char *type) {
  size_t soap_flag_ns1__delete_ = 1;
  short soap_flag;
  a = (struct __ns1__delete *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__delete, sizeof(struct __ns1__delete), 0,
                                            nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__delete(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__delete_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__delete(soap, "ns1:delete", &a->ns1__delete_, "ns1:delete")) {
        soap_flag_ns1__delete_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__delete(struct soap *soap, const struct __ns1__delete *a, const char *tag,
                                                 const char *type) {
  int id = 0;
  if (soap_out___ns1__delete(soap, tag ? tag : "-ns1:delete", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__delete *SOAP_FMAC4 soap_get___ns1__delete(struct soap *soap, struct __ns1__delete *p,
                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__delete(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__delete *SOAP_FMAC2 soap_instantiate___ns1__delete(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__delete(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__delete, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__delete);
    if (size)
      *size = sizeof(struct __ns1__delete);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__delete, n);
    if (size)
      *size = n * sizeof(struct __ns1__delete);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__delete *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__delete(struct soap *soap, int st, int tt, void *p, size_t len,
                                                   const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__delete %p -> %p\n", q, p));
  *(struct __ns1__delete *)p = *(struct __ns1__delete *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteResponse(struct soap *soap, struct __ns1__deleteResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__deleteResponse_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteResponse(struct soap *soap,
                                                                const struct __ns1__deleteResponse *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__deleteResponse(soap, &a->ns1__deleteResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteResponse(struct soap *soap, const char *tag, int id,
                                                         const struct __ns1__deleteResponse *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (a->ns1__deleteResponse_)
    soap_element_result(soap, "ns1:deleteResponse");
  if (soap_out_PointerTons1__deleteResponse(soap, "ns1:deleteResponse", -1, &a->ns1__deleteResponse_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteResponse *SOAP_FMAC4 soap_in___ns1__deleteResponse(struct soap *soap, const char *tag,
                                                                                  struct __ns1__deleteResponse *a,
                                                                                  const char *type) {
  size_t soap_flag_ns1__deleteResponse_ = 1;
  short soap_flag;
  a = (struct __ns1__deleteResponse *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__deleteResponse,
                                                    sizeof(struct __ns1__deleteResponse), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__deleteResponse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__deleteResponse_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__deleteResponse(soap, "ns1:deleteResponse", &a->ns1__deleteResponse_,
                                               "ns1:deleteResponse")) {
        soap_flag_ns1__deleteResponse_--;
        continue;
      }
    soap_check_result(soap, "ns1:deleteResponse");
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteResponse(struct soap *soap, const struct __ns1__deleteResponse *a,
                                                         const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__deleteResponse(soap, tag ? tag : "-ns1:deleteResponse", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteResponse *SOAP_FMAC4 soap_get___ns1__deleteResponse(struct soap *soap,
                                                                                   struct __ns1__deleteResponse *p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in___ns1__deleteResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__deleteResponse *SOAP_FMAC2 soap_instantiate___ns1__deleteResponse(struct soap *soap, int n,
                                                                                           const char *type,
                                                                                           const char *arrayType,
                                                                                           size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteResponse(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__deleteResponse, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__deleteResponse);
    if (size)
      *size = sizeof(struct __ns1__deleteResponse);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__deleteResponse, n);
    if (size)
      *size = n * sizeof(struct __ns1__deleteResponse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__deleteResponse *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteResponse(struct soap *soap, int st, int tt, void *p, size_t len,
                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteResponse %p -> %p\n", q, p));
  *(struct __ns1__deleteResponse *)p = *(struct __ns1__deleteResponse *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProperties(struct soap *soap, struct __ns1__getProperties *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getProperties_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProperties(struct soap *soap,
                                                               const struct __ns1__getProperties *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getProperties(soap, &a->ns1__getProperties_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProperties(struct soap *soap, const char *tag, int id,
                                                        const struct __ns1__getProperties *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getProperties(soap, "ns1:getProperties", -1, &a->ns1__getProperties_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProperties *SOAP_FMAC4 soap_in___ns1__getProperties(struct soap *soap, const char *tag,
                                                                                struct __ns1__getProperties *a,
                                                                                const char *type) {
  size_t soap_flag_ns1__getProperties_ = 1;
  short soap_flag;
  a = (struct __ns1__getProperties *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getProperties,
                                                   sizeof(struct __ns1__getProperties), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getProperties(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getProperties_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getProperties(soap, "ns1:getProperties", &a->ns1__getProperties_,
                                              "ns1:getProperties")) {
        soap_flag_ns1__getProperties_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProperties(struct soap *soap, const struct __ns1__getProperties *a,
                                                        const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getProperties(soap, tag ? tag : "-ns1:getProperties", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProperties *SOAP_FMAC4 soap_get___ns1__getProperties(struct soap *soap,
                                                                                 struct __ns1__getProperties *p,
                                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__getProperties(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getProperties *SOAP_FMAC2 soap_instantiate___ns1__getProperties(struct soap *soap, int n,
                                                                                         const char *type,
                                                                                         const char *arrayType,
                                                                                         size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProperties(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getProperties, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getProperties);
    if (size)
      *size = sizeof(struct __ns1__getProperties);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getProperties, n);
    if (size)
      *size = n * sizeof(struct __ns1__getProperties);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getProperties *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProperties(struct soap *soap, int st, int tt, void *p, size_t len,
                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProperties %p -> %p\n", q, p));
  *(struct __ns1__getProperties *)p = *(struct __ns1__getProperties *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__get(struct soap *soap, struct __ns1__get *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__get_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__get(struct soap *soap, const struct __ns1__get *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__get(soap, &a->ns1__get_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__get(struct soap *soap, const char *tag, int id, const struct __ns1__get *a,
                                              const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__get(soap, "ns1:get", -1, &a->ns1__get_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get *SOAP_FMAC4 soap_in___ns1__get(struct soap *soap, const char *tag, struct __ns1__get *a,
                                                            const char *type) {
  size_t soap_flag_ns1__get_ = 1;
  short soap_flag;
  a = (struct __ns1__get *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__get, sizeof(struct __ns1__get), 0, nullptr,
                                         nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__get(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__get_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__get(soap, "ns1:get", &a->ns1__get_, "ns1:get")) {
        soap_flag_ns1__get_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__get(struct soap *soap, const struct __ns1__get *a, const char *tag,
                                              const char *type) {
  int id = 0;
  if (soap_out___ns1__get(soap, tag ? tag : "-ns1:get", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__get *SOAP_FMAC4 soap_get___ns1__get(struct soap *soap, struct __ns1__get *p, const char *tag,
                                                             const char *type) {
  if ((p = soap_in___ns1__get(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__get *SOAP_FMAC2 soap_instantiate___ns1__get(struct soap *soap, int n, const char *type,
                                                                     const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__get(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__get, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__get);
    if (size)
      *size = sizeof(struct __ns1__get);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__get, n);
    if (size)
      *size = n * sizeof(struct __ns1__get);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__get *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__get(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__get %p -> %p\n", q, p));
  *(struct __ns1__get *)p = *(struct __ns1__get *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserName(struct soap *soap, struct __ns1__getUserName *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getUserName_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserName(struct soap *soap, const struct __ns1__getUserName *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getUserName(soap, &a->ns1__getUserName_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserName(struct soap *soap, const char *tag, int id,
                                                      const struct __ns1__getUserName *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__getUserName(soap, "ns1:getUserName", -1, &a->ns1__getUserName_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserName *SOAP_FMAC4 soap_in___ns1__getUserName(struct soap *soap, const char *tag,
                                                                            struct __ns1__getUserName *a,
                                                                            const char *type) {
  size_t soap_flag_ns1__getUserName_ = 1;
  short soap_flag;
  a = (struct __ns1__getUserName *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__getUserName,
                                                 sizeof(struct __ns1__getUserName), 0, nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__getUserName(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getUserName_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getUserName(soap, "ns1:getUserName", &a->ns1__getUserName_, "ns1:getUserName")) {
        soap_flag_ns1__getUserName_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserName(struct soap *soap, const struct __ns1__getUserName *a,
                                                      const char *tag, const char *type) {
  int id = 0;
  if (soap_out___ns1__getUserName(soap, tag ? tag : "-ns1:getUserName", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserName *SOAP_FMAC4 soap_get___ns1__getUserName(struct soap *soap,
                                                                             struct __ns1__getUserName *p,
                                                                             const char *tag, const char *type) {
  if ((p = soap_in___ns1__getUserName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__getUserName *SOAP_FMAC2 soap_instantiate___ns1__getUserName(struct soap *soap, int n,
                                                                                     const char *type,
                                                                                     const char *arrayType,
                                                                                     size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserName(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__getUserName, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__getUserName);
    if (size)
      *size = sizeof(struct __ns1__getUserName);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__getUserName, n);
    if (size)
      *size = n * sizeof(struct __ns1__getUserName);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__getUserName *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getUserName(struct soap *soap, int st, int tt, void *p, size_t len,
                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getUserName %p -> %p\n", q, p));
  *(struct __ns1__getUserName *)p = *(struct __ns1__getUserName *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__login_ = nullptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__login(soap, &a->ns1__login_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id,
                                                const struct __ns1__login *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_out_PointerTons1__login(soap, "ns1:login", -1, &a->ns1__login_, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login *SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag,
                                                                struct __ns1__login *a, const char *type) {
  size_t soap_flag_ns1__login_ = 1;
  short soap_flag;
  a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE_ICat4___ns1__login, sizeof(struct __ns1__login), 0,
                                           nullptr, nullptr, nullptr);
  if (!a)
    return nullptr;
  soap_default___ns1__login(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__login_ && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__login(soap, "ns1:login", &a->ns1__login_, "ns1:login")) {
        soap_flag_ns1__login_--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag,
                                                const char *type) {
  int id = 0;
  if (soap_out___ns1__login(soap, tag ? tag : "-ns1:login", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login *SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p,
                                                                 const char *tag, const char *type) {
  if ((p = soap_in___ns1__login(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC1 struct __ns1__login *SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type,
                                                                         const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4___ns1__login, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct __ns1__login);
    if (size)
      *size = sizeof(struct __ns1__login);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct __ns1__login, n);
    if (size)
      *size = n * sizeof(struct __ns1__login);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct __ns1__login *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q,
                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__login %p -> %p\n", q, p));
  *(struct __ns1__login *)p = *(struct __ns1__login *)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__any = NULL;
  a->ns1__IcatException_ = NULL;
  a->__type = 0;
  a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a) {
#ifndef WITH_NOIDREF
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__IcatException(soap, &a->ns1__IcatException_);
  soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id,
                                                    const struct SOAP_ENV__Detail *a, const char *type) {
  (void)soap;
  (void)tag;
  (void)id;
  (void)type;
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ICat4_SOAP_ENV__Detail), type))
    return soap->error;
  soap_outliteral(soap, "-any", &a->__any, NULL);
  if (soap_out_PointerTons1__IcatException(soap, "ns1:IcatException", -1, &a->ns1__IcatException_, ""))
    return soap->error;
  if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail *SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag,
                                                                        struct SOAP_ENV__Detail *a, const char *type) {
  size_t soap_flag___any = 1;
  size_t soap_flag_ns1__IcatException_ = 1;
  size_t soap_flag_fault = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ICat4_SOAP_ENV__Detail,
                                               sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Detail(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns1__IcatException_ && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__IcatException(soap, "ns1:IcatException", &a->ns1__IcatException_,
                                                "ns1:IcatException")) {
          soap_flag_ns1__IcatException_--;
          continue;
        }
      if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
        if ((a->fault = soap_getelement(soap, &a->__type))) {
          soap_flag_fault = 0;
          continue;
        }
      if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-any", &a->__any)) {
          soap_flag___any--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void *)a, 0, SOAP_TYPE_ICat4_SOAP_ENV__Detail, 0,
                                                   sizeof(struct SOAP_ENV__Detail), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a,
                                                    const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_SOAP_ENV__Detail);
  if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail *SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p,
                                                                         const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail *SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n,
                                                                                 const char *type,
                                                                                 const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ICat4_SOAP_ENV__Detail, n, ICat4_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(struct SOAP_ENV__Detail);
    if (size)
      *size = sizeof(struct SOAP_ENV__Detail);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Detail);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (struct SOAP_ENV__Detail *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len,
                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
  *(struct SOAP_ENV__Detail *)p = *(struct SOAP_ENV__Detail *)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap,
                                                                    struct SOAP_ENV__Reason *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id,
                                                             struct SOAP_ENV__Reason *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ICat4_SOAP_ENV__Reason);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason **SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag,
                                                                                  struct SOAP_ENV__Reason **a,
                                                                                  const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_SOAP_ENV__Reason,
                                                   sizeof(struct SOAP_ENV__Reason), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_PointerToSOAP_ENV__Reason);
  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason **SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap,
                                                                                   struct SOAP_ENV__Reason **p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap,
                                                                    struct SOAP_ENV__Detail *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id,
                                                             struct SOAP_ENV__Detail *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ICat4_SOAP_ENV__Detail);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail **SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag,
                                                                                  struct SOAP_ENV__Detail **a,
                                                                                  const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_SOAP_ENV__Detail,
                                                   sizeof(struct SOAP_ENV__Detail), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_PointerToSOAP_ENV__Detail);
  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail **SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap,
                                                                                   struct SOAP_ENV__Detail **p,
                                                                                   const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id,
                                                           struct SOAP_ENV__Code *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ICat4_SOAP_ENV__Code);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code **SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag,
                                                                              struct SOAP_ENV__Code **a,
                                                                              const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_SOAP_ENV__Code,
                                                 sizeof(struct SOAP_ENV__Code), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const *a,
                                                           const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, NULL, 0, tag, SOAP_TYPE_ICat4_PointerToSOAP_ENV__Code);
  if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code **SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap,
                                                                               struct SOAP_ENV__Code **p,
                                                                               const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityInfoResponse(struct soap *soap,
                                                                              ns1__getEntityInfoResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityInfoResponse(struct soap *soap, const char *tag, int id,
                                                                       ns1__getEntityInfoResponse *const *a,
                                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityInfoResponse **SOAP_FMAC4 soap_in_PointerTons1__getEntityInfoResponse(
    struct soap *soap, const char *tag, ns1__getEntityInfoResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getEntityInfoResponse **)soap_malloc(soap, sizeof(ns1__getEntityInfoResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getEntityInfoResponse *)soap_instantiate_ns1__getEntityInfoResponse(soap, -1, soap->type,
                                                                                         soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getEntityInfoResponse **p = (ns1__getEntityInfoResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse, sizeof(ns1__getEntityInfoResponse),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityInfoResponse(struct soap *soap,
                                                                       ns1__getEntityInfoResponse *const *a,
                                                                       const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getEntityInfoResponse);
  if (soap_out_PointerTons1__getEntityInfoResponse(soap, tag ? tag : "ns1:getEntityInfoResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getEntityInfoResponse **SOAP_FMAC4 soap_get_PointerTons1__getEntityInfoResponse(
    struct soap *soap, ns1__getEntityInfoResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getEntityInfoResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityInfo(struct soap *soap, ns1__getEntityInfo *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getEntityInfo))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityInfo(struct soap *soap, const char *tag, int id,
                                                               ns1__getEntityInfo *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getEntityInfo);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityInfo **SOAP_FMAC4 soap_in_PointerTons1__getEntityInfo(struct soap *soap, const char *tag,
                                                                               ns1__getEntityInfo **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getEntityInfo **)soap_malloc(soap, sizeof(ns1__getEntityInfo *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getEntityInfo *)soap_instantiate_ns1__getEntityInfo(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getEntityInfo **p = (ns1__getEntityInfo **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityInfo, sizeof(ns1__getEntityInfo), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityInfo(struct soap *soap, ns1__getEntityInfo *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getEntityInfo);
  if (soap_out_PointerTons1__getEntityInfo(soap, tag ? tag : "ns1:getEntityInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getEntityInfo **SOAP_FMAC4 soap_get_PointerTons1__getEntityInfo(struct soap *soap,
                                                                                ns1__getEntityInfo **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__getEntityInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteManyResponse(struct soap *soap,
                                                                           ns1__deleteManyResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__deleteManyResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteManyResponse(struct soap *soap, const char *tag, int id,
                                                                    ns1__deleteManyResponse *const *a,
                                                                    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__deleteManyResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteManyResponse **SOAP_FMAC4 soap_in_PointerTons1__deleteManyResponse(struct soap *soap,
                                                                                         const char *tag,
                                                                                         ns1__deleteManyResponse **a,
                                                                                         const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__deleteManyResponse **)soap_malloc(soap, sizeof(ns1__deleteManyResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__deleteManyResponse *)soap_instantiate_ns1__deleteManyResponse(soap, -1, soap->type,
                                                                                   soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__deleteManyResponse **p = (ns1__deleteManyResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteManyResponse, sizeof(ns1__deleteManyResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteManyResponse(struct soap *soap,
                                                                    ns1__deleteManyResponse *const *a, const char *tag,
                                                                    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__deleteManyResponse);
  if (soap_out_PointerTons1__deleteManyResponse(soap, tag ? tag : "ns1:deleteManyResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteManyResponse **SOAP_FMAC4 soap_get_PointerTons1__deleteManyResponse(struct soap *soap,
                                                                                          ns1__deleteManyResponse **p,
                                                                                          const char *tag,
                                                                                          const char *type) {
  if ((p = soap_in_PointerTons1__deleteManyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteMany(struct soap *soap, ns1__deleteMany *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__deleteMany))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteMany(struct soap *soap, const char *tag, int id,
                                                            ns1__deleteMany *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__deleteMany);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteMany **SOAP_FMAC4 soap_in_PointerTons1__deleteMany(struct soap *soap, const char *tag,
                                                                         ns1__deleteMany **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__deleteMany **)soap_malloc(soap, sizeof(ns1__deleteMany *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__deleteMany *)soap_instantiate_ns1__deleteMany(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__deleteMany **p = (ns1__deleteMany **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteMany, sizeof(ns1__deleteMany), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteMany(struct soap *soap, ns1__deleteMany *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__deleteMany);
  if (soap_out_PointerTons1__deleteMany(soap, tag ? tag : "ns1:deleteMany", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteMany **SOAP_FMAC4 soap_get_PointerTons1__deleteMany(struct soap *soap, ns1__deleteMany **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__deleteMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createManyResponse(struct soap *soap,
                                                                           ns1__createManyResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__createManyResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createManyResponse(struct soap *soap, const char *tag, int id,
                                                                    ns1__createManyResponse *const *a,
                                                                    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__createManyResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createManyResponse **SOAP_FMAC4 soap_in_PointerTons1__createManyResponse(struct soap *soap,
                                                                                         const char *tag,
                                                                                         ns1__createManyResponse **a,
                                                                                         const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__createManyResponse **)soap_malloc(soap, sizeof(ns1__createManyResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__createManyResponse *)soap_instantiate_ns1__createManyResponse(soap, -1, soap->type,
                                                                                   soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__createManyResponse **p = (ns1__createManyResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createManyResponse, sizeof(ns1__createManyResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createManyResponse(struct soap *soap,
                                                                    ns1__createManyResponse *const *a, const char *tag,
                                                                    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__createManyResponse);
  if (soap_out_PointerTons1__createManyResponse(soap, tag ? tag : "ns1:createManyResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createManyResponse **SOAP_FMAC4 soap_get_PointerTons1__createManyResponse(struct soap *soap,
                                                                                          ns1__createManyResponse **p,
                                                                                          const char *tag,
                                                                                          const char *type) {
  if ((p = soap_in_PointerTons1__createManyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createMany(struct soap *soap, ns1__createMany *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__createMany))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createMany(struct soap *soap, const char *tag, int id,
                                                            ns1__createMany *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__createMany);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createMany **SOAP_FMAC4 soap_in_PointerTons1__createMany(struct soap *soap, const char *tag,
                                                                         ns1__createMany **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__createMany **)soap_malloc(soap, sizeof(ns1__createMany *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__createMany *)soap_instantiate_ns1__createMany(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__createMany **p = (ns1__createMany **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createMany, sizeof(ns1__createMany), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createMany(struct soap *soap, ns1__createMany *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__createMany);
  if (soap_out_PointerTons1__createMany(soap, tag ? tag : "ns1:createMany", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createMany **SOAP_FMAC4 soap_get_PointerTons1__createMany(struct soap *soap, ns1__createMany **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__createMany(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneGetPopulatingResponse(
    struct soap *soap, ns1__luceneGetPopulatingResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneGetPopulatingResponse(struct soap *soap, const char *tag, int id,
                                                                             ns1__luceneGetPopulatingResponse *const *a,
                                                                             const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneGetPopulatingResponse **SOAP_FMAC4 soap_in_PointerTons1__luceneGetPopulatingResponse(
    struct soap *soap, const char *tag, ns1__luceneGetPopulatingResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneGetPopulatingResponse **)soap_malloc(soap, sizeof(ns1__luceneGetPopulatingResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneGetPopulatingResponse *)soap_instantiate_ns1__luceneGetPopulatingResponse(
              soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneGetPopulatingResponse **p = (ns1__luceneGetPopulatingResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse,
        sizeof(ns1__luceneGetPopulatingResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneGetPopulatingResponse(struct soap *soap,
                                                                             ns1__luceneGetPopulatingResponse *const *a,
                                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulatingResponse);
  if (soap_out_PointerTons1__luceneGetPopulatingResponse(soap, tag ? tag : "ns1:luceneGetPopulatingResponse", id, a,
                                                         type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneGetPopulatingResponse **SOAP_FMAC4 soap_get_PointerTons1__luceneGetPopulatingResponse(
    struct soap *soap, ns1__luceneGetPopulatingResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneGetPopulatingResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneGetPopulating(struct soap *soap,
                                                                            ns1__luceneGetPopulating *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneGetPopulating))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneGetPopulating(struct soap *soap, const char *tag, int id,
                                                                     ns1__luceneGetPopulating *const *a,
                                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneGetPopulating);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneGetPopulating **SOAP_FMAC4 soap_in_PointerTons1__luceneGetPopulating(struct soap *soap,
                                                                                           const char *tag,
                                                                                           ns1__luceneGetPopulating **a,
                                                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneGetPopulating **)soap_malloc(soap, sizeof(ns1__luceneGetPopulating *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneGetPopulating *)soap_instantiate_ns1__luceneGetPopulating(soap, -1, soap->type,
                                                                                     soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneGetPopulating **p = (ns1__luceneGetPopulating **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneGetPopulating, sizeof(ns1__luceneGetPopulating), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneGetPopulating(struct soap *soap,
                                                                     ns1__luceneGetPopulating *const *a,
                                                                     const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneGetPopulating);
  if (soap_out_PointerTons1__luceneGetPopulating(soap, tag ? tag : "ns1:luceneGetPopulating", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneGetPopulating **SOAP_FMAC4 soap_get_PointerTons1__luceneGetPopulating(
    struct soap *soap, ns1__luceneGetPopulating **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneGetPopulating(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneSearchResponse(struct soap *soap,
                                                                             ns1__luceneSearchResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneSearchResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneSearchResponse(struct soap *soap, const char *tag, int id,
                                                                      ns1__luceneSearchResponse *const *a,
                                                                      const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneSearchResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneSearchResponse **SOAP_FMAC4 soap_in_PointerTons1__luceneSearchResponse(
    struct soap *soap, const char *tag, ns1__luceneSearchResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneSearchResponse **)soap_malloc(soap, sizeof(ns1__luceneSearchResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneSearchResponse *)soap_instantiate_ns1__luceneSearchResponse(soap, -1, soap->type,
                                                                                       soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneSearchResponse **p = (ns1__luceneSearchResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneSearchResponse, sizeof(ns1__luceneSearchResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneSearchResponse(struct soap *soap,
                                                                      ns1__luceneSearchResponse *const *a,
                                                                      const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneSearchResponse);
  if (soap_out_PointerTons1__luceneSearchResponse(soap, tag ? tag : "ns1:luceneSearchResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneSearchResponse **SOAP_FMAC4 soap_get_PointerTons1__luceneSearchResponse(
    struct soap *soap, ns1__luceneSearchResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneSearchResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneSearch(struct soap *soap, ns1__luceneSearch *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneSearch))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneSearch(struct soap *soap, const char *tag, int id,
                                                              ns1__luceneSearch *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneSearch);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneSearch **SOAP_FMAC4 soap_in_PointerTons1__luceneSearch(struct soap *soap, const char *tag,
                                                                             ns1__luceneSearch **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneSearch **)soap_malloc(soap, sizeof(ns1__luceneSearch *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneSearch *)soap_instantiate_ns1__luceneSearch(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneSearch **p = (ns1__luceneSearch **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneSearch, sizeof(ns1__luceneSearch), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneSearch(struct soap *soap, ns1__luceneSearch *const *a,
                                                              const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneSearch);
  if (soap_out_PointerTons1__luceneSearch(soap, tag ? tag : "ns1:luceneSearch", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneSearch **SOAP_FMAC4 soap_get_PointerTons1__luceneSearch(struct soap *soap, ns1__luceneSearch **p,
                                                                              const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneSearch(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneCommitResponse(struct soap *soap,
                                                                             ns1__luceneCommitResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneCommitResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneCommitResponse(struct soap *soap, const char *tag, int id,
                                                                      ns1__luceneCommitResponse *const *a,
                                                                      const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneCommitResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneCommitResponse **SOAP_FMAC4 soap_in_PointerTons1__luceneCommitResponse(
    struct soap *soap, const char *tag, ns1__luceneCommitResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneCommitResponse **)soap_malloc(soap, sizeof(ns1__luceneCommitResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneCommitResponse *)soap_instantiate_ns1__luceneCommitResponse(soap, -1, soap->type,
                                                                                       soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneCommitResponse **p = (ns1__luceneCommitResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneCommitResponse, sizeof(ns1__luceneCommitResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneCommitResponse(struct soap *soap,
                                                                      ns1__luceneCommitResponse *const *a,
                                                                      const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneCommitResponse);
  if (soap_out_PointerTons1__luceneCommitResponse(soap, tag ? tag : "ns1:luceneCommitResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneCommitResponse **SOAP_FMAC4 soap_get_PointerTons1__luceneCommitResponse(
    struct soap *soap, ns1__luceneCommitResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneCommitResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneCommit(struct soap *soap, ns1__luceneCommit *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneCommit))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneCommit(struct soap *soap, const char *tag, int id,
                                                              ns1__luceneCommit *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneCommit);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneCommit **SOAP_FMAC4 soap_in_PointerTons1__luceneCommit(struct soap *soap, const char *tag,
                                                                             ns1__luceneCommit **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneCommit **)soap_malloc(soap, sizeof(ns1__luceneCommit *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneCommit *)soap_instantiate_ns1__luceneCommit(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneCommit **p = (ns1__luceneCommit **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneCommit, sizeof(ns1__luceneCommit), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneCommit(struct soap *soap, ns1__luceneCommit *const *a,
                                                              const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneCommit);
  if (soap_out_PointerTons1__luceneCommit(soap, tag ? tag : "ns1:luceneCommit", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneCommit **SOAP_FMAC4 soap_get_PointerTons1__luceneCommit(struct soap *soap, ns1__luceneCommit **p,
                                                                              const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneCommit(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneClearResponse(struct soap *soap,
                                                                            ns1__luceneClearResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneClearResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneClearResponse(struct soap *soap, const char *tag, int id,
                                                                     ns1__luceneClearResponse *const *a,
                                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneClearResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneClearResponse **SOAP_FMAC4 soap_in_PointerTons1__luceneClearResponse(struct soap *soap,
                                                                                           const char *tag,
                                                                                           ns1__luceneClearResponse **a,
                                                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneClearResponse **)soap_malloc(soap, sizeof(ns1__luceneClearResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneClearResponse *)soap_instantiate_ns1__luceneClearResponse(soap, -1, soap->type,
                                                                                     soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneClearResponse **p = (ns1__luceneClearResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneClearResponse, sizeof(ns1__luceneClearResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneClearResponse(struct soap *soap,
                                                                     ns1__luceneClearResponse *const *a,
                                                                     const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneClearResponse);
  if (soap_out_PointerTons1__luceneClearResponse(soap, tag ? tag : "ns1:luceneClearResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneClearResponse **SOAP_FMAC4 soap_get_PointerTons1__luceneClearResponse(
    struct soap *soap, ns1__luceneClearResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneClearResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__luceneClear(struct soap *soap, ns1__luceneClear *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__luceneClear))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__luceneClear(struct soap *soap, const char *tag, int id,
                                                             ns1__luceneClear *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__luceneClear);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__luceneClear **SOAP_FMAC4 soap_in_PointerTons1__luceneClear(struct soap *soap, const char *tag,
                                                                           ns1__luceneClear **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__luceneClear **)soap_malloc(soap, sizeof(ns1__luceneClear *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__luceneClear *)soap_instantiate_ns1__luceneClear(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__luceneClear **p = (ns1__luceneClear **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneClear, sizeof(ns1__luceneClear), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__luceneClear(struct soap *soap, ns1__luceneClear *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__luceneClear);
  if (soap_out_PointerTons1__luceneClear(soap, tag ? tag : "ns1:luceneClear", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__luceneClear **SOAP_FMAC4 soap_get_PointerTons1__luceneClear(struct soap *soap, ns1__luceneClear **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__luceneClear(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lucenePopulateResponse(struct soap *soap,
                                                                               ns1__lucenePopulateResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lucenePopulateResponse(struct soap *soap, const char *tag, int id,
                                                                        ns1__lucenePopulateResponse *const *a,
                                                                        const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lucenePopulateResponse **SOAP_FMAC4 soap_in_PointerTons1__lucenePopulateResponse(
    struct soap *soap, const char *tag, ns1__lucenePopulateResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__lucenePopulateResponse **)soap_malloc(soap, sizeof(ns1__lucenePopulateResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__lucenePopulateResponse *)soap_instantiate_ns1__lucenePopulateResponse(soap, -1, soap->type,
                                                                                           soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__lucenePopulateResponse **p = (ns1__lucenePopulateResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse, sizeof(ns1__lucenePopulateResponse),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lucenePopulateResponse(struct soap *soap,
                                                                        ns1__lucenePopulateResponse *const *a,
                                                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__lucenePopulateResponse);
  if (soap_out_PointerTons1__lucenePopulateResponse(soap, tag ? tag : "ns1:lucenePopulateResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lucenePopulateResponse **SOAP_FMAC4 soap_get_PointerTons1__lucenePopulateResponse(
    struct soap *soap, ns1__lucenePopulateResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__lucenePopulateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lucenePopulate(struct soap *soap,
                                                                       ns1__lucenePopulate *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__lucenePopulate))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lucenePopulate(struct soap *soap, const char *tag, int id,
                                                                ns1__lucenePopulate *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__lucenePopulate);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lucenePopulate **SOAP_FMAC4 soap_in_PointerTons1__lucenePopulate(struct soap *soap, const char *tag,
                                                                                 ns1__lucenePopulate **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__lucenePopulate **)soap_malloc(soap, sizeof(ns1__lucenePopulate *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__lucenePopulate *)soap_instantiate_ns1__lucenePopulate(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__lucenePopulate **p = (ns1__lucenePopulate **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__lucenePopulate, sizeof(ns1__lucenePopulate), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lucenePopulate(struct soap *soap, ns1__lucenePopulate *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__lucenePopulate);
  if (soap_out_PointerTons1__lucenePopulate(soap, tag ? tag : "ns1:lucenePopulate", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lucenePopulate **SOAP_FMAC4 soap_get_PointerTons1__lucenePopulate(struct soap *soap,
                                                                                  ns1__lucenePopulate **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__lucenePopulate(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTons1__isAccessAllowedResponse(struct soap *soap, ns1__isAccessAllowedResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__isAccessAllowedResponse(struct soap *soap, const char *tag, int id,
                                                                         ns1__isAccessAllowedResponse *const *a,
                                                                         const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__isAccessAllowedResponse **SOAP_FMAC4 soap_in_PointerTons1__isAccessAllowedResponse(
    struct soap *soap, const char *tag, ns1__isAccessAllowedResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__isAccessAllowedResponse **)soap_malloc(soap, sizeof(ns1__isAccessAllowedResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__isAccessAllowedResponse *)soap_instantiate_ns1__isAccessAllowedResponse(soap, -1, soap->type,
                                                                                             soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__isAccessAllowedResponse **p = (ns1__isAccessAllowedResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse,
        sizeof(ns1__isAccessAllowedResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__isAccessAllowedResponse(struct soap *soap,
                                                                         ns1__isAccessAllowedResponse *const *a,
                                                                         const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__isAccessAllowedResponse);
  if (soap_out_PointerTons1__isAccessAllowedResponse(soap, tag ? tag : "ns1:isAccessAllowedResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__isAccessAllowedResponse **SOAP_FMAC4 soap_get_PointerTons1__isAccessAllowedResponse(
    struct soap *soap, ns1__isAccessAllowedResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__isAccessAllowedResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__isAccessAllowed(struct soap *soap,
                                                                        ns1__isAccessAllowed *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__isAccessAllowed))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__isAccessAllowed(struct soap *soap, const char *tag, int id,
                                                                 ns1__isAccessAllowed *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__isAccessAllowed);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__isAccessAllowed **SOAP_FMAC4 soap_in_PointerTons1__isAccessAllowed(struct soap *soap, const char *tag,
                                                                                   ns1__isAccessAllowed **a,
                                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__isAccessAllowed **)soap_malloc(soap, sizeof(ns1__isAccessAllowed *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__isAccessAllowed *)soap_instantiate_ns1__isAccessAllowed(soap, -1, soap->type, soap->arrayType,
                                                                             nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__isAccessAllowed **p = (ns1__isAccessAllowed **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__isAccessAllowed, sizeof(ns1__isAccessAllowed), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__isAccessAllowed(struct soap *soap, ns1__isAccessAllowed *const *a,
                                                                 const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__isAccessAllowed);
  if (soap_out_PointerTons1__isAccessAllowed(soap, tag ? tag : "ns1:isAccessAllowed", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__isAccessAllowed **SOAP_FMAC4 soap_get_PointerTons1__isAccessAllowed(struct soap *soap,
                                                                                    ns1__isAccessAllowed **p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__isAccessAllowed(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchTextResponse(struct soap *soap,
                                                                           ns1__searchTextResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__searchTextResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchTextResponse(struct soap *soap, const char *tag, int id,
                                                                    ns1__searchTextResponse *const *a,
                                                                    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__searchTextResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchTextResponse **SOAP_FMAC4 soap_in_PointerTons1__searchTextResponse(struct soap *soap,
                                                                                         const char *tag,
                                                                                         ns1__searchTextResponse **a,
                                                                                         const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__searchTextResponse **)soap_malloc(soap, sizeof(ns1__searchTextResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__searchTextResponse *)soap_instantiate_ns1__searchTextResponse(soap, -1, soap->type,
                                                                                   soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__searchTextResponse **p = (ns1__searchTextResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchTextResponse, sizeof(ns1__searchTextResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchTextResponse(struct soap *soap,
                                                                    ns1__searchTextResponse *const *a, const char *tag,
                                                                    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__searchTextResponse);
  if (soap_out_PointerTons1__searchTextResponse(soap, tag ? tag : "ns1:searchTextResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchTextResponse **SOAP_FMAC4 soap_get_PointerTons1__searchTextResponse(struct soap *soap,
                                                                                          ns1__searchTextResponse **p,
                                                                                          const char *tag,
                                                                                          const char *type) {
  if ((p = soap_in_PointerTons1__searchTextResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchText(struct soap *soap, ns1__searchText *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__searchText))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchText(struct soap *soap, const char *tag, int id,
                                                            ns1__searchText *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__searchText);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchText **SOAP_FMAC4 soap_in_PointerTons1__searchText(struct soap *soap, const char *tag,
                                                                         ns1__searchText **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__searchText **)soap_malloc(soap, sizeof(ns1__searchText *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__searchText *)soap_instantiate_ns1__searchText(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__searchText **p = (ns1__searchText **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchText, sizeof(ns1__searchText), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchText(struct soap *soap, ns1__searchText *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__searchText);
  if (soap_out_PointerTons1__searchText(soap, tag ? tag : "ns1:searchText", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchText **SOAP_FMAC4 soap_get_PointerTons1__searchText(struct soap *soap, ns1__searchText **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__searchText(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRemainingMinutesResponse(
    struct soap *soap, ns1__getRemainingMinutesResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRemainingMinutesResponse(struct soap *soap, const char *tag, int id,
                                                                             ns1__getRemainingMinutesResponse *const *a,
                                                                             const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRemainingMinutesResponse **SOAP_FMAC4 soap_in_PointerTons1__getRemainingMinutesResponse(
    struct soap *soap, const char *tag, ns1__getRemainingMinutesResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getRemainingMinutesResponse **)soap_malloc(soap, sizeof(ns1__getRemainingMinutesResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getRemainingMinutesResponse *)soap_instantiate_ns1__getRemainingMinutesResponse(
              soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getRemainingMinutesResponse **p = (ns1__getRemainingMinutesResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse,
        sizeof(ns1__getRemainingMinutesResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRemainingMinutesResponse(struct soap *soap,
                                                                             ns1__getRemainingMinutesResponse *const *a,
                                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutesResponse);
  if (soap_out_PointerTons1__getRemainingMinutesResponse(soap, tag ? tag : "ns1:getRemainingMinutesResponse", id, a,
                                                         type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRemainingMinutesResponse **SOAP_FMAC4 soap_get_PointerTons1__getRemainingMinutesResponse(
    struct soap *soap, ns1__getRemainingMinutesResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getRemainingMinutesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRemainingMinutes(struct soap *soap,
                                                                            ns1__getRemainingMinutes *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getRemainingMinutes))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRemainingMinutes(struct soap *soap, const char *tag, int id,
                                                                     ns1__getRemainingMinutes *const *a,
                                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getRemainingMinutes);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRemainingMinutes **SOAP_FMAC4 soap_in_PointerTons1__getRemainingMinutes(struct soap *soap,
                                                                                           const char *tag,
                                                                                           ns1__getRemainingMinutes **a,
                                                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getRemainingMinutes **)soap_malloc(soap, sizeof(ns1__getRemainingMinutes *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getRemainingMinutes *)soap_instantiate_ns1__getRemainingMinutes(soap, -1, soap->type,
                                                                                     soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getRemainingMinutes **p = (ns1__getRemainingMinutes **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getRemainingMinutes, sizeof(ns1__getRemainingMinutes), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRemainingMinutes(struct soap *soap,
                                                                     ns1__getRemainingMinutes *const *a,
                                                                     const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getRemainingMinutes);
  if (soap_out_PointerTons1__getRemainingMinutes(soap, tag ? tag : "ns1:getRemainingMinutes", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRemainingMinutes **SOAP_FMAC4 soap_get_PointerTons1__getRemainingMinutes(
    struct soap *soap, ns1__getRemainingMinutes **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getRemainingMinutes(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap,
                                                                       ns1__logoutResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__logoutResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id,
                                                                ns1__logoutResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__logoutResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logoutResponse **SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag,
                                                                                 ns1__logoutResponse **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__logoutResponse **)soap_malloc(soap, sizeof(ns1__logoutResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__logoutResponse *)soap_instantiate_ns1__logoutResponse(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__logoutResponse **p = (ns1__logoutResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__logoutResponse);
  if (soap_out_PointerTons1__logoutResponse(soap, tag ? tag : "ns1:logoutResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logoutResponse **SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap,
                                                                                  ns1__logoutResponse **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logout(struct soap *soap, ns1__logout *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__logout))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logout(struct soap *soap, const char *tag, int id,
                                                        ns1__logout *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__logout);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logout **SOAP_FMAC4 soap_in_PointerTons1__logout(struct soap *soap, const char *tag, ns1__logout **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__logout **)soap_malloc(soap, sizeof(ns1__logout *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__logout *)soap_instantiate_ns1__logout(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__logout **p = (ns1__logout **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__logout,
                                                     sizeof(ns1__logout), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logout(struct soap *soap, ns1__logout *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__logout);
  if (soap_out_PointerTons1__logout(soap, tag ? tag : "ns1:logout", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logout **SOAP_FMAC4 soap_get_PointerTons1__logout(struct soap *soap, ns1__logout **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__logout(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dummyResponse(struct soap *soap, ns1__dummyResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dummyResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dummyResponse(struct soap *soap, const char *tag, int id,
                                                               ns1__dummyResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dummyResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dummyResponse **SOAP_FMAC4 soap_in_PointerTons1__dummyResponse(struct soap *soap, const char *tag,
                                                                               ns1__dummyResponse **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dummyResponse **)soap_malloc(soap, sizeof(ns1__dummyResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dummyResponse *)soap_instantiate_ns1__dummyResponse(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dummyResponse **p = (ns1__dummyResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dummyResponse, sizeof(ns1__dummyResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dummyResponse(struct soap *soap, ns1__dummyResponse *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dummyResponse);
  if (soap_out_PointerTons1__dummyResponse(soap, tag ? tag : "ns1:dummyResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dummyResponse **SOAP_FMAC4 soap_get_PointerTons1__dummyResponse(struct soap *soap,
                                                                                ns1__dummyResponse **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__dummyResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dummy(struct soap *soap, ns1__dummy *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dummy))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dummy(struct soap *soap, const char *tag, int id, ns1__dummy *const *a,
                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dummy);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dummy **SOAP_FMAC4 soap_in_PointerTons1__dummy(struct soap *soap, const char *tag, ns1__dummy **a,
                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dummy **)soap_malloc(soap, sizeof(ns1__dummy *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dummy *)soap_instantiate_ns1__dummy(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dummy **p =
        (ns1__dummy **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dummy, sizeof(ns1__dummy), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dummy(struct soap *soap, ns1__dummy *const *a, const char *tag,
                                                       const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dummy);
  if (soap_out_PointerTons1__dummy(soap, tag ? tag : "ns1:dummy", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dummy **SOAP_FMAC4 soap_get_PointerTons1__dummy(struct soap *soap, ns1__dummy **p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_PointerTons1__dummy(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refreshResponse(struct soap *soap,
                                                                        ns1__refreshResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__refreshResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refreshResponse(struct soap *soap, const char *tag, int id,
                                                                 ns1__refreshResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__refreshResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__refreshResponse **SOAP_FMAC4 soap_in_PointerTons1__refreshResponse(struct soap *soap, const char *tag,
                                                                                   ns1__refreshResponse **a,
                                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__refreshResponse **)soap_malloc(soap, sizeof(ns1__refreshResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__refreshResponse *)soap_instantiate_ns1__refreshResponse(soap, -1, soap->type, soap->arrayType,
                                                                             nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__refreshResponse **p = (ns1__refreshResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__refreshResponse, sizeof(ns1__refreshResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refreshResponse(struct soap *soap, ns1__refreshResponse *const *a,
                                                                 const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__refreshResponse);
  if (soap_out_PointerTons1__refreshResponse(soap, tag ? tag : "ns1:refreshResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__refreshResponse **SOAP_FMAC4 soap_get_PointerTons1__refreshResponse(struct soap *soap,
                                                                                    ns1__refreshResponse **p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__refreshResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refresh(struct soap *soap, ns1__refresh *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__refresh))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refresh(struct soap *soap, const char *tag, int id,
                                                         ns1__refresh *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__refresh);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__refresh **SOAP_FMAC4 soap_in_PointerTons1__refresh(struct soap *soap, const char *tag, ns1__refresh **a,
                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__refresh **)soap_malloc(soap, sizeof(ns1__refresh *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__refresh *)soap_instantiate_ns1__refresh(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__refresh **p = (ns1__refresh **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__refresh,
                                                       sizeof(ns1__refresh), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refresh(struct soap *soap, ns1__refresh *const *a, const char *tag,
                                                         const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__refresh);
  if (soap_out_PointerTons1__refresh(soap, tag ? tag : "ns1:refresh", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__refresh **SOAP_FMAC4 soap_get_PointerTons1__refresh(struct soap *soap, ns1__refresh **p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__refresh(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityNamesResponse(struct soap *soap,
                                                                               ns1__getEntityNamesResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityNamesResponse(struct soap *soap, const char *tag, int id,
                                                                        ns1__getEntityNamesResponse *const *a,
                                                                        const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityNamesResponse **SOAP_FMAC4 soap_in_PointerTons1__getEntityNamesResponse(
    struct soap *soap, const char *tag, ns1__getEntityNamesResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getEntityNamesResponse **)soap_malloc(soap, sizeof(ns1__getEntityNamesResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getEntityNamesResponse *)soap_instantiate_ns1__getEntityNamesResponse(soap, -1, soap->type,
                                                                                           soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getEntityNamesResponse **p = (ns1__getEntityNamesResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse, sizeof(ns1__getEntityNamesResponse),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityNamesResponse(struct soap *soap,
                                                                        ns1__getEntityNamesResponse *const *a,
                                                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getEntityNamesResponse);
  if (soap_out_PointerTons1__getEntityNamesResponse(soap, tag ? tag : "ns1:getEntityNamesResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getEntityNamesResponse **SOAP_FMAC4 soap_get_PointerTons1__getEntityNamesResponse(
    struct soap *soap, ns1__getEntityNamesResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getEntityNamesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityNames(struct soap *soap,
                                                                       ns1__getEntityNames *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getEntityNames))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityNames(struct soap *soap, const char *tag, int id,
                                                                ns1__getEntityNames *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getEntityNames);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityNames **SOAP_FMAC4 soap_in_PointerTons1__getEntityNames(struct soap *soap, const char *tag,
                                                                                 ns1__getEntityNames **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getEntityNames **)soap_malloc(soap, sizeof(ns1__getEntityNames *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getEntityNames *)soap_instantiate_ns1__getEntityNames(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getEntityNames **p = (ns1__getEntityNames **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityNames, sizeof(ns1__getEntityNames), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityNames(struct soap *soap, ns1__getEntityNames *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getEntityNames);
  if (soap_out_PointerTons1__getEntityNames(soap, tag ? tag : "ns1:getEntityNames", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getEntityNames **SOAP_FMAC4 soap_get_PointerTons1__getEntityNames(struct soap *soap,
                                                                                  ns1__getEntityNames **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getEntityNames(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getApiVersionResponse(struct soap *soap,
                                                                              ns1__getApiVersionResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getApiVersionResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getApiVersionResponse(struct soap *soap, const char *tag, int id,
                                                                       ns1__getApiVersionResponse *const *a,
                                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getApiVersionResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getApiVersionResponse **SOAP_FMAC4 soap_in_PointerTons1__getApiVersionResponse(
    struct soap *soap, const char *tag, ns1__getApiVersionResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getApiVersionResponse **)soap_malloc(soap, sizeof(ns1__getApiVersionResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getApiVersionResponse *)soap_instantiate_ns1__getApiVersionResponse(soap, -1, soap->type,
                                                                                         soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getApiVersionResponse **p = (ns1__getApiVersionResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getApiVersionResponse, sizeof(ns1__getApiVersionResponse),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getApiVersionResponse(struct soap *soap,
                                                                       ns1__getApiVersionResponse *const *a,
                                                                       const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getApiVersionResponse);
  if (soap_out_PointerTons1__getApiVersionResponse(soap, tag ? tag : "ns1:getApiVersionResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getApiVersionResponse **SOAP_FMAC4 soap_get_PointerTons1__getApiVersionResponse(
    struct soap *soap, ns1__getApiVersionResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getApiVersionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getApiVersion(struct soap *soap, ns1__getApiVersion *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getApiVersion))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getApiVersion(struct soap *soap, const char *tag, int id,
                                                               ns1__getApiVersion *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getApiVersion);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getApiVersion **SOAP_FMAC4 soap_in_PointerTons1__getApiVersion(struct soap *soap, const char *tag,
                                                                               ns1__getApiVersion **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getApiVersion **)soap_malloc(soap, sizeof(ns1__getApiVersion *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getApiVersion *)soap_instantiate_ns1__getApiVersion(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getApiVersion **p = (ns1__getApiVersion **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getApiVersion, sizeof(ns1__getApiVersion), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getApiVersion(struct soap *soap, ns1__getApiVersion *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getApiVersion);
  if (soap_out_PointerTons1__getApiVersion(soap, tag ? tag : "ns1:getApiVersion", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getApiVersion **SOAP_FMAC4 soap_get_PointerTons1__getApiVersion(struct soap *soap,
                                                                                ns1__getApiVersion **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__getApiVersion(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateResponse(struct soap *soap,
                                                                       ns1__updateResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__updateResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateResponse(struct soap *soap, const char *tag, int id,
                                                                ns1__updateResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__updateResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateResponse **SOAP_FMAC4 soap_in_PointerTons1__updateResponse(struct soap *soap, const char *tag,
                                                                                 ns1__updateResponse **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__updateResponse **)soap_malloc(soap, sizeof(ns1__updateResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__updateResponse *)soap_instantiate_ns1__updateResponse(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__updateResponse **p = (ns1__updateResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__updateResponse, sizeof(ns1__updateResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateResponse(struct soap *soap, ns1__updateResponse *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__updateResponse);
  if (soap_out_PointerTons1__updateResponse(soap, tag ? tag : "ns1:updateResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateResponse **SOAP_FMAC4 soap_get_PointerTons1__updateResponse(struct soap *soap,
                                                                                  ns1__updateResponse **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__updateResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__update(struct soap *soap, ns1__update *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__update))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__update(struct soap *soap, const char *tag, int id,
                                                        ns1__update *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__update);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__update **SOAP_FMAC4 soap_in_PointerTons1__update(struct soap *soap, const char *tag, ns1__update **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__update **)soap_malloc(soap, sizeof(ns1__update *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__update *)soap_instantiate_ns1__update(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__update **p = (ns1__update **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__update,
                                                     sizeof(ns1__update), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__update(struct soap *soap, ns1__update *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__update);
  if (soap_out_PointerTons1__update(soap, tag ? tag : "ns1:update", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__update **SOAP_FMAC4 soap_get_PointerTons1__update(struct soap *soap, ns1__update **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__update(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createResponse(struct soap *soap,
                                                                       ns1__createResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__createResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createResponse(struct soap *soap, const char *tag, int id,
                                                                ns1__createResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__createResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createResponse **SOAP_FMAC4 soap_in_PointerTons1__createResponse(struct soap *soap, const char *tag,
                                                                                 ns1__createResponse **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__createResponse **)soap_malloc(soap, sizeof(ns1__createResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__createResponse *)soap_instantiate_ns1__createResponse(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__createResponse **p = (ns1__createResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createResponse, sizeof(ns1__createResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createResponse(struct soap *soap, ns1__createResponse *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__createResponse);
  if (soap_out_PointerTons1__createResponse(soap, tag ? tag : "ns1:createResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__createResponse **SOAP_FMAC4 soap_get_PointerTons1__createResponse(struct soap *soap,
                                                                                  ns1__createResponse **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__createResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__create(struct soap *soap, ns1__create *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__create))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__create(struct soap *soap, const char *tag, int id,
                                                        ns1__create *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__create);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__create **SOAP_FMAC4 soap_in_PointerTons1__create(struct soap *soap, const char *tag, ns1__create **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__create **)soap_malloc(soap, sizeof(ns1__create *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__create *)soap_instantiate_ns1__create(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__create **p = (ns1__create **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__create,
                                                     sizeof(ns1__create), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__create(struct soap *soap, ns1__create *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__create);
  if (soap_out_PointerTons1__create(soap, tag ? tag : "ns1:create", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__create **SOAP_FMAC4 soap_get_PointerTons1__create(struct soap *soap, ns1__create **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__create(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchResponse(struct soap *soap,
                                                                       ns1__searchResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__searchResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchResponse(struct soap *soap, const char *tag, int id,
                                                                ns1__searchResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__searchResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchResponse **SOAP_FMAC4 soap_in_PointerTons1__searchResponse(struct soap *soap, const char *tag,
                                                                                 ns1__searchResponse **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__searchResponse **)soap_malloc(soap, sizeof(ns1__searchResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__searchResponse *)soap_instantiate_ns1__searchResponse(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__searchResponse **p = (ns1__searchResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchResponse, sizeof(ns1__searchResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchResponse(struct soap *soap, ns1__searchResponse *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__searchResponse);
  if (soap_out_PointerTons1__searchResponse(soap, tag ? tag : "ns1:searchResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchResponse **SOAP_FMAC4 soap_get_PointerTons1__searchResponse(struct soap *soap,
                                                                                  ns1__searchResponse **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__searchResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__search(struct soap *soap, ns1__search *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__search))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__search(struct soap *soap, const char *tag, int id,
                                                        ns1__search *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__search);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__search **SOAP_FMAC4 soap_in_PointerTons1__search(struct soap *soap, const char *tag, ns1__search **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__search **)soap_malloc(soap, sizeof(ns1__search *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__search *)soap_instantiate_ns1__search(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__search **p = (ns1__search **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__search,
                                                     sizeof(ns1__search), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__search(struct soap *soap, ns1__search *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__search);
  if (soap_out_PointerTons1__search(soap, tag ? tag : "ns1:search", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__search **SOAP_FMAC4 soap_get_PointerTons1__search(struct soap *soap, ns1__search **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__search(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteResponse(struct soap *soap,
                                                                       ns1__deleteResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__deleteResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteResponse(struct soap *soap, const char *tag, int id,
                                                                ns1__deleteResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__deleteResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteResponse **SOAP_FMAC4 soap_in_PointerTons1__deleteResponse(struct soap *soap, const char *tag,
                                                                                 ns1__deleteResponse **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__deleteResponse **)soap_malloc(soap, sizeof(ns1__deleteResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__deleteResponse *)soap_instantiate_ns1__deleteResponse(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__deleteResponse **p = (ns1__deleteResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteResponse, sizeof(ns1__deleteResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteResponse(struct soap *soap, ns1__deleteResponse *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__deleteResponse);
  if (soap_out_PointerTons1__deleteResponse(soap, tag ? tag : "ns1:deleteResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteResponse **SOAP_FMAC4 soap_get_PointerTons1__deleteResponse(struct soap *soap,
                                                                                  ns1__deleteResponse **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__deleteResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__delete(struct soap *soap, ns1__delete *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__delete))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__delete(struct soap *soap, const char *tag, int id,
                                                        ns1__delete *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__delete);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__delete **SOAP_FMAC4 soap_in_PointerTons1__delete(struct soap *soap, const char *tag, ns1__delete **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__delete **)soap_malloc(soap, sizeof(ns1__delete *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__delete *)soap_instantiate_ns1__delete(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__delete **p = (ns1__delete **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__delete,
                                                     sizeof(ns1__delete), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__delete(struct soap *soap, ns1__delete *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__delete);
  if (soap_out_PointerTons1__delete(soap, tag ? tag : "ns1:delete", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__delete **SOAP_FMAC4 soap_get_PointerTons1__delete(struct soap *soap, ns1__delete **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__delete(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPropertiesResponse(struct soap *soap,
                                                                              ns1__getPropertiesResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getPropertiesResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPropertiesResponse(struct soap *soap, const char *tag, int id,
                                                                       ns1__getPropertiesResponse *const *a,
                                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getPropertiesResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPropertiesResponse **SOAP_FMAC4 soap_in_PointerTons1__getPropertiesResponse(
    struct soap *soap, const char *tag, ns1__getPropertiesResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getPropertiesResponse **)soap_malloc(soap, sizeof(ns1__getPropertiesResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getPropertiesResponse *)soap_instantiate_ns1__getPropertiesResponse(soap, -1, soap->type,
                                                                                         soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getPropertiesResponse **p = (ns1__getPropertiesResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getPropertiesResponse, sizeof(ns1__getPropertiesResponse),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPropertiesResponse(struct soap *soap,
                                                                       ns1__getPropertiesResponse *const *a,
                                                                       const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getPropertiesResponse);
  if (soap_out_PointerTons1__getPropertiesResponse(soap, tag ? tag : "ns1:getPropertiesResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPropertiesResponse **SOAP_FMAC4 soap_get_PointerTons1__getPropertiesResponse(
    struct soap *soap, ns1__getPropertiesResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getPropertiesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProperties(struct soap *soap, ns1__getProperties *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getProperties))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProperties(struct soap *soap, const char *tag, int id,
                                                               ns1__getProperties *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getProperties);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProperties **SOAP_FMAC4 soap_in_PointerTons1__getProperties(struct soap *soap, const char *tag,
                                                                               ns1__getProperties **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getProperties **)soap_malloc(soap, sizeof(ns1__getProperties *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getProperties *)soap_instantiate_ns1__getProperties(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getProperties **p = (ns1__getProperties **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getProperties, sizeof(ns1__getProperties), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProperties(struct soap *soap, ns1__getProperties *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getProperties);
  if (soap_out_PointerTons1__getProperties(soap, tag ? tag : "ns1:getProperties", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProperties **SOAP_FMAC4 soap_get_PointerTons1__getProperties(struct soap *soap,
                                                                                ns1__getProperties **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__getProperties(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getResponse(struct soap *soap, ns1__getResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getResponse(struct soap *soap, const char *tag, int id,
                                                             ns1__getResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getResponse **SOAP_FMAC4 soap_in_PointerTons1__getResponse(struct soap *soap, const char *tag,
                                                                           ns1__getResponse **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getResponse **)soap_malloc(soap, sizeof(ns1__getResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getResponse *)soap_instantiate_ns1__getResponse(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getResponse **p = (ns1__getResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getResponse, sizeof(ns1__getResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getResponse(struct soap *soap, ns1__getResponse *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getResponse);
  if (soap_out_PointerTons1__getResponse(soap, tag ? tag : "ns1:getResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getResponse **SOAP_FMAC4 soap_get_PointerTons1__getResponse(struct soap *soap, ns1__getResponse **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get(struct soap *soap, ns1__get *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__get))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get(struct soap *soap, const char *tag, int id, ns1__get *const *a,
                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__get);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__get **SOAP_FMAC4 soap_in_PointerTons1__get(struct soap *soap, const char *tag, ns1__get **a,
                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__get **)soap_malloc(soap, sizeof(ns1__get *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__get *)soap_instantiate_ns1__get(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__get **p =
        (ns1__get **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__get, sizeof(ns1__get), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get(struct soap *soap, ns1__get *const *a, const char *tag,
                                                     const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__get);
  if (soap_out_PointerTons1__get(soap, tag ? tag : "ns1:get", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__get **SOAP_FMAC4 soap_get_PointerTons1__get(struct soap *soap, ns1__get **p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_PointerTons1__get(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getUserNameResponse(struct soap *soap,
                                                                            ns1__getUserNameResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getUserNameResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getUserNameResponse(struct soap *soap, const char *tag, int id,
                                                                     ns1__getUserNameResponse *const *a,
                                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getUserNameResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getUserNameResponse **SOAP_FMAC4 soap_in_PointerTons1__getUserNameResponse(struct soap *soap,
                                                                                           const char *tag,
                                                                                           ns1__getUserNameResponse **a,
                                                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getUserNameResponse **)soap_malloc(soap, sizeof(ns1__getUserNameResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getUserNameResponse *)soap_instantiate_ns1__getUserNameResponse(soap, -1, soap->type,
                                                                                     soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getUserNameResponse **p = (ns1__getUserNameResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getUserNameResponse, sizeof(ns1__getUserNameResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getUserNameResponse(struct soap *soap,
                                                                     ns1__getUserNameResponse *const *a,
                                                                     const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getUserNameResponse);
  if (soap_out_PointerTons1__getUserNameResponse(soap, tag ? tag : "ns1:getUserNameResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getUserNameResponse **SOAP_FMAC4 soap_get_PointerTons1__getUserNameResponse(
    struct soap *soap, ns1__getUserNameResponse **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getUserNameResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getUserName(struct soap *soap, ns1__getUserName *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__getUserName))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getUserName(struct soap *soap, const char *tag, int id,
                                                             ns1__getUserName *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__getUserName);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getUserName **SOAP_FMAC4 soap_in_PointerTons1__getUserName(struct soap *soap, const char *tag,
                                                                           ns1__getUserName **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__getUserName **)soap_malloc(soap, sizeof(ns1__getUserName *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__getUserName *)soap_instantiate_ns1__getUserName(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__getUserName **p = (ns1__getUserName **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getUserName, sizeof(ns1__getUserName), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getUserName(struct soap *soap, ns1__getUserName *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__getUserName);
  if (soap_out_PointerTons1__getUserName(soap, tag ? tag : "ns1:getUserName", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getUserName **SOAP_FMAC4 soap_get_PointerTons1__getUserName(struct soap *soap, ns1__getUserName **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getUserName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__loginResponse))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginResponse(struct soap *soap, const char *tag, int id,
                                                               ns1__loginResponse *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__loginResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loginResponse **SOAP_FMAC4 soap_in_PointerTons1__loginResponse(struct soap *soap, const char *tag,
                                                                               ns1__loginResponse **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__loginResponse **)soap_malloc(soap, sizeof(ns1__loginResponse *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__loginResponse *)soap_instantiate_ns1__loginResponse(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__loginResponse **p = (ns1__loginResponse **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__loginResponse, sizeof(ns1__loginResponse), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginResponse(struct soap *soap, ns1__loginResponse *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__loginResponse);
  if (soap_out_PointerTons1__loginResponse(soap, tag ? tag : "ns1:loginResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loginResponse **SOAP_FMAC4 soap_get_PointerTons1__loginResponse(struct soap *soap,
                                                                                ns1__loginResponse **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__loginResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__login(struct soap *soap, ns1__login *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__login))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__login(struct soap *soap, const char *tag, int id, ns1__login *const *a,
                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__login);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__login **SOAP_FMAC4 soap_in_PointerTons1__login(struct soap *soap, const char *tag, ns1__login **a,
                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__login **)soap_malloc(soap, sizeof(ns1__login *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__login *)soap_instantiate_ns1__login(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__login **p =
        (ns1__login **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__login, sizeof(ns1__login), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__login(struct soap *soap, ns1__login *const *a, const char *tag,
                                                       const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__login);
  if (soap_out_PointerTons1__login(soap, tag ? tag : "ns1:login", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__login **SOAP_FMAC4 soap_get_PointerTons1__login(struct soap *soap, ns1__login **p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_PointerTons1__login(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IcatException(struct soap *soap, ns1__IcatException *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__IcatException))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IcatException(struct soap *soap, const char *tag, int id,
                                                               ns1__IcatException *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__IcatException);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__IcatException **SOAP_FMAC4 soap_in_PointerTons1__IcatException(struct soap *soap, const char *tag,
                                                                               ns1__IcatException **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__IcatException **)soap_malloc(soap, sizeof(ns1__IcatException *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__IcatException *)soap_instantiate_ns1__IcatException(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__IcatException **p = (ns1__IcatException **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__IcatException, sizeof(ns1__IcatException), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IcatException(struct soap *soap, ns1__IcatException *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__IcatException);
  if (soap_out_PointerTons1__IcatException(soap, tag ? tag : "ns1:IcatException", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__IcatException **SOAP_FMAC4 soap_get_PointerTons1__IcatException(struct soap *soap,
                                                                                ns1__IcatException **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__IcatException(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__parameterValueType(struct soap *soap,
                                                                           enum ns1__parameterValueType *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__parameterValueType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__parameterValueType(struct soap *soap, const char *tag, int id,
                                                                    enum ns1__parameterValueType *const *a,
                                                                    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__parameterValueType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__parameterValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__parameterValueType **SOAP_FMAC4 soap_in_PointerTons1__parameterValueType(
    struct soap *soap, const char *tag, enum ns1__parameterValueType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (enum ns1__parameterValueType **)soap_malloc(soap, sizeof(enum ns1__parameterValueType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__parameterValueType(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (enum ns1__parameterValueType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameterValueType, sizeof(enum ns1__parameterValueType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__parameterValueType(struct soap *soap,
                                                                    enum ns1__parameterValueType *const *a,
                                                                    const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__parameterValueType);
  if (soap_out_PointerTons1__parameterValueType(soap, tag ? tag : "ns1:parameterValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__parameterValueType **SOAP_FMAC4 soap_get_PointerTons1__parameterValueType(
    struct soap *soap, enum ns1__parameterValueType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__parameterValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__permissibleStringValue(struct soap *soap,
                                                                               ns1__permissibleStringValue *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__permissibleStringValue))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__permissibleStringValue(struct soap *soap, const char *tag, int id,
                                                                        ns1__permissibleStringValue *const *a,
                                                                        const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__permissibleStringValue);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__permissibleStringValue **SOAP_FMAC4 soap_in_PointerTons1__permissibleStringValue(
    struct soap *soap, const char *tag, ns1__permissibleStringValue **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__permissibleStringValue **)soap_malloc(soap, sizeof(ns1__permissibleStringValue *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__permissibleStringValue *)soap_instantiate_ns1__permissibleStringValue(soap, -1, soap->type,
                                                                                           soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__permissibleStringValue **p = (ns1__permissibleStringValue **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__permissibleStringValue, sizeof(ns1__permissibleStringValue),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__permissibleStringValue(struct soap *soap,
                                                                        ns1__permissibleStringValue *const *a,
                                                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__permissibleStringValue);
  if (soap_out_PointerTons1__permissibleStringValue(soap, tag ? tag : "ns1:permissibleStringValue", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__permissibleStringValue **SOAP_FMAC4 soap_get_PointerTons1__permissibleStringValue(
    struct soap *soap, ns1__permissibleStringValue **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__permissibleStringValue(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const *a,
                                                   const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_double);
  if (id < 0)
    return soap->error;
  return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double **SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a,
                                                       const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_double(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (double **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_double, sizeof(double), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const *a, const char *tag,
                                                   const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTodouble);
  if (soap_out_PointerTodouble(soap, tag ? tag : "double", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 double **SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__rule(struct soap *soap, ns1__rule *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__rule))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__rule(struct soap *soap, const char *tag, int id, ns1__rule *const *a,
                                                      const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__rule);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__rule **SOAP_FMAC4 soap_in_PointerTons1__rule(struct soap *soap, const char *tag, ns1__rule **a,
                                                             const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__rule **)soap_malloc(soap, sizeof(ns1__rule *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__rule *)soap_instantiate_ns1__rule(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__rule **p =
        (ns1__rule **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__rule, sizeof(ns1__rule), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__rule(struct soap *soap, ns1__rule *const *a, const char *tag,
                                                      const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__rule);
  if (soap_out_PointerTons1__rule(soap, tag ? tag : "ns1:rule", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__rule **SOAP_FMAC4 soap_get_PointerTons1__rule(struct soap *soap, ns1__rule **p, const char *tag,
                                                              const char *type) {
  if ((p = soap_in_PointerTons1__rule(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sampleType(struct soap *soap, ns1__sampleType *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__sampleType))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sampleType(struct soap *soap, const char *tag, int id,
                                                            ns1__sampleType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__sampleType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sampleType **SOAP_FMAC4 soap_in_PointerTons1__sampleType(struct soap *soap, const char *tag,
                                                                         ns1__sampleType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__sampleType **)soap_malloc(soap, sizeof(ns1__sampleType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__sampleType *)soap_instantiate_ns1__sampleType(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__sampleType **p = (ns1__sampleType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleType, sizeof(ns1__sampleType), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sampleType(struct soap *soap, ns1__sampleType *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__sampleType);
  if (soap_out_PointerTons1__sampleType(soap, tag ? tag : "ns1:sampleType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sampleType **SOAP_FMAC4 soap_get_PointerTons1__sampleType(struct soap *soap, ns1__sampleType **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__sampleType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigationParameter(struct soap *soap,
                                                                               ns1__investigationParameter *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__investigationParameter))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigationParameter(struct soap *soap, const char *tag, int id,
                                                                        ns1__investigationParameter *const *a,
                                                                        const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__investigationParameter);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigationParameter **SOAP_FMAC4 soap_in_PointerTons1__investigationParameter(
    struct soap *soap, const char *tag, ns1__investigationParameter **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__investigationParameter **)soap_malloc(soap, sizeof(ns1__investigationParameter *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__investigationParameter *)soap_instantiate_ns1__investigationParameter(soap, -1, soap->type,
                                                                                           soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__investigationParameter **p = (ns1__investigationParameter **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationParameter, sizeof(ns1__investigationParameter),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigationParameter(struct soap *soap,
                                                                        ns1__investigationParameter *const *a,
                                                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__investigationParameter);
  if (soap_out_PointerTons1__investigationParameter(soap, tag ? tag : "ns1:investigationParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigationParameter **SOAP_FMAC4 soap_get_PointerTons1__investigationParameter(
    struct soap *soap, ns1__investigationParameter **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__investigationParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTons1__investigationInstrument(struct soap *soap, ns1__investigationInstrument *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__investigationInstrument))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigationInstrument(struct soap *soap, const char *tag, int id,
                                                                         ns1__investigationInstrument *const *a,
                                                                         const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__investigationInstrument);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigationInstrument **SOAP_FMAC4 soap_in_PointerTons1__investigationInstrument(
    struct soap *soap, const char *tag, ns1__investigationInstrument **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__investigationInstrument **)soap_malloc(soap, sizeof(ns1__investigationInstrument *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__investigationInstrument *)soap_instantiate_ns1__investigationInstrument(soap, -1, soap->type,
                                                                                             soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__investigationInstrument **p = (ns1__investigationInstrument **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationInstrument,
        sizeof(ns1__investigationInstrument), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigationInstrument(struct soap *soap,
                                                                         ns1__investigationInstrument *const *a,
                                                                         const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__investigationInstrument);
  if (soap_out_PointerTons1__investigationInstrument(soap, tag ? tag : "ns1:investigationInstrument", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigationInstrument **SOAP_FMAC4 soap_get_PointerTons1__investigationInstrument(
    struct soap *soap, ns1__investigationInstrument **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__investigationInstrument(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__accessType(struct soap *soap, enum ns1__accessType *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__accessType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__accessType(struct soap *soap, const char *tag, int id,
                                                            enum ns1__accessType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__accessType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__accessType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__accessType **SOAP_FMAC4 soap_in_PointerTons1__accessType(struct soap *soap, const char *tag,
                                                                              enum ns1__accessType **a,
                                                                              const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (enum ns1__accessType **)soap_malloc(soap, sizeof(enum ns1__accessType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__accessType(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (enum ns1__accessType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__accessType,
                                                sizeof(enum ns1__accessType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__accessType(struct soap *soap, enum ns1__accessType *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__accessType);
  if (soap_out_PointerTons1__accessType(soap, tag ? tag : "ns1:accessType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__accessType **SOAP_FMAC4 soap_get_PointerTons1__accessType(struct soap *soap,
                                                                               enum ns1__accessType **p,
                                                                               const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__accessType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_xsd__anyType))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id,
                                                         xsd__anyType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_xsd__anyType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType **SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a,
                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    xsd__anyType **p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__anyType,
                                                       sizeof(xsd__anyType), 0);
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__boolean,
                                          sizeof(xsd__boolean), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__dateTime,
                                          sizeof(xsd__dateTime), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__double,
                                          sizeof(xsd__double), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__int, sizeof(xsd__int), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__long, sizeof(xsd__long),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_xsd__string,
                                          sizeof(xsd__string), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__icatExceptionType_,
                                          sizeof(ns1__icatExceptionType_), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__studyStatus_,
                                          sizeof(ns1__studyStatus_), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameterValueType_,
                                          sizeof(ns1__parameterValueType_), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__relType_,
                                          sizeof(ns1__relType_), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__accessType_,
                                          sizeof(ns1__accessType_), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneClear,
                                          sizeof(ns1__luceneClear), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneClearResponse,
                                          sizeof(ns1__luceneClearResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__IcatException,
                                          sizeof(ns1__IcatException), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createMany,
                                          sizeof(ns1__createMany), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityBaseBean,
                                          sizeof(ns1__entityBaseBean), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createManyResponse,
                                          sizeof(ns1__createManyResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__create,
                                          sizeof(ns1__create), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__createResponse,
                                          sizeof(ns1__createResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getProperties,
                                          sizeof(ns1__getProperties), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getPropertiesResponse,
                                          sizeof(ns1__getPropertiesResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneSearch,
                                          sizeof(ns1__luceneSearch), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneSearchResponse,
                                          sizeof(ns1__luceneSearchResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__lucenePopulate,
                                          sizeof(ns1__lucenePopulate), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__lucenePopulateResponse,
                                          sizeof(ns1__lucenePopulateResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__get, sizeof(ns1__get), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getResponse,
                                          sizeof(ns1__getResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityNames,
                                          sizeof(ns1__getEntityNames), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityNamesResponse,
                                          sizeof(ns1__getEntityNamesResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getApiVersion,
                                          sizeof(ns1__getApiVersion), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getApiVersionResponse,
                                          sizeof(ns1__getApiVersionResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneGetPopulating,
                                          sizeof(ns1__luceneGetPopulating), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a,
                                          SOAP_TYPE_ICat4_ns1__luceneGetPopulatingResponse,
                                          sizeof(ns1__luceneGetPopulatingResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__update,
                                          sizeof(ns1__update), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__updateResponse,
                                          sizeof(ns1__updateResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteMany,
                                          sizeof(ns1__deleteMany), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteManyResponse,
                                          sizeof(ns1__deleteManyResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getUserName,
                                          sizeof(ns1__getUserName), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getUserNameResponse,
                                          sizeof(ns1__getUserNameResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__refresh,
                                          sizeof(ns1__refresh), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__refreshResponse,
                                          sizeof(ns1__refreshResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__login, sizeof(ns1__login),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__loginResponse,
                                          sizeof(ns1__loginResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dummy, sizeof(ns1__dummy),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dummyResponse,
                                          sizeof(ns1__dummyResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityInfo,
                                          sizeof(ns1__getEntityInfo), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getEntityInfoResponse,
                                          sizeof(ns1__getEntityInfoResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityInfo,
                                          sizeof(ns1__entityInfo), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__constraint,
                                          sizeof(ns1__constraint), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityField,
                                          sizeof(ns1__entityField), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneCommit,
                                          sizeof(ns1__luceneCommit), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__luceneCommitResponse,
                                          sizeof(ns1__luceneCommitResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchText,
                                          sizeof(ns1__searchText), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchTextResponse,
                                          sizeof(ns1__searchTextResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__delete,
                                          sizeof(ns1__delete), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__deleteResponse,
                                          sizeof(ns1__deleteResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__isAccessAllowed,
                                          sizeof(ns1__isAccessAllowed), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__isAccessAllowedResponse,
                                          sizeof(ns1__isAccessAllowedResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__search,
                                          sizeof(ns1__search), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__searchResponse,
                                          sizeof(ns1__searchResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__logout,
                                          sizeof(ns1__logout), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__logoutResponse,
                                          sizeof(ns1__logoutResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__getRemainingMinutes,
                                          sizeof(ns1__getRemainingMinutes), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a,
                                          SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse,
                                          sizeof(ns1__getRemainingMinutesResponse), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafile,
                                          sizeof(ns1__datafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile,
                                          sizeof(ns1__dataCollectionDatafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollection,
                                          sizeof(ns1__dataCollection), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionDataset,
                                          sizeof(ns1__dataCollectionDataset), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataset,
                                          sizeof(ns1__dataset), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigation,
                                          sizeof(ns1__investigation), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facility,
                                          sizeof(ns1__facility), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__application,
                                          sizeof(ns1__application), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__job, sizeof(ns1__job), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileFormat,
                                          sizeof(ns1__datafileFormat), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetType,
                                          sizeof(ns1__datasetType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facilityCycle,
                                          sizeof(ns1__facilityCycle), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrument,
                                          sizeof(ns1__instrument), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrumentScientist,
                                          sizeof(ns1__instrumentScientist), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__user, sizeof(ns1__user),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationUser,
                                          sizeof(ns1__investigationUser), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__study, sizeof(ns1__study),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__studyInvestigation,
                                          sizeof(ns1__studyInvestigation), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__userGroup,
                                          sizeof(ns1__userGroup), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__grouping,
                                          sizeof(ns1__grouping), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__rule, sizeof(ns1__rule),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationInstrument,
                                          sizeof(ns1__investigationInstrument), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationType,
                                          sizeof(ns1__investigationType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameterType,
                                          sizeof(ns1__parameterType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameter,
                                          sizeof(ns1__parameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__permissibleStringValue,
                                          sizeof(ns1__permissibleStringValue), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sample,
                                          sizeof(ns1__sample), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleType,
                                          sizeof(ns1__sampleType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__keyword,
                                          sizeof(ns1__keyword), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publication,
                                          sizeof(ns1__publication), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__shift, sizeof(ns1__shift),
                                          0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__relatedDatafile,
                                          sizeof(ns1__relatedDatafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__log, sizeof(ns1__log), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publicStep,
                                          sizeof(ns1__publicStep), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionParameter,
                                          sizeof(ns1__dataCollectionParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileParameter,
                                          sizeof(ns1__datafileParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetParameter,
                                          sizeof(ns1__datasetParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationParameter,
                                          sizeof(ns1__investigationParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleParameter,
                                          sizeof(ns1__sampleParameter), 0);
    }
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const *a, const char *tag,
                                                         const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerToxsd__anyType);
  if (soap_out_PointerToxsd__anyType(soap, tag ? tag : "xsd:anyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__anyType **SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const *a,
                                                const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_int);
  if (id < 0)
    return soap->error;
  return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int **SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_int(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (int **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_int, sizeof(int), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerToint);
  if (soap_out_PointerToint(soap, tag ? tag : "int", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int **SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relType(struct soap *soap, enum ns1__relType *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__relType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relType(struct soap *soap, const char *tag, int id,
                                                         enum ns1__relType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__relType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__relType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__relType **SOAP_FMAC4 soap_in_PointerTons1__relType(struct soap *soap, const char *tag,
                                                                        enum ns1__relType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (enum ns1__relType **)soap_malloc(soap, sizeof(enum ns1__relType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__relType(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (enum ns1__relType **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__relType,
                                             sizeof(enum ns1__relType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relType(struct soap *soap, enum ns1__relType *const *a,
                                                         const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__relType);
  if (soap_out_PointerTons1__relType(soap, tag ? tag : "ns1:relType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__relType **SOAP_FMAC4 soap_get_PointerTons1__relType(struct soap *soap, enum ns1__relType **p,
                                                                         const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__relType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entityField(struct soap *soap, ns1__entityField *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__entityField))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entityField(struct soap *soap, const char *tag, int id,
                                                             ns1__entityField *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__entityField);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__entityField **SOAP_FMAC4 soap_in_PointerTons1__entityField(struct soap *soap, const char *tag,
                                                                           ns1__entityField **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__entityField **)soap_malloc(soap, sizeof(ns1__entityField *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__entityField *)soap_instantiate_ns1__entityField(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__entityField **p = (ns1__entityField **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityField, sizeof(ns1__entityField), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entityField(struct soap *soap, ns1__entityField *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__entityField);
  if (soap_out_PointerTons1__entityField(soap, tag ? tag : "ns1:entityField", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__entityField **SOAP_FMAC4 soap_get_PointerTons1__entityField(struct soap *soap, ns1__entityField **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__entityField(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__constraint(struct soap *soap, ns1__constraint *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__constraint))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__constraint(struct soap *soap, const char *tag, int id,
                                                            ns1__constraint *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__constraint);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__constraint **SOAP_FMAC4 soap_in_PointerTons1__constraint(struct soap *soap, const char *tag,
                                                                         ns1__constraint **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__constraint **)soap_malloc(soap, sizeof(ns1__constraint *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__constraint *)soap_instantiate_ns1__constraint(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__constraint **p = (ns1__constraint **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__constraint, sizeof(ns1__constraint), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__constraint(struct soap *soap, ns1__constraint *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__constraint);
  if (soap_out_PointerTons1__constraint(soap, tag ? tag : "ns1:constraint", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__constraint **SOAP_FMAC4 soap_get_PointerTons1__constraint(struct soap *soap, ns1__constraint **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__constraint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entityInfo(struct soap *soap, ns1__entityInfo *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__entityInfo))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entityInfo(struct soap *soap, const char *tag, int id,
                                                            ns1__entityInfo *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__entityInfo);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__entityInfo **SOAP_FMAC4 soap_in_PointerTons1__entityInfo(struct soap *soap, const char *tag,
                                                                         ns1__entityInfo **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__entityInfo **)soap_malloc(soap, sizeof(ns1__entityInfo *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__entityInfo *)soap_instantiate_ns1__entityInfo(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__entityInfo **p = (ns1__entityInfo **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityInfo, sizeof(ns1__entityInfo), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entityInfo(struct soap *soap, ns1__entityInfo *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__entityInfo);
  if (soap_out_PointerTons1__entityInfo(soap, tag ? tag : "ns1:entityInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__entityInfo **SOAP_FMAC4 soap_get_PointerTons1__entityInfo(struct soap *soap, ns1__entityInfo **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__entityInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__publicStep(struct soap *soap, ns1__publicStep *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__publicStep))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__publicStep(struct soap *soap, const char *tag, int id,
                                                            ns1__publicStep *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__publicStep);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__publicStep **SOAP_FMAC4 soap_in_PointerTons1__publicStep(struct soap *soap, const char *tag,
                                                                         ns1__publicStep **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__publicStep **)soap_malloc(soap, sizeof(ns1__publicStep *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__publicStep *)soap_instantiate_ns1__publicStep(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__publicStep **p = (ns1__publicStep **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publicStep, sizeof(ns1__publicStep), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__publicStep(struct soap *soap, ns1__publicStep *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__publicStep);
  if (soap_out_PointerTons1__publicStep(soap, tag ? tag : "ns1:publicStep", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__publicStep **SOAP_FMAC4 soap_get_PointerTons1__publicStep(struct soap *soap, ns1__publicStep **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__publicStep(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__log(struct soap *soap, ns1__log *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__log))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__log(struct soap *soap, const char *tag, int id, ns1__log *const *a,
                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__log);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__log **SOAP_FMAC4 soap_in_PointerTons1__log(struct soap *soap, const char *tag, ns1__log **a,
                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__log **)soap_malloc(soap, sizeof(ns1__log *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__log *)soap_instantiate_ns1__log(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__log **p =
        (ns1__log **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__log, sizeof(ns1__log), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__log(struct soap *soap, ns1__log *const *a, const char *tag,
                                                     const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__log);
  if (soap_out_PointerTons1__log(soap, tag ? tag : "ns1:log", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__log **SOAP_FMAC4 soap_get_PointerTons1__log(struct soap *soap, ns1__log **p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_PointerTons1__log(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userGroup(struct soap *soap, ns1__userGroup *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__userGroup))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userGroup(struct soap *soap, const char *tag, int id,
                                                           ns1__userGroup *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__userGroup);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__userGroup **SOAP_FMAC4 soap_in_PointerTons1__userGroup(struct soap *soap, const char *tag,
                                                                       ns1__userGroup **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__userGroup **)soap_malloc(soap, sizeof(ns1__userGroup *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__userGroup *)soap_instantiate_ns1__userGroup(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__userGroup **p = (ns1__userGroup **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__userGroup,
                                                           sizeof(ns1__userGroup), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userGroup(struct soap *soap, ns1__userGroup *const *a, const char *tag,
                                                           const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__userGroup);
  if (soap_out_PointerTons1__userGroup(soap, tag ? tag : "ns1:userGroup", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userGroup **SOAP_FMAC4 soap_get_PointerTons1__userGroup(struct soap *soap, ns1__userGroup **p,
                                                                        const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__userGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__grouping(struct soap *soap, ns1__grouping *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__grouping))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__grouping(struct soap *soap, const char *tag, int id,
                                                          ns1__grouping *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__grouping);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__grouping **SOAP_FMAC4 soap_in_PointerTons1__grouping(struct soap *soap, const char *tag,
                                                                     ns1__grouping **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__grouping **)soap_malloc(soap, sizeof(ns1__grouping *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__grouping *)soap_instantiate_ns1__grouping(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__grouping **p = (ns1__grouping **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__grouping,
                                                         sizeof(ns1__grouping), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__grouping(struct soap *soap, ns1__grouping *const *a, const char *tag,
                                                          const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__grouping);
  if (soap_out_PointerTons1__grouping(soap, tag ? tag : "ns1:grouping", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__grouping **SOAP_FMAC4 soap_get_PointerTons1__grouping(struct soap *soap, ns1__grouping **p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__grouping(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dataCollectionDatafile(struct soap *soap,
                                                                               ns1__dataCollectionDatafile *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataCollectionDatafile(struct soap *soap, const char *tag, int id,
                                                                        ns1__dataCollectionDatafile *const *a,
                                                                        const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataCollectionDatafile **SOAP_FMAC4 soap_in_PointerTons1__dataCollectionDatafile(
    struct soap *soap, const char *tag, ns1__dataCollectionDatafile **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dataCollectionDatafile **)soap_malloc(soap, sizeof(ns1__dataCollectionDatafile *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dataCollectionDatafile *)soap_instantiate_ns1__dataCollectionDatafile(soap, -1, soap->type,
                                                                                           soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dataCollectionDatafile **p = (ns1__dataCollectionDatafile **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionDatafile, sizeof(ns1__dataCollectionDatafile),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataCollectionDatafile(struct soap *soap,
                                                                        ns1__dataCollectionDatafile *const *a,
                                                                        const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dataCollectionDatafile);
  if (soap_out_PointerTons1__dataCollectionDatafile(soap, tag ? tag : "ns1:dataCollectionDatafile", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataCollectionDatafile **SOAP_FMAC4 soap_get_PointerTons1__dataCollectionDatafile(
    struct soap *soap, ns1__dataCollectionDatafile **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__dataCollectionDatafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dataCollectionDataset(struct soap *soap,
                                                                              ns1__dataCollectionDataset *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dataCollectionDataset))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataCollectionDataset(struct soap *soap, const char *tag, int id,
                                                                       ns1__dataCollectionDataset *const *a,
                                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dataCollectionDataset);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataCollectionDataset **SOAP_FMAC4 soap_in_PointerTons1__dataCollectionDataset(
    struct soap *soap, const char *tag, ns1__dataCollectionDataset **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dataCollectionDataset **)soap_malloc(soap, sizeof(ns1__dataCollectionDataset *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dataCollectionDataset *)soap_instantiate_ns1__dataCollectionDataset(soap, -1, soap->type,
                                                                                         soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dataCollectionDataset **p = (ns1__dataCollectionDataset **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionDataset, sizeof(ns1__dataCollectionDataset),
        0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataCollectionDataset(struct soap *soap,
                                                                       ns1__dataCollectionDataset *const *a,
                                                                       const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dataCollectionDataset);
  if (soap_out_PointerTons1__dataCollectionDataset(soap, tag ? tag : "ns1:dataCollectionDataset", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataCollectionDataset **SOAP_FMAC4 soap_get_PointerTons1__dataCollectionDataset(
    struct soap *soap, ns1__dataCollectionDataset **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__dataCollectionDataset(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTons1__dataCollectionParameter(struct soap *soap, ns1__dataCollectionParameter *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dataCollectionParameter))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataCollectionParameter(struct soap *soap, const char *tag, int id,
                                                                         ns1__dataCollectionParameter *const *a,
                                                                         const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dataCollectionParameter);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataCollectionParameter **SOAP_FMAC4 soap_in_PointerTons1__dataCollectionParameter(
    struct soap *soap, const char *tag, ns1__dataCollectionParameter **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dataCollectionParameter **)soap_malloc(soap, sizeof(ns1__dataCollectionParameter *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dataCollectionParameter *)soap_instantiate_ns1__dataCollectionParameter(soap, -1, soap->type,
                                                                                             soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dataCollectionParameter **p = (ns1__dataCollectionParameter **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollectionParameter,
        sizeof(ns1__dataCollectionParameter), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataCollectionParameter(struct soap *soap,
                                                                         ns1__dataCollectionParameter *const *a,
                                                                         const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dataCollectionParameter);
  if (soap_out_PointerTons1__dataCollectionParameter(soap, tag ? tag : "ns1:dataCollectionParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataCollectionParameter **SOAP_FMAC4 soap_get_PointerTons1__dataCollectionParameter(
    struct soap *soap, ns1__dataCollectionParameter **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__dataCollectionParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dataCollection(struct soap *soap,
                                                                       ns1__dataCollection *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dataCollection))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataCollection(struct soap *soap, const char *tag, int id,
                                                                ns1__dataCollection *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dataCollection);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataCollection **SOAP_FMAC4 soap_in_PointerTons1__dataCollection(struct soap *soap, const char *tag,
                                                                                 ns1__dataCollection **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dataCollection **)soap_malloc(soap, sizeof(ns1__dataCollection *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dataCollection *)soap_instantiate_ns1__dataCollection(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dataCollection **p = (ns1__dataCollection **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollection, sizeof(ns1__dataCollection), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataCollection(struct soap *soap, ns1__dataCollection *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dataCollection);
  if (soap_out_PointerTons1__dataCollection(soap, tag ? tag : "ns1:dataCollection", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataCollection **SOAP_FMAC4 soap_get_PointerTons1__dataCollection(struct soap *soap,
                                                                                  ns1__dataCollection **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__dataCollection(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__job(struct soap *soap, ns1__job *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__job))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__job(struct soap *soap, const char *tag, int id, ns1__job *const *a,
                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__job);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__job **SOAP_FMAC4 soap_in_PointerTons1__job(struct soap *soap, const char *tag, ns1__job **a,
                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__job **)soap_malloc(soap, sizeof(ns1__job *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__job *)soap_instantiate_ns1__job(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__job **p =
        (ns1__job **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__job, sizeof(ns1__job), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__job(struct soap *soap, ns1__job *const *a, const char *tag,
                                                     const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__job);
  if (soap_out_PointerTons1__job(soap, tag ? tag : "ns1:job", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__job **SOAP_FMAC4 soap_get_PointerTons1__job(struct soap *soap, ns1__job **p, const char *tag,
                                                            const char *type) {
  if ((p = soap_in_PointerTons1__job(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__application(struct soap *soap, ns1__application *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__application))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__application(struct soap *soap, const char *tag, int id,
                                                             ns1__application *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__application);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__application **SOAP_FMAC4 soap_in_PointerTons1__application(struct soap *soap, const char *tag,
                                                                           ns1__application **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__application **)soap_malloc(soap, sizeof(ns1__application *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__application *)soap_instantiate_ns1__application(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__application **p = (ns1__application **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__application, sizeof(ns1__application), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__application(struct soap *soap, ns1__application *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__application);
  if (soap_out_PointerTons1__application(soap, tag ? tag : "ns1:application", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__application **SOAP_FMAC4 soap_get_PointerTons1__application(struct soap *soap, ns1__application **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__application(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__studyStatus(struct soap *soap,
                                                                    enum ns1__studyStatus *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__studyStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__studyStatus(struct soap *soap, const char *tag, int id,
                                                             enum ns1__studyStatus *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__studyStatus);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__studyStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__studyStatus **SOAP_FMAC4 soap_in_PointerTons1__studyStatus(struct soap *soap, const char *tag,
                                                                                enum ns1__studyStatus **a,
                                                                                const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (enum ns1__studyStatus **)soap_malloc(soap, sizeof(enum ns1__studyStatus *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__studyStatus(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (enum ns1__studyStatus **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__studyStatus,
                                                 sizeof(enum ns1__studyStatus), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__studyStatus(struct soap *soap, enum ns1__studyStatus *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__studyStatus);
  if (soap_out_PointerTons1__studyStatus(soap, tag ? tag : "ns1:studyStatus", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__studyStatus **SOAP_FMAC4 soap_get_PointerTons1__studyStatus(struct soap *soap,
                                                                                 enum ns1__studyStatus **p,
                                                                                 const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__studyStatus(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__studyInvestigation(struct soap *soap,
                                                                           ns1__studyInvestigation *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__studyInvestigation))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__studyInvestigation(struct soap *soap, const char *tag, int id,
                                                                    ns1__studyInvestigation *const *a,
                                                                    const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__studyInvestigation);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__studyInvestigation **SOAP_FMAC4 soap_in_PointerTons1__studyInvestigation(struct soap *soap,
                                                                                         const char *tag,
                                                                                         ns1__studyInvestigation **a,
                                                                                         const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__studyInvestigation **)soap_malloc(soap, sizeof(ns1__studyInvestigation *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__studyInvestigation *)soap_instantiate_ns1__studyInvestigation(soap, -1, soap->type,
                                                                                   soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__studyInvestigation **p = (ns1__studyInvestigation **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__studyInvestigation, sizeof(ns1__studyInvestigation), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__studyInvestigation(struct soap *soap,
                                                                    ns1__studyInvestigation *const *a, const char *tag,
                                                                    const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__studyInvestigation);
  if (soap_out_PointerTons1__studyInvestigation(soap, tag ? tag : "ns1:studyInvestigation", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__studyInvestigation **SOAP_FMAC4 soap_get_PointerTons1__studyInvestigation(struct soap *soap,
                                                                                          ns1__studyInvestigation **p,
                                                                                          const char *tag,
                                                                                          const char *type) {
  if ((p = soap_in_PointerTons1__studyInvestigation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__study(struct soap *soap, ns1__study *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__study))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__study(struct soap *soap, const char *tag, int id, ns1__study *const *a,
                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__study);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__study **SOAP_FMAC4 soap_in_PointerTons1__study(struct soap *soap, const char *tag, ns1__study **a,
                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__study **)soap_malloc(soap, sizeof(ns1__study *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__study *)soap_instantiate_ns1__study(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__study **p =
        (ns1__study **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__study, sizeof(ns1__study), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__study(struct soap *soap, ns1__study *const *a, const char *tag,
                                                       const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__study);
  if (soap_out_PointerTons1__study(soap, tag ? tag : "ns1:study", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__study **SOAP_FMAC4 soap_get_PointerTons1__study(struct soap *soap, ns1__study **p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_PointerTons1__study(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__shift(struct soap *soap, ns1__shift *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__shift))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__shift(struct soap *soap, const char *tag, int id, ns1__shift *const *a,
                                                       const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__shift);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__shift **SOAP_FMAC4 soap_in_PointerTons1__shift(struct soap *soap, const char *tag, ns1__shift **a,
                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__shift **)soap_malloc(soap, sizeof(ns1__shift *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__shift *)soap_instantiate_ns1__shift(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__shift **p =
        (ns1__shift **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__shift, sizeof(ns1__shift), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__shift(struct soap *soap, ns1__shift *const *a, const char *tag,
                                                       const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__shift);
  if (soap_out_PointerTons1__shift(soap, tag ? tag : "ns1:shift", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__shift **SOAP_FMAC4 soap_get_PointerTons1__shift(struct soap *soap, ns1__shift **p, const char *tag,
                                                                const char *type) {
  if ((p = soap_in_PointerTons1__shift(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sampleParameter(struct soap *soap,
                                                                        ns1__sampleParameter *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__sampleParameter))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sampleParameter(struct soap *soap, const char *tag, int id,
                                                                 ns1__sampleParameter *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__sampleParameter);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sampleParameter **SOAP_FMAC4 soap_in_PointerTons1__sampleParameter(struct soap *soap, const char *tag,
                                                                                   ns1__sampleParameter **a,
                                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__sampleParameter **)soap_malloc(soap, sizeof(ns1__sampleParameter *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__sampleParameter *)soap_instantiate_ns1__sampleParameter(soap, -1, soap->type, soap->arrayType,
                                                                             nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__sampleParameter **p = (ns1__sampleParameter **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleParameter, sizeof(ns1__sampleParameter), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sampleParameter(struct soap *soap, ns1__sampleParameter *const *a,
                                                                 const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__sampleParameter);
  if (soap_out_PointerTons1__sampleParameter(soap, tag ? tag : "ns1:sampleParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sampleParameter **SOAP_FMAC4 soap_get_PointerTons1__sampleParameter(struct soap *soap,
                                                                                    ns1__sampleParameter **p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__sampleParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sample(struct soap *soap, ns1__sample *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__sample))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sample(struct soap *soap, const char *tag, int id,
                                                        ns1__sample *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__sample);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sample **SOAP_FMAC4 soap_in_PointerTons1__sample(struct soap *soap, const char *tag, ns1__sample **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__sample **)soap_malloc(soap, sizeof(ns1__sample *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__sample *)soap_instantiate_ns1__sample(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__sample **p = (ns1__sample **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sample,
                                                     sizeof(ns1__sample), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sample(struct soap *soap, ns1__sample *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__sample);
  if (soap_out_PointerTons1__sample(soap, tag ? tag : "ns1:sample", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sample **SOAP_FMAC4 soap_get_PointerTons1__sample(struct soap *soap, ns1__sample **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTons1__sample(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relatedDatafile(struct soap *soap,
                                                                        ns1__relatedDatafile *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__relatedDatafile))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relatedDatafile(struct soap *soap, const char *tag, int id,
                                                                 ns1__relatedDatafile *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__relatedDatafile);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__relatedDatafile **SOAP_FMAC4 soap_in_PointerTons1__relatedDatafile(struct soap *soap, const char *tag,
                                                                                   ns1__relatedDatafile **a,
                                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__relatedDatafile **)soap_malloc(soap, sizeof(ns1__relatedDatafile *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__relatedDatafile *)soap_instantiate_ns1__relatedDatafile(soap, -1, soap->type, soap->arrayType,
                                                                             nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__relatedDatafile **p = (ns1__relatedDatafile **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__relatedDatafile, sizeof(ns1__relatedDatafile), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relatedDatafile(struct soap *soap, ns1__relatedDatafile *const *a,
                                                                 const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__relatedDatafile);
  if (soap_out_PointerTons1__relatedDatafile(soap, tag ? tag : "ns1:relatedDatafile", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__relatedDatafile **SOAP_FMAC4 soap_get_PointerTons1__relatedDatafile(struct soap *soap,
                                                                                    ns1__relatedDatafile **p,
                                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__relatedDatafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__publication(struct soap *soap, ns1__publication *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__publication))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__publication(struct soap *soap, const char *tag, int id,
                                                             ns1__publication *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__publication);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__publication **SOAP_FMAC4 soap_in_PointerTons1__publication(struct soap *soap, const char *tag,
                                                                           ns1__publication **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__publication **)soap_malloc(soap, sizeof(ns1__publication *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__publication *)soap_instantiate_ns1__publication(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__publication **p = (ns1__publication **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publication, sizeof(ns1__publication), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__publication(struct soap *soap, ns1__publication *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__publication);
  if (soap_out_PointerTons1__publication(soap, tag ? tag : "ns1:publication", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__publication **SOAP_FMAC4 soap_get_PointerTons1__publication(struct soap *soap, ns1__publication **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__publication(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__parameterType(struct soap *soap, ns1__parameterType *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__parameterType))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__parameterType(struct soap *soap, const char *tag, int id,
                                                               ns1__parameterType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__parameterType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__parameterType **SOAP_FMAC4 soap_in_PointerTons1__parameterType(struct soap *soap, const char *tag,
                                                                               ns1__parameterType **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__parameterType **)soap_malloc(soap, sizeof(ns1__parameterType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__parameterType *)soap_instantiate_ns1__parameterType(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__parameterType **p = (ns1__parameterType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameterType, sizeof(ns1__parameterType), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__parameterType(struct soap *soap, ns1__parameterType *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__parameterType);
  if (soap_out_PointerTons1__parameterType(soap, tag ? tag : "ns1:parameterType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__parameterType **SOAP_FMAC4 soap_get_PointerTons1__parameterType(struct soap *soap,
                                                                                ns1__parameterType **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__parameterType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__keyword(struct soap *soap, ns1__keyword *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__keyword))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__keyword(struct soap *soap, const char *tag, int id,
                                                         ns1__keyword *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__keyword);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__keyword **SOAP_FMAC4 soap_in_PointerTons1__keyword(struct soap *soap, const char *tag, ns1__keyword **a,
                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__keyword **)soap_malloc(soap, sizeof(ns1__keyword *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__keyword *)soap_instantiate_ns1__keyword(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__keyword **p = (ns1__keyword **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__keyword,
                                                       sizeof(ns1__keyword), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__keyword(struct soap *soap, ns1__keyword *const *a, const char *tag,
                                                         const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__keyword);
  if (soap_out_PointerTons1__keyword(soap, tag ? tag : "ns1:keyword", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__keyword **SOAP_FMAC4 soap_get_PointerTons1__keyword(struct soap *soap, ns1__keyword **p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__keyword(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigationUser(struct soap *soap,
                                                                          ns1__investigationUser *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__investigationUser))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigationUser(struct soap *soap, const char *tag, int id,
                                                                   ns1__investigationUser *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__investigationUser);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigationUser **SOAP_FMAC4 soap_in_PointerTons1__investigationUser(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__investigationUser **a,
                                                                                       const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__investigationUser **)soap_malloc(soap, sizeof(ns1__investigationUser *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__investigationUser *)soap_instantiate_ns1__investigationUser(soap, -1, soap->type, soap->arrayType,
                                                                                 nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__investigationUser **p = (ns1__investigationUser **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationUser, sizeof(ns1__investigationUser), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigationUser(struct soap *soap, ns1__investigationUser *const *a,
                                                                   const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__investigationUser);
  if (soap_out_PointerTons1__investigationUser(soap, tag ? tag : "ns1:investigationUser", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigationUser **SOAP_FMAC4 soap_get_PointerTons1__investigationUser(struct soap *soap,
                                                                                        ns1__investigationUser **p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_PointerTons1__investigationUser(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigationType(struct soap *soap,
                                                                          ns1__investigationType *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__investigationType))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigationType(struct soap *soap, const char *tag, int id,
                                                                   ns1__investigationType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__investigationType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigationType **SOAP_FMAC4 soap_in_PointerTons1__investigationType(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__investigationType **a,
                                                                                       const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__investigationType **)soap_malloc(soap, sizeof(ns1__investigationType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__investigationType *)soap_instantiate_ns1__investigationType(soap, -1, soap->type, soap->arrayType,
                                                                                 nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__investigationType **p = (ns1__investigationType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationType, sizeof(ns1__investigationType), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigationType(struct soap *soap, ns1__investigationType *const *a,
                                                                   const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__investigationType);
  if (soap_out_PointerTons1__investigationType(soap, tag ? tag : "ns1:investigationType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigationType **SOAP_FMAC4 soap_get_PointerTons1__investigationType(struct soap *soap,
                                                                                        ns1__investigationType **p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_PointerTons1__investigationType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__investigation(struct soap *soap, ns1__investigation *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__investigation))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__investigation(struct soap *soap, const char *tag, int id,
                                                               ns1__investigation *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__investigation);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__investigation **SOAP_FMAC4 soap_in_PointerTons1__investigation(struct soap *soap, const char *tag,
                                                                               ns1__investigation **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__investigation **)soap_malloc(soap, sizeof(ns1__investigation *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__investigation *)soap_instantiate_ns1__investigation(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__investigation **p = (ns1__investigation **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigation, sizeof(ns1__investigation), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__investigation(struct soap *soap, ns1__investigation *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__investigation);
  if (soap_out_PointerTons1__investigation(soap, tag ? tag : "ns1:investigation", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__investigation **SOAP_FMAC4 soap_get_PointerTons1__investigation(struct soap *soap,
                                                                                ns1__investigation **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__investigation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__instrument(struct soap *soap, ns1__instrument *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__instrument))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__instrument(struct soap *soap, const char *tag, int id,
                                                            ns1__instrument *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__instrument);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__instrument **SOAP_FMAC4 soap_in_PointerTons1__instrument(struct soap *soap, const char *tag,
                                                                         ns1__instrument **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__instrument **)soap_malloc(soap, sizeof(ns1__instrument *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__instrument *)soap_instantiate_ns1__instrument(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__instrument **p = (ns1__instrument **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrument, sizeof(ns1__instrument), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__instrument(struct soap *soap, ns1__instrument *const *a,
                                                            const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__instrument);
  if (soap_out_PointerTons1__instrument(soap, tag ? tag : "ns1:instrument", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__instrument **SOAP_FMAC4 soap_get_PointerTons1__instrument(struct soap *soap, ns1__instrument **p,
                                                                          const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__instrument(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user(struct soap *soap, ns1__user *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__user))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user(struct soap *soap, const char *tag, int id, ns1__user *const *a,
                                                      const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__user);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__user **SOAP_FMAC4 soap_in_PointerTons1__user(struct soap *soap, const char *tag, ns1__user **a,
                                                             const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__user **)soap_malloc(soap, sizeof(ns1__user *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__user *)soap_instantiate_ns1__user(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__user **p =
        (ns1__user **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__user, sizeof(ns1__user), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user(struct soap *soap, ns1__user *const *a, const char *tag,
                                                      const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__user);
  if (soap_out_PointerTons1__user(soap, tag ? tag : "ns1:user", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__user **SOAP_FMAC4 soap_get_PointerTons1__user(struct soap *soap, ns1__user **p, const char *tag,
                                                              const char *type) {
  if ((p = soap_in_PointerTons1__user(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__instrumentScientist(struct soap *soap,
                                                                            ns1__instrumentScientist *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__instrumentScientist))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__instrumentScientist(struct soap *soap, const char *tag, int id,
                                                                     ns1__instrumentScientist *const *a,
                                                                     const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__instrumentScientist);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__instrumentScientist **SOAP_FMAC4 soap_in_PointerTons1__instrumentScientist(struct soap *soap,
                                                                                           const char *tag,
                                                                                           ns1__instrumentScientist **a,
                                                                                           const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__instrumentScientist **)soap_malloc(soap, sizeof(ns1__instrumentScientist *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__instrumentScientist *)soap_instantiate_ns1__instrumentScientist(soap, -1, soap->type,
                                                                                     soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__instrumentScientist **p = (ns1__instrumentScientist **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrumentScientist, sizeof(ns1__instrumentScientist), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__instrumentScientist(struct soap *soap,
                                                                     ns1__instrumentScientist *const *a,
                                                                     const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__instrumentScientist);
  if (soap_out_PointerTons1__instrumentScientist(soap, tag ? tag : "ns1:instrumentScientist", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__instrumentScientist **SOAP_FMAC4 soap_get_PointerTons1__instrumentScientist(
    struct soap *soap, ns1__instrumentScientist **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__instrumentScientist(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__facilityCycle(struct soap *soap, ns1__facilityCycle *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__facilityCycle))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__facilityCycle(struct soap *soap, const char *tag, int id,
                                                               ns1__facilityCycle *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__facilityCycle);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__facilityCycle **SOAP_FMAC4 soap_in_PointerTons1__facilityCycle(struct soap *soap, const char *tag,
                                                                               ns1__facilityCycle **a,
                                                                               const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__facilityCycle **)soap_malloc(soap, sizeof(ns1__facilityCycle *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__facilityCycle *)soap_instantiate_ns1__facilityCycle(soap, -1, soap->type, soap->arrayType,
                                                                         nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__facilityCycle **p = (ns1__facilityCycle **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facilityCycle, sizeof(ns1__facilityCycle), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__facilityCycle(struct soap *soap, ns1__facilityCycle *const *a,
                                                               const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__facilityCycle);
  if (soap_out_PointerTons1__facilityCycle(soap, tag ? tag : "ns1:facilityCycle", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__facilityCycle **SOAP_FMAC4 soap_get_PointerTons1__facilityCycle(struct soap *soap,
                                                                                ns1__facilityCycle **p, const char *tag,
                                                                                const char *type) {
  if ((p = soap_in_PointerTons1__facilityCycle(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__facility(struct soap *soap, ns1__facility *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__facility))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__facility(struct soap *soap, const char *tag, int id,
                                                          ns1__facility *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__facility);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__facility **SOAP_FMAC4 soap_in_PointerTons1__facility(struct soap *soap, const char *tag,
                                                                     ns1__facility **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__facility **)soap_malloc(soap, sizeof(ns1__facility *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__facility *)soap_instantiate_ns1__facility(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__facility **p = (ns1__facility **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facility,
                                                         sizeof(ns1__facility), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__facility(struct soap *soap, ns1__facility *const *a, const char *tag,
                                                          const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__facility);
  if (soap_out_PointerTons1__facility(soap, tag ? tag : "ns1:facility", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__facility **SOAP_FMAC4 soap_get_PointerTons1__facility(struct soap *soap, ns1__facility **p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__facility(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datasetType(struct soap *soap, ns1__datasetType *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__datasetType))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datasetType(struct soap *soap, const char *tag, int id,
                                                             ns1__datasetType *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__datasetType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datasetType **SOAP_FMAC4 soap_in_PointerTons1__datasetType(struct soap *soap, const char *tag,
                                                                           ns1__datasetType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__datasetType **)soap_malloc(soap, sizeof(ns1__datasetType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__datasetType *)soap_instantiate_ns1__datasetType(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__datasetType **p = (ns1__datasetType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetType, sizeof(ns1__datasetType), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datasetType(struct soap *soap, ns1__datasetType *const *a,
                                                             const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__datasetType);
  if (soap_out_PointerTons1__datasetType(soap, tag ? tag : "ns1:datasetType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datasetType **SOAP_FMAC4 soap_get_PointerTons1__datasetType(struct soap *soap, ns1__datasetType **p,
                                                                            const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__datasetType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datasetParameter(struct soap *soap,
                                                                         ns1__datasetParameter *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__datasetParameter))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datasetParameter(struct soap *soap, const char *tag, int id,
                                                                  ns1__datasetParameter *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__datasetParameter);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datasetParameter **SOAP_FMAC4 soap_in_PointerTons1__datasetParameter(struct soap *soap, const char *tag,
                                                                                     ns1__datasetParameter **a,
                                                                                     const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__datasetParameter **)soap_malloc(soap, sizeof(ns1__datasetParameter *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__datasetParameter *)soap_instantiate_ns1__datasetParameter(soap, -1, soap->type, soap->arrayType,
                                                                               nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__datasetParameter **p = (ns1__datasetParameter **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetParameter, sizeof(ns1__datasetParameter), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datasetParameter(struct soap *soap, ns1__datasetParameter *const *a,
                                                                  const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__datasetParameter);
  if (soap_out_PointerTons1__datasetParameter(soap, tag ? tag : "ns1:datasetParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datasetParameter **SOAP_FMAC4 soap_get_PointerTons1__datasetParameter(struct soap *soap,
                                                                                      ns1__datasetParameter **p,
                                                                                      const char *tag,
                                                                                      const char *type) {
  if ((p = soap_in_PointerTons1__datasetParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dataset(struct soap *soap, ns1__dataset *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__dataset))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dataset(struct soap *soap, const char *tag, int id,
                                                         ns1__dataset *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__dataset);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dataset **SOAP_FMAC4 soap_in_PointerTons1__dataset(struct soap *soap, const char *tag, ns1__dataset **a,
                                                                   const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__dataset **)soap_malloc(soap, sizeof(ns1__dataset *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__dataset *)soap_instantiate_ns1__dataset(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__dataset **p = (ns1__dataset **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataset,
                                                       sizeof(ns1__dataset), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dataset(struct soap *soap, ns1__dataset *const *a, const char *tag,
                                                         const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__dataset);
  if (soap_out_PointerTons1__dataset(soap, tag ? tag : "ns1:dataset", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dataset **SOAP_FMAC4 soap_get_PointerTons1__dataset(struct soap *soap, ns1__dataset **p,
                                                                    const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__dataset(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileParameter(struct soap *soap,
                                                                          ns1__datafileParameter *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__datafileParameter))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileParameter(struct soap *soap, const char *tag, int id,
                                                                   ns1__datafileParameter *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__datafileParameter);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileParameter **SOAP_FMAC4 soap_in_PointerTons1__datafileParameter(struct soap *soap,
                                                                                       const char *tag,
                                                                                       ns1__datafileParameter **a,
                                                                                       const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__datafileParameter **)soap_malloc(soap, sizeof(ns1__datafileParameter *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__datafileParameter *)soap_instantiate_ns1__datafileParameter(soap, -1, soap->type, soap->arrayType,
                                                                                 nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__datafileParameter **p = (ns1__datafileParameter **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileParameter, sizeof(ns1__datafileParameter), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileParameter(struct soap *soap, ns1__datafileParameter *const *a,
                                                                   const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__datafileParameter);
  if (soap_out_PointerTons1__datafileParameter(soap, tag ? tag : "ns1:datafileParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileParameter **SOAP_FMAC4 soap_get_PointerTons1__datafileParameter(struct soap *soap,
                                                                                        ns1__datafileParameter **p,
                                                                                        const char *tag,
                                                                                        const char *type) {
  if ((p = soap_in_PointerTons1__datafileParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafileFormat(struct soap *soap,
                                                                       ns1__datafileFormat *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__datafileFormat))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafileFormat(struct soap *soap, const char *tag, int id,
                                                                ns1__datafileFormat *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__datafileFormat);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafileFormat **SOAP_FMAC4 soap_in_PointerTons1__datafileFormat(struct soap *soap, const char *tag,
                                                                                 ns1__datafileFormat **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__datafileFormat **)soap_malloc(soap, sizeof(ns1__datafileFormat *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__datafileFormat *)soap_instantiate_ns1__datafileFormat(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__datafileFormat **p = (ns1__datafileFormat **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileFormat, sizeof(ns1__datafileFormat), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafileFormat(struct soap *soap, ns1__datafileFormat *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__datafileFormat);
  if (soap_out_PointerTons1__datafileFormat(soap, tag ? tag : "ns1:datafileFormat", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafileFormat **SOAP_FMAC4 soap_get_PointerTons1__datafileFormat(struct soap *soap,
                                                                                  ns1__datafileFormat **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__datafileFormat(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__datafile(struct soap *soap, ns1__datafile *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__datafile))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__datafile(struct soap *soap, const char *tag, int id,
                                                          ns1__datafile *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__datafile);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__datafile **SOAP_FMAC4 soap_in_PointerTons1__datafile(struct soap *soap, const char *tag,
                                                                     ns1__datafile **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__datafile **)soap_malloc(soap, sizeof(ns1__datafile *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__datafile *)soap_instantiate_ns1__datafile(soap, -1, soap->type, soap->arrayType, nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__datafile **p = (ns1__datafile **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafile,
                                                         sizeof(ns1__datafile), 0);
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__datafile(struct soap *soap, ns1__datafile *const *a, const char *tag,
                                                          const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__datafile);
  if (soap_out_PointerTons1__datafile(soap, tag ? tag : "ns1:datafile", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__datafile **SOAP_FMAC4 soap_get_PointerTons1__datafile(struct soap *soap, ns1__datafile **p,
                                                                      const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__datafile(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, std::vector<_ns1__login_credentials_entry> *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry))
    soap_serialize_std__vectorTemplateOf_ns1__login_credentials_entry(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, const char *tag, int id, std::vector<_ns1__login_credentials_entry> *const *a,
    const char *type) {
  if (!*a)
    return soap_element_null(soap, tag, id, type);
  return soap_out_std__vectorTemplateOf_ns1__login_credentials_entry(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns1__login_credentials_entry> **SOAP_FMAC4
soap_in_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(struct soap *soap, const char *tag,
                                                                    std::vector<_ns1__login_credentials_entry> **a,
                                                                    const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  soap_revert(soap);
  if (!a) {
    if (!(a = (std::vector<_ns1__login_credentials_entry> **)soap_malloc(
              soap, sizeof(std::vector<_ns1__login_credentials_entry> *))))
      return nullptr;
    *a = nullptr;
  }
  if (!(*a = soap_in_std__vectorTemplateOf_ns1__login_credentials_entry(soap, tag, *a, type)))
    return nullptr;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, std::vector<_ns1__login_credentials_entry> *const *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag,
                      SOAP_TYPE_ICat4_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry);
  if (soap_out_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(soap, tag ? tag : "", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns1__login_credentials_entry> **SOAP_FMAC4
soap_get_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(struct soap *soap,
                                                                     std::vector<_ns1__login_credentials_entry> **p,
                                                                     const char *tag, const char *type) {
  if ((p = soap_in_PointerTostd__vectorTemplateOf_ns1__login_credentials_entry(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const *a,
                                                   const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_LONG64);
  if (id < 0)
    return soap->error;
  return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 **SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a,
                                                       const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (LONG64 **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_LONG64, sizeof(LONG64), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const *a, const char *tag,
                                                   const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerToLONG64);
  if (soap_out_PointerToLONG64(soap, tag ? tag : "long", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 **SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag,
                                                        const char *type) {
  if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const *a,
                                                 const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_time);
  if (id < 0)
    return soap->error;
  return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t **SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_time(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (time_t **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_time, sizeof(time_t), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const *a, const char *tag,
                                                 const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTotime);
  if (soap_out_PointerTotime(soap, tag ? tag : "dateTime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 time_t **SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag,
                                                      const char *type) {
  if ((p = soap_in_PointerTotime(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entityBaseBean(struct soap *soap,
                                                                       ns1__entityBaseBean *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__entityBaseBean))
    (*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entityBaseBean(struct soap *soap, const char *tag, int id,
                                                                ns1__entityBaseBean *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__entityBaseBean);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__entityBaseBean **SOAP_FMAC4 soap_in_PointerTons1__entityBaseBean(struct soap *soap, const char *tag,
                                                                                 ns1__entityBaseBean **a,
                                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (ns1__entityBaseBean **)soap_malloc(soap, sizeof(ns1__entityBaseBean *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (ns1__entityBaseBean *)soap_instantiate_ns1__entityBaseBean(soap, -1, soap->type, soap->arrayType,
                                                                           nullptr)))
      return nullptr;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, nullptr))
      return nullptr;
  } else {
    ns1__entityBaseBean **p = (ns1__entityBaseBean **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__entityBaseBean, sizeof(ns1__entityBaseBean), 0);
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafile,
                                                 sizeof(ns1__datafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__dataCollectionDatafile,
                                                 sizeof(ns1__dataCollectionDatafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataCollection,
                                                 sizeof(ns1__dataCollection), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__dataCollectionDataset,
                                                 sizeof(ns1__dataCollectionDataset), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__dataset,
                                                 sizeof(ns1__dataset), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigation,
                                                 sizeof(ns1__investigation), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facility,
                                                 sizeof(ns1__facility), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__application,
                                                 sizeof(ns1__application), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__job,
                                                 sizeof(ns1__job), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileFormat,
                                                 sizeof(ns1__datafileFormat), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetType,
                                                 sizeof(ns1__datasetType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__facilityCycle,
                                                 sizeof(ns1__facilityCycle), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrument,
                                                 sizeof(ns1__instrument), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__instrumentScientist,
                                                 sizeof(ns1__instrumentScientist), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__user,
                                                 sizeof(ns1__user), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationUser,
                                                 sizeof(ns1__investigationUser), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__study,
                                                 sizeof(ns1__study), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__studyInvestigation,
                                                 sizeof(ns1__studyInvestigation), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__userGroup,
                                                 sizeof(ns1__userGroup), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__grouping,
                                                 sizeof(ns1__grouping), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__rule,
                                                 sizeof(ns1__rule), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__investigationInstrument,
                                                 sizeof(ns1__investigationInstrument), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__investigationType,
                                                 sizeof(ns1__investigationType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameterType,
                                                 sizeof(ns1__parameterType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__parameter,
                                                 sizeof(ns1__parameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__permissibleStringValue,
                                                 sizeof(ns1__permissibleStringValue), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sample,
                                                 sizeof(ns1__sample), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleType,
                                                 sizeof(ns1__sampleType), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__keyword,
                                                 sizeof(ns1__keyword), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publication,
                                                 sizeof(ns1__publication), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__shift,
                                                 sizeof(ns1__shift), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__relatedDatafile,
                                                 sizeof(ns1__relatedDatafile), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__log,
                                                 sizeof(ns1__log), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__publicStep,
                                                 sizeof(ns1__publicStep), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__dataCollectionParameter,
                                                 sizeof(ns1__dataCollectionParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datafileParameter,
                                                 sizeof(ns1__datafileParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__datasetParameter,
                                                 sizeof(ns1__datasetParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a,
                                                 SOAP_TYPE_ICat4_ns1__investigationParameter,
                                                 sizeof(ns1__investigationParameter), 0);
    }
    if (!p && soap->error == SOAP_HREF) {
      soap->error = SOAP_OK;
      p = (ns1__entityBaseBean **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__sampleParameter,
                                                 sizeof(ns1__sampleParameter), 0);
    }
    a = p;
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entityBaseBean(struct soap *soap, ns1__entityBaseBean *const *a,
                                                                const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__entityBaseBean);
  if (soap_out_PointerTons1__entityBaseBean(soap, tag ? tag : "ns1:entityBaseBean", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__entityBaseBean **SOAP_FMAC4 soap_get_PointerTons1__entityBaseBean(struct soap *soap,
                                                                                  ns1__entityBaseBean **p,
                                                                                  const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__entityBaseBean(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__icatExceptionType(struct soap *soap,
                                                                          enum ns1__icatExceptionType *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_ns1__icatExceptionType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__icatExceptionType(struct soap *soap, const char *tag, int id,
                                                                   enum ns1__icatExceptionType *const *a,
                                                                   const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_ns1__icatExceptionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__icatExceptionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__icatExceptionType **SOAP_FMAC4 soap_in_PointerTons1__icatExceptionType(
    struct soap *soap, const char *tag, enum ns1__icatExceptionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (enum ns1__icatExceptionType **)soap_malloc(soap, sizeof(enum ns1__icatExceptionType *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__icatExceptionType(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (enum ns1__icatExceptionType **)soap_id_lookup(
        soap, soap->href, (void **)a, SOAP_TYPE_ICat4_ns1__icatExceptionType, sizeof(enum ns1__icatExceptionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__icatExceptionType(struct soap *soap,
                                                                   enum ns1__icatExceptionType *const *a,
                                                                   const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTons1__icatExceptionType);
  if (soap_out_PointerTons1__icatExceptionType(soap, tag ? tag : "ns1:icatExceptionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__icatExceptionType **SOAP_FMAC4 soap_get_PointerTons1__icatExceptionType(
    struct soap *soap, enum ns1__icatExceptionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__icatExceptionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const *a) {
#ifndef WITH_NOIDREF
  if (!soap_reference(soap, *a, SOAP_TYPE_ICat4_std__string))
    soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id,
                                                        std::string *const *a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, nullptr, 0, type, SOAP_TYPE_ICat4_std__string);
  if (id < 0)
    return soap->error;
  return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string **SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a,
                                                                 const char *type) {
  if (soap_element_begin_in(soap, tag, 1, nullptr))
    return nullptr;
  if (!a)
    if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
      return nullptr;
  *a = nullptr;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_std__string(soap, tag, *a, type)))
      return nullptr;
  } else {
    a = (std::string **)soap_id_lookup(soap, soap->href, (void **)a, SOAP_TYPE_ICat4_std__string, sizeof(std::string),
                                       0);
    if (soap->body && soap_element_end_in(soap, tag))
      return nullptr;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const *a, const char *tag,
                                                        const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_PointerTostd__string);
  if (soap_out_PointerTostd__string(soap, tag ? tag : "string", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 std::string **SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag,
                                                                  const char *type) {
  if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const *a,
                                          const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ICat4__QName);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_ICat4__QName, 2, 0, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4__QName);
  if (soap_out__QName(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in__QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char *)nullptr;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const *a) {
#ifndef WITH_NOIDREF
  soap_reference(soap, *a, SOAP_TYPE_ICat4_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const *a,
                                          const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ICat4_string);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_ICat4_string, 1, 0, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const *a, const char *tag, const char *type) {
  int id = soap_embed(soap, (void *)a, nullptr, 0, tag, SOAP_TYPE_ICat4_string);
  if (soap_out_string(soap, tag ? tag : "byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char **SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in_string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return nullptr;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__sampleParameter(
    struct soap *soap, std::vector<ns1__sampleParameter *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__sampleParameter(
    struct soap *soap, const std::vector<ns1__sampleParameter *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__sampleParameter *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__sampleParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__sampleParameter(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__sampleParameter *> *a, const char *type) {
  for (std::vector<ns1__sampleParameter *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__sampleParameter(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__sampleParameter *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__sampleParameter(
    struct soap *soap, const char *tag, std::vector<ns1__sampleParameter *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__sampleParameter *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__sampleParameter,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleParameter, sizeof(ns1__sampleParameter), 1))
        break;
      if (!soap_in_PointerTons1__sampleParameter(soap, tag, nullptr, "ns1:sampleParameter"))
        break;
    } else if (!soap_in_PointerTons1__sampleParameter(soap, tag, &n, "ns1:sampleParameter"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__sampleParameter(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__sampleParameter *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "sampleParameter(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__sampleParameter *>);
    if (size)
      *size = sizeof(std::vector<ns1__sampleParameter *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__sampleParameter *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__sampleParameter *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__sampleParameter *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__sampleParameter(struct soap *soap, int st,
                                                                                        int tt, void *p, size_t len,
                                                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__sampleParameter * > %p -> %p\n", q, p));
  *(std::vector<ns1__sampleParameter *> *)p = *(std::vector<ns1__sampleParameter *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__permissibleStringValue(
    struct soap *soap, std::vector<ns1__permissibleStringValue *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__permissibleStringValue(
    struct soap *soap, const std::vector<ns1__permissibleStringValue *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__permissibleStringValue *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__permissibleStringValue(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__permissibleStringValue(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__permissibleStringValue *> *a, const char *type) {
  for (std::vector<ns1__permissibleStringValue *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__permissibleStringValue(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__permissibleStringValue *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__permissibleStringValue(struct soap *soap, const char *tag,
                                                                  std::vector<ns1__permissibleStringValue *> *a,
                                                                  const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__permissibleStringValue *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__permissibleStringValue,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__permissibleStringValue,
                                     sizeof(ns1__permissibleStringValue), 1))
        break;
      if (!soap_in_PointerTons1__permissibleStringValue(soap, tag, nullptr, "ns1:permissibleStringValue"))
        break;
    } else if (!soap_in_PointerTons1__permissibleStringValue(soap, tag, &n, "ns1:permissibleStringValue"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__permissibleStringValue(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__permissibleStringValue *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__permissibleStringValue(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "permissibleStringValue(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__permissibleStringValue, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__permissibleStringValue *>);
    if (size)
      *size = sizeof(std::vector<ns1__permissibleStringValue *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__permissibleStringValue *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__permissibleStringValue *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__permissibleStringValue *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__permissibleStringValue(
    struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__permissibleStringValue * > %p -> %p\n", q, p));
  *(std::vector<ns1__permissibleStringValue *> *)p = *(std::vector<ns1__permissibleStringValue *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__rule(struct soap *soap,
                                                                                std::vector<ns1__rule *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__rule(struct soap *soap,
                                                                                  const std::vector<ns1__rule *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__rule *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__rule(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__rule(struct soap *soap, const char *tag, int id,
                                                                           const std::vector<ns1__rule *> *a,
                                                                           const char *type) {
  for (std::vector<ns1__rule *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__rule(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__rule *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__rule(
    struct soap *soap, const char *tag, std::vector<ns1__rule *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__rule *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__rule, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__rule,
                                     sizeof(ns1__rule), 1))
        break;
      if (!soap_in_PointerTons1__rule(soap, tag, nullptr, "ns1:rule"))
        break;
    } else if (!soap_in_PointerTons1__rule(soap, tag, &n, "ns1:rule"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__rule(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__rule *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__rule(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__rule(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__rule, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__rule *>);
    if (size)
      *size = sizeof(std::vector<ns1__rule *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__rule *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__rule *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__rule *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__rule(struct soap *soap, int st, int tt, void *p,
                                                                             size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__rule * > %p -> %p\n", q, p));
  *(std::vector<ns1__rule *> *)p = *(std::vector<ns1__rule *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__userGroup(struct soap *soap,
                                                                                     std::vector<ns1__userGroup *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTons1__userGroup(struct soap *soap, const std::vector<ns1__userGroup *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__userGroup *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__userGroup(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__userGroup(struct soap *soap, const char *tag,
                                                                                int id,
                                                                                const std::vector<ns1__userGroup *> *a,
                                                                                const char *type) {
  for (std::vector<ns1__userGroup *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__userGroup(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__userGroup *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__userGroup(
    struct soap *soap, const char *tag, std::vector<ns1__userGroup *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__userGroup *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__userGroup,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__userGroup, sizeof(ns1__userGroup), 1))
        break;
      if (!soap_in_PointerTons1__userGroup(soap, tag, nullptr, "ns1:userGroup"))
        break;
    } else if (!soap_in_PointerTons1__userGroup(soap, tag, &n, "ns1:userGroup"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__userGroup(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__userGroup *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__userGroup(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__userGroup(%"
                            "d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__userGroup, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__userGroup *>);
    if (size)
      *size = sizeof(std::vector<ns1__userGroup *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__userGroup *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__userGroup *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__userGroup *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__userGroup(struct soap *soap, int st, int tt,
                                                                                  void *p, size_t len, const void *q,
                                                                                  size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__userGroup * > %p -> %p\n", q, p));
  *(std::vector<ns1__userGroup *> *)p = *(std::vector<ns1__userGroup *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__study(struct soap *soap,
                                                                                 std::vector<ns1__study *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__study(struct soap *soap,
                                                                                   const std::vector<ns1__study *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__study *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__study(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__study(struct soap *soap, const char *tag, int id,
                                                                            const std::vector<ns1__study *> *a,
                                                                            const char *type) {
  for (std::vector<ns1__study *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__study(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__study *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__study(
    struct soap *soap, const char *tag, std::vector<ns1__study *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__study *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__study,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__study, sizeof(ns1__study), 1))
        break;
      if (!soap_in_PointerTons1__study(soap, tag, nullptr, "ns1:study"))
        break;
    } else if (!soap_in_PointerTons1__study(soap, tag, &n, "ns1:study"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__study(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__study *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__study(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__study(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__study, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__study *>);
    if (size)
      *size = sizeof(std::vector<ns1__study *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__study *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__study *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__study *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__study(struct soap *soap, int st, int tt,
                                                                              void *p, size_t len, const void *q,
                                                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__study * > %p -> %p\n", q, p));
  *(std::vector<ns1__study *> *)p = *(std::vector<ns1__study *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__instrumentScientist(
    struct soap *soap, std::vector<ns1__instrumentScientist *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__instrumentScientist(
    struct soap *soap, const std::vector<ns1__instrumentScientist *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__instrumentScientist *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__instrumentScientist(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__instrumentScientist(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__instrumentScientist *> *a, const char *type) {
  for (std::vector<ns1__instrumentScientist *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__instrumentScientist(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__instrumentScientist *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__instrumentScientist(struct soap *soap, const char *tag,
                                                               std::vector<ns1__instrumentScientist *> *a,
                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__instrumentScientist *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__instrumentScientist,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrumentScientist,
                                     sizeof(ns1__instrumentScientist), 1))
        break;
      if (!soap_in_PointerTons1__instrumentScientist(soap, tag, nullptr, "ns1:instrumentScientist"))
        break;
    } else if (!soap_in_PointerTons1__instrumentScientist(soap, tag, &n, "ns1:instrumentScientist"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__instrumentScientist(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__instrumentScientist *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__instrumentScientist(struct soap *soap, int n, const char *type,
                                                                        const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "instrumentScientist(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrumentScientist, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__instrumentScientist *>);
    if (size)
      *size = sizeof(std::vector<ns1__instrumentScientist *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__instrumentScientist *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__instrumentScientist *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__instrumentScientist *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__instrumentScientist(struct soap *soap, int st,
                                                                                            int tt, void *p, size_t len,
                                                                                            const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__instrumentScientist * > %p -> %p\n", q, p));
  *(std::vector<ns1__instrumentScientist *> *)p = *(std::vector<ns1__instrumentScientist *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__sampleType(struct soap *soap, std::vector<ns1__sampleType *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__sampleType(
    struct soap *soap, const std::vector<ns1__sampleType *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__sampleType *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__sampleType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__sampleType(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__sampleType *> *a, const char *type) {
  for (std::vector<ns1__sampleType *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__sampleType(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__sampleType *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__sampleType(
    struct soap *soap, const char *tag, std::vector<ns1__sampleType *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__sampleType *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__sampleType,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleType, sizeof(ns1__sampleType), 1))
        break;
      if (!soap_in_PointerTons1__sampleType(soap, tag, nullptr, "ns1:sampleType"))
        break;
    } else if (!soap_in_PointerTons1__sampleType(soap, tag, &n, "ns1:sampleType"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__sampleType(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__sampleType *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__sampleType(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__sampleType(%"
                            "d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sampleType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__sampleType *>);
    if (size)
      *size = sizeof(std::vector<ns1__sampleType *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__sampleType *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__sampleType *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__sampleType *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__sampleType(struct soap *soap, int st, int tt,
                                                                                   void *p, size_t len, const void *q,
                                                                                   size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__sampleType * > %p -> %p\n", q, p));
  *(std::vector<ns1__sampleType *> *)p = *(std::vector<ns1__sampleType *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__parameterType(struct soap *soap, std::vector<ns1__parameterType *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__parameterType(
    struct soap *soap, const std::vector<ns1__parameterType *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__parameterType *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__parameterType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__parameterType(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__parameterType *> *a, const char *type) {
  for (std::vector<ns1__parameterType *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__parameterType(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__parameterType *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__parameterType(
    struct soap *soap, const char *tag, std::vector<ns1__parameterType *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__parameterType *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__parameterType,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__parameterType, sizeof(ns1__parameterType), 1))
        break;
      if (!soap_in_PointerTons1__parameterType(soap, tag, nullptr, "ns1:parameterType"))
        break;
    } else if (!soap_in_PointerTons1__parameterType(soap, tag, &n, "ns1:parameterType"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__parameterType(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__parameterType *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__parameterType(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "parameterType(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__parameterType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__parameterType *>);
    if (size)
      *size = sizeof(std::vector<ns1__parameterType *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__parameterType *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__parameterType *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__parameterType *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__parameterType(struct soap *soap, int st, int tt,
                                                                                      void *p, size_t len,
                                                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__parameterType * > %p -> %p\n", q, p));
  *(std::vector<ns1__parameterType *> *)p = *(std::vector<ns1__parameterType *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, std::vector<ns1__investigation *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigation(
    struct soap *soap, const std::vector<ns1__investigation *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__investigation *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__investigation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigation(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__investigation *> *a, const char *type) {
  for (std::vector<ns1__investigation *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__investigation(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigation *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__investigation(
    struct soap *soap, const char *tag, std::vector<ns1__investigation *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__investigation *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__investigation,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigation, sizeof(ns1__investigation), 1))
        break;
      if (!soap_in_PointerTons1__investigation(soap, tag, nullptr, "ns1:investigation"))
        break;
    } else if (!soap_in_PointerTons1__investigation(soap, tag, &n, "ns1:investigation"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigation(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__investigation *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "investigation(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigation, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__investigation *>);
    if (size)
      *size = sizeof(std::vector<ns1__investigation *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__investigation *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__investigation *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__investigation *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigation(struct soap *soap, int st, int tt,
                                                                                      void *p, size_t len,
                                                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigation * > %p -> %p\n", q, p));
  *(std::vector<ns1__investigation *> *)p = *(std::vector<ns1__investigation *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigationType(
    struct soap *soap, std::vector<ns1__investigationType *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigationType(
    struct soap *soap, const std::vector<ns1__investigationType *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__investigationType *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__investigationType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigationType(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__investigationType *> *a, const char *type) {
  for (std::vector<ns1__investigationType *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__investigationType(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigationType *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__investigationType(struct soap *soap, const char *tag,
                                                             std::vector<ns1__investigationType *> *a,
                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__investigationType *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__investigationType,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationType, sizeof(ns1__investigationType), 1))
        break;
      if (!soap_in_PointerTons1__investigationType(soap, tag, nullptr, "ns1:investigationType"))
        break;
    } else if (!soap_in_PointerTons1__investigationType(soap, tag, &n, "ns1:investigationType"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigationType(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__investigationType *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__investigationType(struct soap *soap, int n, const char *type,
                                                                      const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "investigationType(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__investigationType *>);
    if (size)
      *size = sizeof(std::vector<ns1__investigationType *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__investigationType *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__investigationType *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__investigationType *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigationType(struct soap *soap, int st,
                                                                                          int tt, void *p, size_t len,
                                                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigationType * > %p -> %p\n", q, p));
  *(std::vector<ns1__investigationType *> *)p = *(std::vector<ns1__investigationType *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__instrument(struct soap *soap, std::vector<ns1__instrument *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__instrument(
    struct soap *soap, const std::vector<ns1__instrument *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__instrument *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__instrument(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__instrument(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__instrument *> *a, const char *type) {
  for (std::vector<ns1__instrument *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__instrument(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__instrument *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__instrument(
    struct soap *soap, const char *tag, std::vector<ns1__instrument *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__instrument *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__instrument,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrument, sizeof(ns1__instrument), 1))
        break;
      if (!soap_in_PointerTons1__instrument(soap, tag, nullptr, "ns1:instrument"))
        break;
    } else if (!soap_in_PointerTons1__instrument(soap, tag, &n, "ns1:instrument"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__instrument(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__instrument *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__instrument(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__instrument(%"
                            "d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__instrument, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__instrument *>);
    if (size)
      *size = sizeof(std::vector<ns1__instrument *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__instrument *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__instrument *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__instrument *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__instrument(struct soap *soap, int st, int tt,
                                                                                   void *p, size_t len, const void *q,
                                                                                   size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__instrument * > %p -> %p\n", q, p));
  *(std::vector<ns1__instrument *> *)p = *(std::vector<ns1__instrument *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, std::vector<ns1__facilityCycle *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__facilityCycle(
    struct soap *soap, const std::vector<ns1__facilityCycle *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__facilityCycle *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__facilityCycle(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__facilityCycle(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__facilityCycle *> *a, const char *type) {
  for (std::vector<ns1__facilityCycle *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__facilityCycle(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__facilityCycle *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__facilityCycle(
    struct soap *soap, const char *tag, std::vector<ns1__facilityCycle *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__facilityCycle *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__facilityCycle,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__facilityCycle, sizeof(ns1__facilityCycle), 1))
        break;
      if (!soap_in_PointerTons1__facilityCycle(soap, tag, nullptr, "ns1:facilityCycle"))
        break;
    } else if (!soap_in_PointerTons1__facilityCycle(soap, tag, &n, "ns1:facilityCycle"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__facilityCycle(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__facilityCycle *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, int n, const char *type,
                                                                  const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "facilityCycle(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__facilityCycle, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__facilityCycle *>);
    if (size)
      *size = sizeof(std::vector<ns1__facilityCycle *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__facilityCycle *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__facilityCycle *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__facilityCycle *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__facilityCycle(struct soap *soap, int st, int tt,
                                                                                      void *p, size_t len,
                                                                                      const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__facilityCycle * > %p -> %p\n", q, p));
  *(std::vector<ns1__facilityCycle *> *)p = *(std::vector<ns1__facilityCycle *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__datasetType(struct soap *soap, std::vector<ns1__datasetType *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datasetType(
    struct soap *soap, const std::vector<ns1__datasetType *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__datasetType *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__datasetType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datasetType(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__datasetType *> *a, const char *type) {
  for (std::vector<ns1__datasetType *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__datasetType(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datasetType *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datasetType(
    struct soap *soap, const char *tag, std::vector<ns1__datasetType *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__datasetType *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__datasetType,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetType, sizeof(ns1__datasetType), 1))
        break;
      if (!soap_in_PointerTons1__datasetType(soap, tag, nullptr, "ns1:datasetType"))
        break;
    } else if (!soap_in_PointerTons1__datasetType(soap, tag, &n, "ns1:datasetType"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datasetType(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__datasetType *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datasetType(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__datasetType("
                            "%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__datasetType *>);
    if (size)
      *size = sizeof(std::vector<ns1__datasetType *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__datasetType *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__datasetType *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__datasetType *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datasetType(struct soap *soap, int st, int tt,
                                                                                    void *p, size_t len, const void *q,
                                                                                    size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datasetType * > %p -> %p\n", q, p));
  *(std::vector<ns1__datasetType *> *)p = *(std::vector<ns1__datasetType *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafileFormat(
    struct soap *soap, std::vector<ns1__datafileFormat *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datafileFormat(
    struct soap *soap, const std::vector<ns1__datafileFormat *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__datafileFormat *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__datafileFormat(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafileFormat(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__datafileFormat *> *a, const char *type) {
  for (std::vector<ns1__datafileFormat *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__datafileFormat(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafileFormat *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datafileFormat(
    struct soap *soap, const char *tag, std::vector<ns1__datafileFormat *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__datafileFormat *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__datafileFormat,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileFormat, sizeof(ns1__datafileFormat), 1))
        break;
      if (!soap_in_PointerTons1__datafileFormat(soap, tag, nullptr, "ns1:datafileFormat"))
        break;
    } else if (!soap_in_PointerTons1__datafileFormat(soap, tag, &n, "ns1:datafileFormat"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafileFormat(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__datafileFormat *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, int n, const char *type,
                                                                   const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "datafileFormat(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileFormat, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__datafileFormat *>);
    if (size)
      *size = sizeof(std::vector<ns1__datafileFormat *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__datafileFormat *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__datafileFormat *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__datafileFormat *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafileFormat(struct soap *soap, int st,
                                                                                       int tt, void *p, size_t len,
                                                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafileFormat * > %p -> %p\n", q, p));
  *(std::vector<ns1__datafileFormat *> *)p = *(std::vector<ns1__datafileFormat *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__application(struct soap *soap, std::vector<ns1__application *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__application(
    struct soap *soap, const std::vector<ns1__application *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__application *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__application(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__application(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__application *> *a, const char *type) {
  for (std::vector<ns1__application *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__application(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__application *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__application(
    struct soap *soap, const char *tag, std::vector<ns1__application *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__application *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__application,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__application, sizeof(ns1__application), 1))
        break;
      if (!soap_in_PointerTons1__application(soap, tag, nullptr, "ns1:application"))
        break;
    } else if (!soap_in_PointerTons1__application(soap, tag, &n, "ns1:application"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__application(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__application *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__application(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__application("
                            "%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__application, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__application *>);
    if (size)
      *size = sizeof(std::vector<ns1__application *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__application *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__application *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__application *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__application(struct soap *soap, int st, int tt,
                                                                                    void *p, size_t len, const void *q,
                                                                                    size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__application * > %p -> %p\n", q, p));
  *(std::vector<ns1__application *> *)p = *(std::vector<ns1__application *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__studyInvestigation(
    struct soap *soap, std::vector<ns1__studyInvestigation *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__studyInvestigation(
    struct soap *soap, const std::vector<ns1__studyInvestigation *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__studyInvestigation *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__studyInvestigation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__studyInvestigation(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__studyInvestigation *> *a, const char *type) {
  for (std::vector<ns1__studyInvestigation *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__studyInvestigation(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__studyInvestigation *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__studyInvestigation(struct soap *soap, const char *tag,
                                                              std::vector<ns1__studyInvestigation *> *a,
                                                              const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__studyInvestigation *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__studyInvestigation,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__studyInvestigation,
                                     sizeof(ns1__studyInvestigation), 1))
        break;
      if (!soap_in_PointerTons1__studyInvestigation(soap, tag, nullptr, "ns1:studyInvestigation"))
        break;
    } else if (!soap_in_PointerTons1__studyInvestigation(soap, tag, &n, "ns1:studyInvestigation"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__studyInvestigation(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__studyInvestigation *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__studyInvestigation(struct soap *soap, int n, const char *type,
                                                                       const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "studyInvestigation(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__studyInvestigation, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__studyInvestigation *>);
    if (size)
      *size = sizeof(std::vector<ns1__studyInvestigation *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__studyInvestigation *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__studyInvestigation *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__studyInvestigation *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__studyInvestigation(struct soap *soap, int st,
                                                                                           int tt, void *p, size_t len,
                                                                                           const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__studyInvestigation * > %p -> %p\n", q, p));
  *(std::vector<ns1__studyInvestigation *> *)p = *(std::vector<ns1__studyInvestigation *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__shift(struct soap *soap,
                                                                                 std::vector<ns1__shift *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__shift(struct soap *soap,
                                                                                   const std::vector<ns1__shift *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__shift *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__shift(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, const char *tag, int id,
                                                                            const std::vector<ns1__shift *> *a,
                                                                            const char *type) {
  for (std::vector<ns1__shift *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__shift(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__shift *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__shift(
    struct soap *soap, const char *tag, std::vector<ns1__shift *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__shift *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__shift,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__shift, sizeof(ns1__shift), 1))
        break;
      if (!soap_in_PointerTons1__shift(soap, tag, nullptr, "ns1:shift"))
        break;
    } else if (!soap_in_PointerTons1__shift(soap, tag, &n, "ns1:shift"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__shift(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__shift *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__shift(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__shift(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__shift, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__shift *>);
    if (size)
      *size = sizeof(std::vector<ns1__shift *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__shift *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__shift *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__shift *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__shift(struct soap *soap, int st, int tt,
                                                                              void *p, size_t len, const void *q,
                                                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__shift * > %p -> %p\n", q, p));
  *(std::vector<ns1__shift *> *)p = *(std::vector<ns1__shift *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__sample(struct soap *soap,
                                                                                  std::vector<ns1__sample *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, const std::vector<ns1__sample *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__sample *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__sample(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, const char *tag, int id,
                                                                             const std::vector<ns1__sample *> *a,
                                                                             const char *type) {
  for (std::vector<ns1__sample *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__sample(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__sample *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__sample(
    struct soap *soap, const char *tag, std::vector<ns1__sample *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__sample *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__sample,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sample, sizeof(ns1__sample), 1))
        break;
      if (!soap_in_PointerTons1__sample(soap, tag, nullptr, "ns1:sample"))
        break;
    } else if (!soap_in_PointerTons1__sample(soap, tag, &n, "ns1:sample"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__sample(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__sample *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__sample(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__sample(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__sample, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__sample *>);
    if (size)
      *size = sizeof(std::vector<ns1__sample *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__sample *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__sample *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__sample *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__sample(struct soap *soap, int st, int tt,
                                                                               void *p, size_t len, const void *q,
                                                                               size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__sample * > %p -> %p\n", q, p));
  *(std::vector<ns1__sample *> *)p = *(std::vector<ns1__sample *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, std::vector<ns1__publication *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__publication(
    struct soap *soap, const std::vector<ns1__publication *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__publication *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__publication(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__publication(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__publication *> *a, const char *type) {
  for (std::vector<ns1__publication *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__publication(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__publication *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__publication(
    struct soap *soap, const char *tag, std::vector<ns1__publication *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__publication *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__publication,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__publication, sizeof(ns1__publication), 1))
        break;
      if (!soap_in_PointerTons1__publication(soap, tag, nullptr, "ns1:publication"))
        break;
    } else if (!soap_in_PointerTons1__publication(soap, tag, &n, "ns1:publication"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__publication(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__publication *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__publication(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__publication("
                            "%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__publication, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__publication *>);
    if (size)
      *size = sizeof(std::vector<ns1__publication *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__publication *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__publication *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__publication *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__publication(struct soap *soap, int st, int tt,
                                                                                    void *p, size_t len, const void *q,
                                                                                    size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__publication * > %p -> %p\n", q, p));
  *(std::vector<ns1__publication *> *)p = *(std::vector<ns1__publication *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigationParameter(
    struct soap *soap, std::vector<ns1__investigationParameter *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigationParameter(
    struct soap *soap, const std::vector<ns1__investigationParameter *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__investigationParameter *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__investigationParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigationParameter(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__investigationParameter *> *a, const char *type) {
  for (std::vector<ns1__investigationParameter *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__investigationParameter(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigationParameter *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__investigationParameter(struct soap *soap, const char *tag,
                                                                  std::vector<ns1__investigationParameter *> *a,
                                                                  const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__investigationParameter *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__investigationParameter,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationParameter,
                                     sizeof(ns1__investigationParameter), 1))
        break;
      if (!soap_in_PointerTons1__investigationParameter(soap, tag, nullptr, "ns1:investigationParameter"))
        break;
    } else if (!soap_in_PointerTons1__investigationParameter(soap, tag, &n, "ns1:investigationParameter"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigationParameter(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__investigationParameter *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__investigationParameter(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "investigationParameter(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__investigationParameter *>);
    if (size)
      *size = sizeof(std::vector<ns1__investigationParameter *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__investigationParameter *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__investigationParameter *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__investigationParameter *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigationParameter(
    struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigationParameter * > %p -> %p\n", q, p));
  *(std::vector<ns1__investigationParameter *> *)p = *(std::vector<ns1__investigationParameter *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap,
                                                                                   std::vector<ns1__keyword *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, const std::vector<ns1__keyword *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__keyword *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__keyword(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, const char *tag,
                                                                              int id,
                                                                              const std::vector<ns1__keyword *> *a,
                                                                              const char *type) {
  for (std::vector<ns1__keyword *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__keyword(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__keyword *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__keyword(
    struct soap *soap, const char *tag, std::vector<ns1__keyword *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__keyword *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__keyword,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__keyword, sizeof(ns1__keyword), 1))
        break;
      if (!soap_in_PointerTons1__keyword(soap, tag, nullptr, "ns1:keyword"))
        break;
    } else if (!soap_in_PointerTons1__keyword(soap, tag, &n, "ns1:keyword"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__keyword(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__keyword *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__keyword(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__keyword(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__keyword, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__keyword *>);
    if (size)
      *size = sizeof(std::vector<ns1__keyword *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__keyword *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__keyword *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__keyword *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__keyword(struct soap *soap, int st, int tt,
                                                                                void *p, size_t len, const void *q,
                                                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__keyword * > %p -> %p\n", q, p));
  *(std::vector<ns1__keyword *> *)p = *(std::vector<ns1__keyword *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigationUser(
    struct soap *soap, std::vector<ns1__investigationUser *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigationUser(
    struct soap *soap, const std::vector<ns1__investigationUser *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__investigationUser *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__investigationUser(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigationUser(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__investigationUser *> *a, const char *type) {
  for (std::vector<ns1__investigationUser *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__investigationUser(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigationUser *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__investigationUser(struct soap *soap, const char *tag,
                                                             std::vector<ns1__investigationUser *> *a,
                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__investigationUser *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__investigationUser,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationUser, sizeof(ns1__investigationUser), 1))
        break;
      if (!soap_in_PointerTons1__investigationUser(soap, tag, nullptr, "ns1:investigationUser"))
        break;
    } else if (!soap_in_PointerTons1__investigationUser(soap, tag, &n, "ns1:investigationUser"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigationUser(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__investigationUser *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__investigationUser(struct soap *soap, int n, const char *type,
                                                                      const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "investigationUser(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationUser, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__investigationUser *>);
    if (size)
      *size = sizeof(std::vector<ns1__investigationUser *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__investigationUser *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__investigationUser *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__investigationUser *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigationUser(struct soap *soap, int st,
                                                                                          int tt, void *p, size_t len,
                                                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigationUser * > %p -> %p\n", q, p));
  *(std::vector<ns1__investigationUser *> *)p = *(std::vector<ns1__investigationUser *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__investigationInstrument(
    struct soap *soap, std::vector<ns1__investigationInstrument *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__investigationInstrument(
    struct soap *soap, const std::vector<ns1__investigationInstrument *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__investigationInstrument *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__investigationInstrument(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__investigationInstrument(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__investigationInstrument *> *a,
    const char *type) {
  for (std::vector<ns1__investigationInstrument *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__investigationInstrument(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__investigationInstrument *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__investigationInstrument(struct soap *soap, const char *tag,
                                                                   std::vector<ns1__investigationInstrument *> *a,
                                                                   const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__investigationInstrument *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__investigationInstrument,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationInstrument,
                                     sizeof(ns1__investigationInstrument), 1))
        break;
      if (!soap_in_PointerTons1__investigationInstrument(soap, tag, nullptr, "ns1:investigationInstrument"))
        break;
    } else if (!soap_in_PointerTons1__investigationInstrument(soap, tag, &n, "ns1:investigationInstrument"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__investigationInstrument(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__investigationInstrument *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__investigationInstrument(struct soap *soap, int n, const char *type,
                                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "investigationInstrument(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__investigationInstrument, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__investigationInstrument *>);
    if (size)
      *size = sizeof(std::vector<ns1__investigationInstrument *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__investigationInstrument *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__investigationInstrument *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__investigationInstrument *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__investigationInstrument(
    struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__investigationInstrument * > %p -> %p\n", q, p));
  *(std::vector<ns1__investigationInstrument *> *)p = *(std::vector<ns1__investigationInstrument *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap,
                                                                                   std::vector<ns1__dataset *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, const std::vector<ns1__dataset *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__dataset *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__dataset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, const char *tag,
                                                                              int id,
                                                                              const std::vector<ns1__dataset *> *a,
                                                                              const char *type) {
  for (std::vector<ns1__dataset *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__dataset(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dataset *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__dataset(
    struct soap *soap, const char *tag, std::vector<ns1__dataset *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__dataset *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__dataset,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataset, sizeof(ns1__dataset), 1))
        break;
      if (!soap_in_PointerTons1__dataset(soap, tag, nullptr, "ns1:dataset"))
        break;
    } else if (!soap_in_PointerTons1__dataset(soap, tag, &n, "ns1:dataset"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dataset(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__dataset *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__dataset(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__dataset(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataset, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__dataset *>);
    if (size)
      *size = sizeof(std::vector<ns1__dataset *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__dataset *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__dataset *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__dataset *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dataset(struct soap *soap, int st, int tt,
                                                                                void *p, size_t len, const void *q,
                                                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dataset * > %p -> %p\n", q, p));
  *(std::vector<ns1__dataset *> *)p = *(std::vector<ns1__dataset *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datasetParameter(
    struct soap *soap, std::vector<ns1__datasetParameter *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datasetParameter(
    struct soap *soap, const std::vector<ns1__datasetParameter *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__datasetParameter *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__datasetParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datasetParameter(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__datasetParameter *> *a, const char *type) {
  for (std::vector<ns1__datasetParameter *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__datasetParameter(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datasetParameter *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datasetParameter(
    struct soap *soap, const char *tag, std::vector<ns1__datasetParameter *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__datasetParameter *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__datasetParameter,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetParameter, sizeof(ns1__datasetParameter), 1))
        break;
      if (!soap_in_PointerTons1__datasetParameter(soap, tag, nullptr, "ns1:datasetParameter"))
        break;
    } else if (!soap_in_PointerTons1__datasetParameter(soap, tag, &n, "ns1:datasetParameter"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datasetParameter(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__datasetParameter *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, int n, const char *type,
                                                                     const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "datasetParameter(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datasetParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__datasetParameter *>);
    if (size)
      *size = sizeof(std::vector<ns1__datasetParameter *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__datasetParameter *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__datasetParameter *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__datasetParameter *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datasetParameter(struct soap *soap, int st,
                                                                                         int tt, void *p, size_t len,
                                                                                         const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datasetParameter * > %p -> %p\n", q, p));
  *(std::vector<ns1__datasetParameter *> *)p = *(std::vector<ns1__datasetParameter *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap,
                                                                                    std::vector<ns1__datafile *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, const std::vector<ns1__datafile *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__datafile *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__datafile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, const char *tag,
                                                                               int id,
                                                                               const std::vector<ns1__datafile *> *a,
                                                                               const char *type) {
  for (std::vector<ns1__datafile *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__datafile(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafile *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__datafile(
    struct soap *soap, const char *tag, std::vector<ns1__datafile *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__datafile *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__datafile,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafile, sizeof(ns1__datafile), 1))
        break;
      if (!soap_in_PointerTons1__datafile(soap, tag, nullptr, "ns1:datafile"))
        break;
    } else if (!soap_in_PointerTons1__datafile(soap, tag, &n, "ns1:datafile"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafile(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__datafile *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__datafile(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__datafile(%d,"
                            " %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__datafile *>);
    if (size)
      *size = sizeof(std::vector<ns1__datafile *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__datafile *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__datafile *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__datafile *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafile(struct soap *soap, int st, int tt,
                                                                                 void *p, size_t len, const void *q,
                                                                                 size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafile * > %p -> %p\n", q, p));
  *(std::vector<ns1__datafile *> *)p = *(std::vector<ns1__datafile *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
    struct soap *soap, std::vector<ns1__dataCollectionParameter *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
    struct soap *soap, const std::vector<ns1__dataCollectionParameter *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__dataCollectionParameter *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__dataCollectionParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__dataCollectionParameter *> *a,
    const char *type) {
  for (std::vector<ns1__dataCollectionParameter *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__dataCollectionParameter(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dataCollectionParameter *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__dataCollectionParameter(struct soap *soap, const char *tag,
                                                                   std::vector<ns1__dataCollectionParameter *> *a,
                                                                   const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__dataCollectionParameter *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__dataCollectionParameter,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionParameter,
                                     sizeof(ns1__dataCollectionParameter), 1))
        break;
      if (!soap_in_PointerTons1__dataCollectionParameter(soap, tag, nullptr, "ns1:dataCollectionParameter"))
        break;
    } else if (!soap_in_PointerTons1__dataCollectionParameter(soap, tag, &n, "ns1:dataCollectionParameter"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dataCollectionParameter(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__dataCollectionParameter *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionParameter(struct soap *soap, int n, const char *type,
                                                                            const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "dataCollectionParameter(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__dataCollectionParameter *>);
    if (size)
      *size = sizeof(std::vector<ns1__dataCollectionParameter *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__dataCollectionParameter *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__dataCollectionParameter *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__dataCollectionParameter *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dataCollectionParameter(
    struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dataCollectionParameter * > %p -> %p\n", q, p));
  *(std::vector<ns1__dataCollectionParameter *> *)p = *(std::vector<ns1__dataCollectionParameter *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__job(struct soap *soap,
                                                                               std::vector<ns1__job *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__job(struct soap *soap,
                                                                                 const std::vector<ns1__job *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__job *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__job(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__job(struct soap *soap, const char *tag, int id,
                                                                          const std::vector<ns1__job *> *a,
                                                                          const char *type) {
  for (std::vector<ns1__job *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__job(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__job *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__job(
    struct soap *soap, const char *tag, std::vector<ns1__job *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__job *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__job, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__job,
                                     sizeof(ns1__job), 1))
        break;
      if (!soap_in_PointerTons1__job(soap, tag, nullptr, "ns1:job"))
        break;
    } else if (!soap_in_PointerTons1__job(soap, tag, &n, "ns1:job"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__job(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__job *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__job(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__job(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__job, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__job *>);
    if (size)
      *size = sizeof(std::vector<ns1__job *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__job *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__job *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__job *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__job(struct soap *soap, int st, int tt, void *p,
                                                                            size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__job * > %p -> %p\n", q, p));
  *(std::vector<ns1__job *> *)p = *(std::vector<ns1__job *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
    struct soap *soap, std::vector<ns1__dataCollectionDataset *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
    struct soap *soap, const std::vector<ns1__dataCollectionDataset *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__dataCollectionDataset *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__dataCollectionDataset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDataset(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__dataCollectionDataset *> *a, const char *type) {
  for (std::vector<ns1__dataCollectionDataset *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__dataCollectionDataset(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dataCollectionDataset *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDataset(struct soap *soap, const char *tag,
                                                                 std::vector<ns1__dataCollectionDataset *> *a,
                                                                 const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__dataCollectionDataset *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__dataCollectionDataset,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDataset,
                                     sizeof(ns1__dataCollectionDataset), 1))
        break;
      if (!soap_in_PointerTons1__dataCollectionDataset(soap, tag, nullptr, "ns1:dataCollectionDataset"))
        break;
    } else if (!soap_in_PointerTons1__dataCollectionDataset(soap, tag, &n, "ns1:dataCollectionDataset"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dataCollectionDataset(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__dataCollectionDataset *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionDataset(struct soap *soap, int n, const char *type,
                                                                          const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "dataCollectionDataset(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDataset, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__dataCollectionDataset *>);
    if (size)
      *size = sizeof(std::vector<ns1__dataCollectionDataset *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__dataCollectionDataset *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__dataCollectionDataset *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__dataCollectionDataset *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dataCollectionDataset(struct soap *soap, int st,
                                                                                              int tt, void *p,
                                                                                              size_t len, const void *q,
                                                                                              size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dataCollectionDataset * > %p -> %p\n", q, p));
  *(std::vector<ns1__dataCollectionDataset *> *)p = *(std::vector<ns1__dataCollectionDataset *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__datafileParameter(
    struct soap *soap, std::vector<ns1__datafileParameter *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__datafileParameter(
    struct soap *soap, const std::vector<ns1__datafileParameter *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__datafileParameter *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__datafileParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__datafileParameter(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__datafileParameter *> *a, const char *type) {
  for (std::vector<ns1__datafileParameter *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__datafileParameter(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__datafileParameter *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, const char *tag,
                                                             std::vector<ns1__datafileParameter *> *a,
                                                             const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__datafileParameter *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__datafileParameter,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileParameter, sizeof(ns1__datafileParameter), 1))
        break;
      if (!soap_in_PointerTons1__datafileParameter(soap, tag, nullptr, "ns1:datafileParameter"))
        break;
    } else if (!soap_in_PointerTons1__datafileParameter(soap, tag, &n, "ns1:datafileParameter"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__datafileParameter(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__datafileParameter *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, int n, const char *type,
                                                                      const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "datafileParameter(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__datafileParameter, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__datafileParameter *>);
    if (size)
      *size = sizeof(std::vector<ns1__datafileParameter *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__datafileParameter *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__datafileParameter *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__datafileParameter *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__datafileParameter(struct soap *soap, int st,
                                                                                          int tt, void *p, size_t len,
                                                                                          const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__datafileParameter * > %p -> %p\n", q, p));
  *(std::vector<ns1__datafileParameter *> *)p = *(std::vector<ns1__datafileParameter *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__relatedDatafile(
    struct soap *soap, std::vector<ns1__relatedDatafile *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__relatedDatafile(
    struct soap *soap, const std::vector<ns1__relatedDatafile *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__relatedDatafile *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__relatedDatafile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__relatedDatafile(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__relatedDatafile *> *a, const char *type) {
  for (std::vector<ns1__relatedDatafile *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__relatedDatafile(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__relatedDatafile *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__relatedDatafile(
    struct soap *soap, const char *tag, std::vector<ns1__relatedDatafile *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__relatedDatafile *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__relatedDatafile,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__relatedDatafile, sizeof(ns1__relatedDatafile), 1))
        break;
      if (!soap_in_PointerTons1__relatedDatafile(soap, tag, nullptr, "ns1:relatedDatafile"))
        break;
    } else if (!soap_in_PointerTons1__relatedDatafile(soap, tag, &n, "ns1:relatedDatafile"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__relatedDatafile(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__relatedDatafile *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__relatedDatafile(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "relatedDatafile(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__relatedDatafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__relatedDatafile *>);
    if (size)
      *size = sizeof(std::vector<ns1__relatedDatafile *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__relatedDatafile *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__relatedDatafile *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__relatedDatafile *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__relatedDatafile(struct soap *soap, int st,
                                                                                        int tt, void *p, size_t len,
                                                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__relatedDatafile * > %p -> %p\n", q, p));
  *(std::vector<ns1__relatedDatafile *> *)p = *(std::vector<ns1__relatedDatafile *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
    struct soap *soap, std::vector<ns1__dataCollectionDatafile *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
    struct soap *soap, const std::vector<ns1__dataCollectionDatafile *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__dataCollectionDatafile *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__dataCollectionDatafile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__dataCollectionDatafile *> *a, const char *type) {
  for (std::vector<ns1__dataCollectionDatafile *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__dataCollectionDatafile(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dataCollectionDatafile *> *SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(struct soap *soap, const char *tag,
                                                                  std::vector<ns1__dataCollectionDatafile *> *a,
                                                                  const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__dataCollectionDatafile *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_ns1__dataCollectionDatafile,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDatafile,
                                     sizeof(ns1__dataCollectionDatafile), 1))
        break;
      if (!soap_in_PointerTons1__dataCollectionDatafile(soap, tag, nullptr, "ns1:dataCollectionDatafile"))
        break;
    } else if (!soap_in_PointerTons1__dataCollectionDatafile(soap, tag, &n, "ns1:dataCollectionDatafile"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__dataCollectionDatafile *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(struct soap *soap, int n, const char *type,
                                                                           const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "dataCollectionDatafile(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(
      soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__dataCollectionDatafile, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__dataCollectionDatafile *>);
    if (size)
      *size = sizeof(std::vector<ns1__dataCollectionDatafile *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__dataCollectionDatafile *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__dataCollectionDatafile *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__dataCollectionDatafile *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dataCollectionDatafile(
    struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dataCollectionDatafile * > %p -> %p\n", q, p));
  *(std::vector<ns1__dataCollectionDatafile *> *)p = *(std::vector<ns1__dataCollectionDatafile *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap,
                                                                                   std::vector<xsd__anyType *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const std::vector<xsd__anyType *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<xsd__anyType *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerToxsd__anyType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag,
                                                                              int id,
                                                                              const std::vector<xsd__anyType *> *a,
                                                                              const char *type) {
  for (std::vector<xsd__anyType *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerToxsd__anyType(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__anyType *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxsd__anyType(
    struct soap *soap, const char *tag, std::vector<xsd__anyType *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    xsd__anyType *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_xsd__anyType,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerToxsd__anyType, sizeof(xsd__anyType), 1))
        break;
      if (!soap_in_PointerToxsd__anyType(soap, tag, nullptr, "xsd:anyType"))
        break;
    } else if (!soap_in_PointerToxsd__anyType(soap, tag, &n, "xsd:anyType"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxsd__anyType(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<xsd__anyType *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerToxsd__anyType(%d, "
                            "%s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerToxsd__anyType, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<xsd__anyType *>);
    if (size)
      *size = sizeof(std::vector<xsd__anyType *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<xsd__anyType *>, n);
    if (size)
      *size = n * sizeof(std::vector<xsd__anyType *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<xsd__anyType *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int st, int tt,
                                                                                void *p, size_t len, const void *q,
                                                                                size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__anyType * > %p -> %p\n", q, p));
  *(std::vector<xsd__anyType *> *)p = *(std::vector<xsd__anyType *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__entityField(struct soap *soap, std::vector<ns1__entityField *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__entityField(
    struct soap *soap, const std::vector<ns1__entityField *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__entityField *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__entityField(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__entityField(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__entityField *> *a, const char *type) {
  for (std::vector<ns1__entityField *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__entityField(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__entityField *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__entityField(
    struct soap *soap, const char *tag, std::vector<ns1__entityField *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__entityField *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__entityField,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityField, sizeof(ns1__entityField), 1))
        break;
      if (!soap_in_PointerTons1__entityField(soap, tag, nullptr, "ns1:entityField"))
        break;
    } else if (!soap_in_PointerTons1__entityField(soap, tag, &n, "ns1:entityField"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__entityField(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__entityField *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__entityField(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__entityField("
                            "%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityField, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__entityField *>);
    if (size)
      *size = sizeof(std::vector<ns1__entityField *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__entityField *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__entityField *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__entityField *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__entityField(struct soap *soap, int st, int tt,
                                                                                    void *p, size_t len, const void *q,
                                                                                    size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__entityField * > %p -> %p\n", q, p));
  *(std::vector<ns1__entityField *> *)p = *(std::vector<ns1__entityField *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTons1__constraint(struct soap *soap, std::vector<ns1__constraint *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__constraint(
    struct soap *soap, const std::vector<ns1__constraint *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__constraint *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__constraint(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__constraint(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__constraint *> *a, const char *type) {
  for (std::vector<ns1__constraint *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__constraint(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__constraint *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__constraint(
    struct soap *soap, const char *tag, std::vector<ns1__constraint *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__constraint *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__constraint,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__constraint, sizeof(ns1__constraint), 1))
        break;
      if (!soap_in_PointerTons1__constraint(soap, tag, nullptr, "ns1:constraint"))
        break;
    } else if (!soap_in_PointerTons1__constraint(soap, tag, &n, "ns1:constraint"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__constraint(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__constraint *> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__constraint(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__constraint(%"
                            "d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__constraint, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__constraint *>);
    if (size)
      *size = sizeof(std::vector<ns1__constraint *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__constraint *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__constraint *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__constraint *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__constraint(struct soap *soap, int st, int tt,
                                                                                   void *p, size_t len, const void *q,
                                                                                   size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__constraint * > %p -> %p\n", q, p));
  *(std::vector<ns1__constraint *> *)p = *(std::vector<ns1__constraint *> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, std::vector<_ns1__login_credentials_entry> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, const std::vector<_ns1__login_credentials_entry> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<_ns1__login_credentials_entry>::const_iterator i = a->begin(); i != a->end(); ++i)
    (*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns1__login_credentials_entry(
    struct soap *soap, const char *tag, int id, const std::vector<_ns1__login_credentials_entry> *a, const char *type) {
  for (std::vector<_ns1__login_credentials_entry>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if ((*i).soap_out(soap, tag, id, ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns1__login_credentials_entry> *SOAP_FMAC4
soap_in_std__vectorTemplateOf_ns1__login_credentials_entry(struct soap *soap, const char *tag,
                                                           std::vector<_ns1__login_credentials_entry> *a,
                                                           const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    _ns1__login_credentials_entry n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n.soap_default(soap);
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4__ns1__login_credentials_entry,
                                     SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry,
                                     sizeof(_ns1__login_credentials_entry), 0))
        break;
      if (!soap_in__ns1__login_credentials_entry(soap, tag, nullptr, ""))
        break;
    } else if (!soap_in__ns1__login_credentials_entry(soap, tag, &n, ""))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOf_ns1__login_credentials_entry(soap, -1)))
      return nullptr;
    soap_update_pointers(soap, (char *)&n, (char *)&n + sizeof(n), (char *)&(*a->insert(a->end(), n)), (char *)&n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<_ns1__login_credentials_entry> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOf_ns1__login_credentials_entry(struct soap *soap, int n, const char *type,
                                                                    const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__vectorTemplateOf_ns1__"
                            "login_credentials_entry(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOf_ns1__login_credentials_entry, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<_ns1__login_credentials_entry>);
    if (size)
      *size = sizeof(std::vector<_ns1__login_credentials_entry>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<_ns1__login_credentials_entry>, n);
    if (size)
      *size = n * sizeof(std::vector<_ns1__login_credentials_entry>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<_ns1__login_credentials_entry> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns1__login_credentials_entry(struct soap *soap, int st,
                                                                                        int tt, void *p, size_t len,
                                                                                        const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns1__login_credentials_entry > %p -> %p\n", q, p));
  *(std::vector<_ns1__login_credentials_entry> *)p = *(std::vector<_ns1__login_credentials_entry> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap,
                                                                         std::vector<std::string> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap,
                                                                           const std::vector<std::string> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id,
                                                                    const std::vector<std::string> *a,
                                                                    const char *type) {
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_std__string(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> *SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap,
                                                                                         const char *tag,
                                                                                         std::vector<std::string> *a,
                                                                                         const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    std::string n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    soap_default_std__string(soap, &n);
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_std__string, SOAP_TYPE_ICat4_std__vectorTemplateOfstd__string,
                                     sizeof(std::string), 0))
        break;
      if (!soap_in_std__string(soap, tag, nullptr, "xsd:string"))
        break;
    } else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
      return nullptr;
    soap_update_pointers(soap, (char *)&n, (char *)&n + sizeof(n), (char *)&(*a->insert(a->end(), n)), (char *)&n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<std::string> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(
    struct soap *soap, int n, const char *type, const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n,
                            type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfstd__string, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<std::string>);
    if (size)
      *size = sizeof(std::vector<std::string>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<std::string>, n);
    if (size)
      *size = n * sizeof(std::vector<std::string>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<std::string> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p,
                                                                      size_t len, const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
  *(std::vector<std::string> *)p = *(std::vector<std::string> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(struct soap *soap, const std::vector<LONG64> *a) {
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, int id,
                                                               const std::vector<LONG64> *a, const char *type) {
  for (std::vector<LONG64>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_LONG64(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64> *SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag,
                                                                               std::vector<LONG64> *a,
                                                                               const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    LONG64 n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    soap_default_LONG64(soap, &n);
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(),
                                     SOAP_TYPE_ICat4_LONG64, SOAP_TYPE_ICat4_std__vectorTemplateOfLONG64,
                                     sizeof(LONG64), 0))
        break;
      if (!soap_in_LONG64(soap, tag, nullptr, "xsd:long"))
        break;
    } else if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<LONG64> *SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfLONG64(struct soap *soap, int n,
                                                                                        const char *type,
                                                                                        const char *arrayType,
                                                                                        size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n", n, type ? type : "",
                            arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfLONG64, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<LONG64>);
    if (size)
      *size = sizeof(std::vector<LONG64>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<LONG64>, n);
    if (size)
      *size = n * sizeof(std::vector<LONG64>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<LONG64> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(struct soap *soap, int st, int tt, void *p, size_t len,
                                                                 const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
  *(std::vector<LONG64> *)p = *(std::vector<LONG64> *)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__entityBaseBean(
    struct soap *soap, std::vector<ns1__entityBaseBean *> *p) {
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__entityBaseBean(
    struct soap *soap, const std::vector<ns1__entityBaseBean *> *a) {
#ifndef WITH_NOIDREF
  for (std::vector<ns1__entityBaseBean *>::const_iterator i = a->begin(); i != a->end(); ++i)
    soap_serialize_PointerTons1__entityBaseBean(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__entityBaseBean(
    struct soap *soap, const char *tag, int id, const std::vector<ns1__entityBaseBean *> *a, const char *type) {
  for (std::vector<ns1__entityBaseBean *>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_PointerTons1__entityBaseBean(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__entityBaseBean *> *SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__entityBaseBean(
    struct soap *soap, const char *tag, std::vector<ns1__entityBaseBean *> *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  short soap_flag;
  for (soap_flag = 0;; soap_flag = 1) {
    ns1__entityBaseBean *n;
    if (tag && *tag != '-') {
      if (soap_element_begin_in(soap, tag, 1, nullptr))
        break;
      soap_revert(soap);
    }
    n = nullptr;
    if (tag && *tag != '-' && (*soap->id || *soap->href)) {
      if (!soap_container_id_forward(
              soap, *soap->id ? soap->id : soap->href, a, (size_t)a->size(), SOAP_TYPE_ICat4_ns1__entityBaseBean,
              SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityBaseBean, sizeof(ns1__entityBaseBean), 1))
        break;
      if (!soap_in_PointerTons1__entityBaseBean(soap, tag, nullptr, "ns1:entityBaseBean"))
        break;
    } else if (!soap_in_PointerTons1__entityBaseBean(soap, tag, &n, "ns1:entityBaseBean"))
      break;
    if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__entityBaseBean(soap, -1)))
      return nullptr;
    a->push_back(n);
    if (!tag || *tag == '-')
      return a;
  }
  if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)) {
    soap->error = SOAP_OK;
    return a;
  }
  return nullptr;
}

SOAP_FMAC1 std::vector<ns1__entityBaseBean *> *SOAP_FMAC2
soap_instantiate_std__vectorTemplateOfPointerTons1__entityBaseBean(struct soap *soap, int n, const char *type,
                                                                   const char *arrayType, size_t *size) {
  (void)type;
  (void)arrayType; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                            "soap_instantiate_std__"
                            "vectorTemplateOfPointerTons1__"
                            "entityBaseBean(%d, %s, %s)\n",
                            n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp =
      soap_link(soap, nullptr, SOAP_TYPE_ICat4_std__vectorTemplateOfPointerTons1__entityBaseBean, n, ICat4_fdelete);
  if (!cp)
    return nullptr;
  if (n < 0) {
    cp->ptr = (void *)SOAP_NEW(std::vector<ns1__entityBaseBean *>);
    if (size)
      *size = sizeof(std::vector<ns1__entityBaseBean *>);
  } else {
    cp->ptr = (void *)SOAP_NEW_ARRAY(std::vector<ns1__entityBaseBean *>, n);
    if (size)
      *size = n * sizeof(std::vector<ns1__entityBaseBean *>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  if (!cp->ptr)
    soap->error = SOAP_EOM;
  return (std::vector<ns1__entityBaseBean *> *)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__entityBaseBean(struct soap *soap, int st,
                                                                                       int tt, void *p, size_t len,
                                                                                       const void *q, size_t n) {
  (void)soap;
  (void)tt;
  (void)st;
  (void)len;
  (void)n; /* appease -Wall -Werror */
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__entityBaseBean * > %p -> %p\n", q, p));
  *(std::vector<ns1__entityBaseBean *> *)p = *(std::vector<ns1__entityBaseBean *> *)q;
}

} // namespace ICat4

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of ICat4C.cpp */

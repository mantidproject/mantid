#ifndef COMPOSITE_IMPLICIT_FUNCTION_TEST_H_
#define COMPOSITE_IMPLICIT_FUNCTION_TEST_H_

#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <cxxtest/TestSuite.h>
#include <cmath>
#include <typeinfo>

#include "MantidGeometry/MDGeometry/CompositeImplicitFunction.h"
#include "MantidKernel/WarningSuppressions.h"

using namespace Mantid::Geometry;

class CompositeImplicitFunctionTest : public CxxTest::TestSuite {
private:
  // Fake ImplicitFunction to verify abstract treatement of nested functions by
  // composite.
  class MockImplicitFunction : public Mantid::Geometry::MDImplicitFunction {
  public:
    GNU_DIAG_OFF_SUGGEST_OVERRIDE
    MOCK_CONST_METHOD0(toXMLString, std::string());
    MOCK_CONST_METHOD0(getName, std::string());
    MOCK_METHOD1(isPointContained, bool(const Mantid::coord_t *coords));
    GNU_DIAG_ON_SUGGEST_OVERRIDE
    bool isPointContained(const std::vector<Mantid::coord_t> &) override {
      return true;
    }
    // Unhide base class methods (avoids Intel compiler warning)
    using MDImplicitFunction::isPointContained;
    ~MockImplicitFunction() override {}
  };

public:
  void testFunctionAddition() {
    CompositeImplicitFunction composite;
    composite.addFunction(
        Mantid::Geometry::MDImplicitFunction_sptr(new MockImplicitFunction()));
    composite.addFunction(
        Mantid::Geometry::MDImplicitFunction_sptr(new MockImplicitFunction()));
    TSM_ASSERT_EQUALS("Two functions should have been added to composite", 2,
                      composite.getNFunctions());
  }

  void testEvaluateNestedFunctionsViaCoordinates() {
    using namespace testing;

    CompositeImplicitFunction composite;
    MockImplicitFunction *a = new MockImplicitFunction;
    MockImplicitFunction *b = new MockImplicitFunction;
    EXPECT_CALL(*a, isPointContained(_))
        .Times(1)
        .WillOnce(testing::Return(true));
    EXPECT_CALL(*b, isPointContained(_)).Times(1);

    composite.addFunction(Mantid::Geometry::MDImplicitFunction_sptr(a));
    composite.addFunction(Mantid::Geometry::MDImplicitFunction_sptr(b));

    Mantid::coord_t coord[3] = {0, 0, 0};
    composite.isPointContained(coord);
    TSM_ASSERT("This nested function should have been executed",
               testing::Mock::VerifyAndClearExpectations(a));
    TSM_ASSERT("This nested function should have been executed",
               testing::Mock::VerifyAndClearExpectations(b));
  }

  void testRecursiveToXML() {
    MockImplicitFunction *mockFunctionA = new MockImplicitFunction;
    MockImplicitFunction *mockFunctionB = new MockImplicitFunction;

    EXPECT_CALL(*mockFunctionA, toXMLString())
        .Times(1)
        .WillOnce(testing::Return("<Function></Function>"));
    EXPECT_CALL(*mockFunctionB, toXMLString())
        .Times(1)
        .WillOnce(testing::Return("<Function></Function>"));

    CompositeImplicitFunction function;
    function.addFunction(
        Mantid::Geometry::MDImplicitFunction_sptr(mockFunctionA));
    function.addFunction(
        Mantid::Geometry::MDImplicitFunction_sptr(mockFunctionB));

    TSM_ASSERT_EQUALS(
        "The xml generated by this function did not match the expected schema.",
        "<Function><Type>CompositeImplicitFunction</Type><ParameterList/"
        "><Function></Function><Function></Function></Function>",
        function.toXMLString());
  }

  void testCannotAddNullDimension() {
    CompositeImplicitFunction function;

    MockImplicitFunction *nullFunction = nullptr;
    TSM_ASSERT("A null function cannot be added to a function of type "
               "CompositeFunction",
               !function.addFunction(
                   Mantid::Geometry::MDImplicitFunction_sptr(nullFunction)));
  }
};

#endif

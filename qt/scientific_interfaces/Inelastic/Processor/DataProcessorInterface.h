// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2010 ISIS Rutherford Appleton Laboratory UKRI,
//   NScD Oak Ridge National Laboratory, European Spallation Source,
//   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
// SPDX - License - Identifier: GPL - 3.0 +
#pragma once
#include "ui_DataProcessorInterface.h"

#include "DataProcessor.h"
#include "MantidGeometry/IComponent.h"
#include "MantidQtWidgets/Common/AlgorithmRunner.h"
#include "MantidQtWidgets/Common/QtJobRunner.h"
#include "MantidQtWidgets/Spectroscopy/InelasticInterface.h"

#include <string>
#include <unordered_map>

#include <QRegExp>
#include <QScrollArea>

namespace MantidQt {
namespace CustomInterfaces {

class DataProcessor;

/**
This class defines the InelasticDataProcessor interface. It handles the overall
instrument settings
and sets up the appropriate interface depending on the deltaE mode of the
instrument. The deltaE
mode is defined in the instrument definition file using the "deltaE-mode".
*/

class DataProcessorInterface : public InelasticInterface {
  Q_OBJECT

public:
  /// Default Constructor
  explicit DataProcessorInterface(QWidget *parent = nullptr);
  /// Destructor
  ~DataProcessorInterface() override;
  /// Interface name
  static std::string name() { return "Data Processor"; }
  // This interface's categories.
  static QString categoryInfo() { return "Inelastic"; }

  /// Initialize the layout
  void initLayout() override;

signals:
  /// Emitted when the instrument setup is changed
  void newInstrumentConfiguration();

private slots:

  /// Exports the current tab algorithms as a Python script
  void exportTabPython();

  /// Called when the load instrument algorithms complete
  void instrumentLoadingDone(bool error);

private:
  std::string documentationPage() const override;

  void applySettings(std::map<std::string, QVariant> const &settings) override;

  QString getInstrumentParameterFrom(const Mantid::Geometry::IComponent_const_sptr &comp, const std::string &param);

  /**
   * Adds an MVP tab to the cache of tabs that can be shown.
   *
   * This method is used to ensure that the tabs are always loaded and their
   * layouts setup for the sake of screenshoting them for documentation.
   *
   * @param name Name to be displayed on tab
   */

  template <typename TabPresenter, typename TabView, typename TabModel> void addMVPTab(const std::string &name) {
    QWidget *tabWidget = new QWidget(m_uiForm.twIDRTabs);
    QVBoxLayout *tabLayout = new QVBoxLayout(tabWidget);
    tabWidget->setLayout(tabLayout);

    QScrollArea *tabScrollArea = new QScrollArea(tabWidget);
    tabLayout->addWidget(tabScrollArea);
    tabScrollArea->setWidgetResizable(true);

    QWidget *tabContent = new QWidget(tabScrollArea);
    tabContent->setObjectName("tab" + QString::fromStdString(name).remove(QRegExp("[ ,()]")));
    tabScrollArea->setWidget(tabContent);
    tabScrollArea->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    auto jobRunner = std::make_unique<MantidQt::API::QtJobRunner>();
    auto algorithmRunner = std::make_unique<MantidQt::API::AlgorithmRunner>(std::move(jobRunner));

    std::unique_ptr<TabModel> tabModel = std::make_unique<TabModel>();
    auto presenter = std::make_unique<TabPresenter>(tabContent, std::move(algorithmRunner), new TabView(tabContent),
                                                    std::move(tabModel));

    tabContent->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    m_presenters[name] = std::move(presenter);

    // Add all tabs to UI initially
    m_uiForm.twIDRTabs->addTab(tabWidget, QString::fromStdString(name));
  }

  /// The .ui form generated by Qt Designer
  Ui::DataProcessorInterface m_uiForm;

  /// A map to hold the presenter corresponding to each tab
  std::unordered_map<std::string, std::unique_ptr<IDataProcessor>> m_presenters;
};

} // namespace CustomInterfaces
} // namespace MantidQt

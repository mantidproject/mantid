// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2010 ISIS Rutherford Appleton Laboratory UKRI,
//   NScD Oak Ridge National Laboratory, European Spallation Source,
//   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
// SPDX - License - Identifier: GPL - 3.0 +
#pragma once
#include "ui_DataManipulationInterface.h"

#include "Common/InelasticInterface.h"
#include "DataManipulation.h"

#include "MantidGeometry/IComponent.h"

#include <QRegExp>
#include <QScrollArea>

namespace MantidQt {
namespace CustomInterfaces {

class DataManipulation;

/**
This class defines the InelasticDataManipulation interface. It handles the overall
instrument settings
and sets up the appropriate interface depending on the deltaE mode of the
instrument. The deltaE
mode is defined in the instrument definition file using the "deltaE-mode".
*/

class DataManipulationInterface : public InelasticInterface {
  Q_OBJECT

public:
  /// Default Constructor
  explicit DataManipulationInterface(QWidget *parent = nullptr);
  /// Destructor
  ~DataManipulationInterface() override;
  /// Interface name
  static std::string name() { return "Data Manipulation"; }
  // This interface's categories.
  static QString categoryInfo() { return "Inelastic"; }

  /// Initialize the layout
  void initLayout() override;
  /// Run Python-based initialisation commands
  void initLocalPython() override;

signals:
  /// Emitted when the instrument setup is changed
  void newInstrumentConfiguration();

private slots:
  /// Shows/hides tabs based on facility
  void filterUiForFacility(const QString &facility);

  /// Exports the current tab algorithms as a Python script
  void exportTabPython();

  /// Called when the load instrument algorithms complete
  void instrumentLoadingDone(bool error);

private:
  std::string documentationPage() const override;

  void applySettings(std::map<std::string, QVariant> const &settings) override;

  QString getInstrumentParameterFrom(const Mantid::Geometry::IComponent_const_sptr &comp, const std::string &param);

  /// Set and show an instrument-specific widget
  void closeEvent(QCloseEvent *close) override;

  /**
   * Adds an MVP tab to the cache of tabs that can be shown.
   *
   * This method is used to ensure that the tabs are always loaded and their
   * layouts setup for the sake of screenshoting them for documentation.
   *
   * @param name Name to be displayed on tab
   */

  template <typename TabPresenter, typename TabView, typename TabModel> void addMVPTab(const QString &name) {
    QWidget *tabWidget = new QWidget(m_uiForm.twIDRTabs);
    QVBoxLayout *tabLayout = new QVBoxLayout(tabWidget);
    tabWidget->setLayout(tabLayout);

    QScrollArea *tabScrollArea = new QScrollArea(tabWidget);
    tabLayout->addWidget(tabScrollArea);
    tabScrollArea->setWidgetResizable(true);

    QWidget *tabContent = new QWidget(tabScrollArea);
    tabContent->setObjectName("tab" + QString(name).remove(QRegExp("[ ,()]")));
    tabScrollArea->setWidget(tabContent);
    tabScrollArea->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    std::unique_ptr<TabModel> tabModel = std::make_unique<TabModel>();

    DataManipulation *tabIDRContent = new TabPresenter(tabContent, new TabView(tabContent), std::move(tabModel));

    tabIDRContent->setupTab();
    tabContent->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    connect(tabIDRContent, SIGNAL(showMessageBox(const QString &)), this, SLOT(showMessageBox(const QString &)));

    // Add to the cache
    m_tabs[name] = qMakePair(tabWidget, tabIDRContent);

    // Add all tabs to UI initially
    m_uiForm.twIDRTabs->addTab(tabWidget, name);
  }

  friend class DataManipulation;
  /// The .ui form generated by Qt Designer
  Ui::DataManipulationInterface m_uiForm;

  // All indirect tabs
  QMap<QString, QPair<QWidget *, DataManipulation *>> m_tabs;
  QString m_dataDir; ///< default data search directory
  QString m_saveDir; ///< default data save directory
};

} // namespace CustomInterfaces
} // namespace MantidQt

// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2012 ISIS Rutherford Appleton Laboratory UKRI,
//     NScD Oak Ridge National Laboratory, European Spallation Source
//     & Institut Laue - Langevin
// SPDX - License - Identifier: GPL - 3.0 +
#ifndef MANTIDQTCUSTOMINTERFACES_DYNAMICPDF_FITCONTROL_H_
#define MANTIDQTCUSTOMINTERFACES_DYNAMICPDF_FITCONTROL_H_

// Mantid Coding standars <http://www.mantidproject.org/Coding_Standards>
// Mantid Headers from the same project
#include "ui_DPDFFitControl.h"
// Mantid headers from other projects
#include "DllConfig.h"
#include "MantidAPI/IFunction.h"
// 3rd party library headers
#include <QWidget>
// System headers

// Forward Declarations
class QAction;
class QMenu;
namespace Mantid {
namespace API {
class IFunction;
}
} // namespace Mantid
namespace MantidQt {
namespace API {
class AlgorithmRunner;
}
namespace MantidWidgets {
class FunctionBrowser;
class FitOptionsBrowser;
} // namespace MantidWidgets
namespace CustomInterfaces {
namespace DynamicPDF {
class BackgroundRemover;
class DPDFFitOptionsBrowser;
class InputDataControl;
class DisplayControl;
} // namespace DynamicPDF
} // namespace CustomInterfaces
} // namespace MantidQt

namespace MantidQt {
namespace CustomInterfaces {
namespace DynamicPDF {

/** An interface to manage models and options for fitting

  @date 2016-03-22
*/
class MANTIDQT_DYNAMICPDF_DLL FitControl : public QWidget {
  Q_OBJECT

  friend class BackgroundRemover;

public:
  FitControl(QWidget *parent = nullptr);
  ~FitControl();

public slots:
  int getNumberOfSpectra() const;

signals:
  /**
   * @brief signals the end of the model evaluation
   * @param modelWorkspaceName workspace containing data,
   * evaluation, and residuals
   */
  void signalModelEvaluationFinished(const QString &modelWorkspaceName);

private slots:
  void updateFitRangeFromDisplayControl();
  void updateFitRangeSelector(const QString &propertyName);
  void fit();
  void finishIndividualFit(bool error);
  void slotEvaluateModel(const QString &, const QString &);
  void finishModelEvaluation(bool error);
  void updateFunctionBrowserWithBuiltInModel(const QString &modelName);

private:
  void initLayout();
  void setConnections();
  bool isSliceSelectedForFitting();
  void setInputDataControl(InputDataControl *inputDataControl);
  void setDisplayControl(DisplayControl *displayControl);
  void fitSequential();
  void fitSimultaneous();
  void fitIndividual(const bool &isEvaluation = false);
  void updateFunctionBrowser(Mantid::API::IFunction_sptr fun);
  void updateFunctionBrowser(const QString &directory,
                             const QString &modelName);
  void initBuiltInModels();
  void saveBuiltInModels();
  void loadBuiltInModels(QMenu *menuBuiltIn);
  void initCustomModels();

  /// The form generated by Qt Designer
  Ui::FitControl m_uiForm;
  /// Define the fitting model
  MantidQt::MantidWidgets::FunctionBrowser *m_functionBrowser;
  /// Define options for the fitting procedure
  DPDFFitOptionsBrowser *m_fitOptionsBrowser;
  /// object handling all input slices
  InputDataControl *m_inputDataControl;
  /// object handline the display of the curves
  DisplayControl *m_displayControl;
  /// Fit algorithm runner
  std::unique_ptr<MantidQt::API::AlgorithmRunner> m_fitRunner;

  /// Workspace root name for individual fit
  const std::string m_individualFitName;
  /// Workspace root name for model evaluation
  const std::string m_modelEvaluationName;

}; // class FitControl
} // namespace DynamicPDF
} // namespace CustomInterfaces
} // namespace MantidQt
#endif // MANTIDQTCUSTOMINTERFACES_DYNAMICPDF_FITCONTROL_H_

.. algorithm::

.. summary::

.. alias::

.. properties::

Description
-----------

This algorithm is able to generate event splitters according to user's
requirement for filtering events. The generated time splitters are
stored either in a `SplittersWorkspace <http://www.mantidproject.org/SplittersWorkspace>`_ or a
:ref:`MatrixWorkspace <MatrixWorkspace>`. Both of them will be used by
algorithm :ref:`FilterEvents <algm-FilterEvents>`
to filter events from an
:ref:`EventWorkspace <EventWorkspace>`.

This algorithm is designed as a general-purposed event splitter
generator. Combined with :ref:`FilterEvents <algm-FilterEvents>`,
it will replace

-  :ref:`FilterByTime <algm-FilterByTime>`
-  :ref:`FilterByLogValue <algm-FilterByLogValue>`

Moreover, the time resolution of these two algorithms is microseconds,
i.e., the wall time of an (neutron) event. While the original
:ref:`FilterByTime <algm-FilterByTime>`
and
:ref:`FilterByLogValue <algm-FilterByLogValue>`
are of the resolution of pulse time. It is also enhanced to process the fast
frequency sample logs, which can be even faster than chopper frequencies.

Workspace to store event splitters
##################################

An event splitter used in Mantid contains start time, stop time and
target workspace. Any data structure that has the above 3 properties can
serve as an event splitter. There are two types of output workspaces for storing
event splitters that are supported by this algorithm.

-  `SplittersWorkspace <http://www.mantidproject.org/SplittersWorkspace>`_: It is a
   `TableWorkspace <http://www.mantidproject.org/TableWorkspace>`_ that has 3 columns for start
   time, stop time and target workspace for events within start time and
   stop time. This type of workspace is appropriate for the case that
   the amount of generated event splitters are not huge;
-  :ref:`MatrixWorkspace <MatrixWorkspace>`: It uses X-axis to store time
   stamp in total nanoseconds and Y-axis to store target workspace. For
   example, x\_i, x\_i+1 and y\_i construct an event filter as start
   time is x\_i, stop time is x\_i+1, and target workspace is y\_i-th
   workspace. If y\_i is less than 0, then it means that all events
   between time x\_i and x\_i+1 will be discarded. This type of
   workspace is appropriate for the case that the amount of generated
   event splitters are huge, because processing a
   :ref:`MatrixWorkspace <MatrixWorkspace>` is way faster than a
   `TableWorkspace <http://www.mantidproject.org/TableWorkspace>`_ in Mantid.

Functionalities
###############

Here are the types of event filters (i.e.,
`SplittersWorkspace <http://www.mantidproject.org/SplittersWorkspace>`_) that can be generated by
this algorithm:

-  A filter for one time interval.

-  A series of filters for multiple continuous time intervals, which
   have the same length of period. Each of them has an individual
   workspace index associated. These workspace indices are incremented
   by 1 from 0 along with their orders in time.

-  A series of filters for multiple continuous time intervals, which
   have various lengths of period.  
   Each of them has an individual workspace index associated. 
   These workspace indices are incremented by 1 from 0 along with their
   order in time. 

-  A filter containing one or multiple time intervals according to a
   specified log value. Any log value of the time that falls into the
   selected time intervals is equal or within the tolerance of a user
   specified value.

-  A series filters containing one or multiple time intervals according
   to specified log values incremented by a constant value. Any log
   value of the time that falls into the selected time intervals is
   equal or within the tolerance of the log value as v\_0 + n x delta\_v
   +/- tolerance\_v.

Generate event filters by time
==============================

Event filters can be created by defining start and stop time and time intervals. 
The three input properties used are *StartTime*, *StopTime* and *TimeInterval*. 
*TimeInterval* accepts an array of doubles. 

If the array size is zero, then there will be one and only splitter will be 
created from *StartTime* and *StopTime*. 

If the size of the array is one, then all event splitters will have the same duration
of time. 

In general if the array is composed as :math:`t_1, t_2, \cdots, t_n`, 
and :math:`T_0` is the run start time, 
then the event splitters will have the time boudaries as 

.. math:: (T_0, T_0+t_1), (T_0+t_1, T_0+t_1+t_2), \cdots, (T_0+\sum_{i=1}^(n-1)t_i, T_0+\sum_{i=1}^nt_i), (T_0+\sum_{i=1}^nt_i, T_0+\sum_{i=1}^nt_i+t_1), \cdots

until the stop time is reached. 

Unit of time
############

There are three types of units that are supported for time. 
They are second, nanosecond and percentage of duration from *StartTime* to *StopTime*. 


Generate event filters by sample log value
==========================================

The sample log will be divided to intervals as :math:`v_0, v_1, \cdots, v_{i-1}, v_i, v_{i+1}, \cdots`. 
All log entries, whose values falls into range :math:`[v_j, v_{j+1})`, will be assigned to
a same workspace group. 


About how log value is recorded
###############################

SNS DAS records log values upon its changing. The frequency of log
sampling is significantly faster than change of the log, i.e., sample
environment devices. Therefore, it is reasonable to assume that all the
log value changes as step functions.

The option to do interpolation is not supported at this moment.

Comparison to FilterByLogValue
##############################

1. If the first log value is within the specified range and the first
log time is after run star time, FilterByLogValue assumes that the log
value before the first recorded log time is also within range, and thus
the first splitter starts from the run star time, while
:ref:`GenerateEventsFilter <algm-GenerateEventsFilter>`
tends to be more conservative, and thus the first
splitter will start from the first log time.

2. FilterByLogValue only filters events at the resolution of pulse time,
while :ref:`GenerateEventsFilter <algm-GenerateEventsFilter>` can improve the
resolution to 1 microsecond.

Algorithm Parameters and Examples
---------------------------------

Here are the introductions to some important parameters (i.e., algorithm's properties). 


Parameter: *Centre*
###################

The input Boolean parameter *centre* is for filtering by log value(s).
If option *centre* is taken, then for each interval,

-  starting time = log\_time - tolerance\_time;
-  stopping time = log\_time - tolerance\_time;

It is a shift to left.

Parameter: *MinimumLogValue*, *MaximumLogValue*, *LogValueTolerance* and *LogValueInterval*
###########################################################################################

These four parameters are used to determine the log value intervals for
filtering events.

Double value log
================

Let user-specified minimum log value to be :math:`L_{min}`, 
LogValueTolerance to be :math:`t`, and LogValueInterval to be :math:`\delta`, 
then the log value intervals are 

.. math:: [L_{min}-t, L_{min}-tol+\delta), [L_{min}-tol+\delta, L_{min}-tol+2\cdot\delta), \cdots

The default value of LogValueTolerance is LogValueInterval divided by 2.

Integer value log
=================

It is a little bit different for sample log recorded with integer. 

- *MinimumLogValue* and *MaximumLogValue* can be same such that only entries with exacly the same log value 
  will be considered;
- If *LogValueInterval* is not give (i.e., default value is used), then any log enetry with log value
  larger and equal to *MinimumLogValue* and smaller and equal to *MaximumLogValue* will be considered. 
  Be noticed that in the same case for double value log, log entry with value equal to *MaximumLogValue*
  will be excluded. 



Example: Filter by double log value from :math:`s_0` to :math:`s_f`
###################################################################

There are two setup to acquire the same result: 

- Use single-log-value mode:

  - MinimumLogValue = :math:`s_0`
  - MaximumLogValue = :math:`s_f`
  - LogValueInterval is left to default
  
- Use multiple-log-value mode:

  - MinimumLogValue = :math:`s_0`
  - MaximumLogValue = :math:`s_f`
  - LogValueInterval = :math:`s_f - s_0`
  - LogValueTolerance = 0
  



Usage
-----

.. include:: ../usagedata-note.txt

The following is a contrived example to show how one would use the algorithm to split
up an :ref:`EventWorkspace <EventWorkspace>` by a temperature
log. The resulting workspaces would then be fed to
:ref:`FilterEvents <algm-FilterEvents>`
for further processing.

.. testcode:: Ex

    ws = Load("CNCS_7860_event.nxs")
    # The InformationWorkspace name is mandatory
    ws2 = GenerateEventsFilter(ws, InformationWorkspace="info", UnitOfTime="Nanoseconds",
                               Logname="SampleTemp", MinimumLogValue=279.9, MaximumLogValue=279.98,
                               LogValueInterval=0.01)
    # The first workspace is the SplittersWorkspace and the second is the InformationWorkspace
    print "Number of workspaces =", len(ws2)
    print "First workspace type =", ws2[0].id()
    print "Second workspace type =", ws2[1].id()
    print "Number of columns in first TableWorkspace =", ws2[0].columnCount()
    print "Number of rows in first TableWorkspace =", ws2[0].rowCount()
    print "Number of columns in second TableWorkspace =", ws2[1].columnCount()
    print "Number of rows in second TableWorkspace =", ws2[1].rowCount()

Output:

.. testoutput:: Ex

    Number of workspaces = 2
    First workspace type = TableWorkspace
    Second workspace type = TableWorkspace
    Number of columns in first TableWorkspace = 3
    Number of rows in first TableWorkspace = 6
    Number of columns in second TableWorkspace = 2
    Number of rows in second TableWorkspace = 9

.. categories::

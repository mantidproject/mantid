/*WIKI*

Reads a McStas Event NeXus file into a Mantid WorkspaceGroup with a user-supplied name. Data generated by the McStas component monitor_nD is stored in workspaces of type [[event]]. 

This algorithm is under development. Currently is it only possible to read data from one detector. The McStas component monitor_nD must be called with the argument: options ="mantid square x limits=[-0.2 0.2] bins=128 y limits=[-0.2 0.2] bins=128, neutron pixel t, list all neutrons".  Number of bins and limits can be chosen freely. 

To generate McStas event data and the corresponding IDF for Mantid run the following commands from an xterm:

- export MCSTAS_CFLAGS="-g -lm -O2 -DUSE_NEXUS -lNeXus"
- mcrun -c templateSANS.instr --format=NeXus -n0
- ./mcdisplay templateSANS.instr -n0 --format=Mantid
- cp templateSANS.out.xml IDF.xml
- mcrun templateSANS --format=NeXus

For more information about McStas and its general usage for simulating neutron scattering instruments and experiments visit the McStas homepage http://www.mcstas.org.


*WIKI*/


#include "MantidDataHandling/LoadMcStasEventNexus.h"
#include "MantidAPI/FileProperty.h"
#include "MantidAPI/WorkspaceFactory.h"
#include "MantidAPI/WorkspaceGroup.h"
#include "MantidAPI/IEventWorkspace.h"
#include "MantidKernel/Unit.h"
#include <nexus/NeXusFile.hpp>
#include "MantidAPI/AlgorithmManager.h"
#include "MantidGeometry/Instrument.h"
#include "MantidGeometry/Instrument/InstrumentDefinitionParser.h"
#include "MantidAPI/InstrumentDataService.h"
#include "MantidDataHandling/LoadEventNexus.h"
#include "MantidKernel/UnitFactory.h"
#include "MantidAPI/RegisterFileLoader.h"

namespace Mantid
{
namespace DataHandling 
{
  using namespace Kernel;
  using namespace API;
  using namespace DataObjects;

  // Register the algorithm into the AlgorithmFactory
  DECLARE_HDF_FILELOADER_ALGORITHM(LoadMcStasEventNexus);


  //----------------------------------------------------------------------------------------------
  /** Constructor
   */
  LoadMcStasEventNexus::LoadMcStasEventNexus()
  {
  }
    
  //----------------------------------------------------------------------------------------------
  /** Destructor
   */
  LoadMcStasEventNexus::~LoadMcStasEventNexus()
  {
  }
  

  //----------------------------------------------------------------------------------------------
  /// Algorithm's name for identification. @see Algorithm::name
  const std::string LoadMcStasEventNexus::name() const { return "LoadMcStasEventNexus";};
  
  /// Algorithm's version for identification. @see Algorithm::version
  int LoadMcStasEventNexus::version() const { return 1;};
  
  /// Algorithm's category for identification. @see Algorithm::category
  const std::string LoadMcStasEventNexus::category() const { return "DataHandling";}

  //----------------------------------------------------------------------------------------------
  /// Sets documentation strings for this algorithm
  void LoadMcStasEventNexus::initDocs()
  {
    this->setWikiSummary("This algorithm loads a McStas Event NeXus file into an event workspace.");
    this->setOptionalMessage("Loads a McStas Event NeXus file into an event workspace.");
  }

  //----------------------------------------------------------------------------------------------
  /** Initialize the algorithm's properties.
   */
  void LoadMcStasEventNexus::init()
  {
    std::vector<std::string> exts;
    exts.push_back(".h5");
    exts.push_back(".nxs");
    declareProperty(new FileProperty("Filename", "", FileProperty::Load, exts),
        "The name of the Nexus file to load" );
        
    declareProperty(new WorkspaceProperty<Workspace>("OutputWorkspace","",Direction::Output), "An output workspace.");
  }

  //----------------------------------------------------------------------------------------------
  /** Execute the algorithm.
   */
  void LoadMcStasEventNexus::exec()
  {
    std::string filename = getPropertyValue("Filename");
    g_log.debug() << "Opening file " << filename << std::endl;
        
    ::NeXus::File nxFile(filename);
    auto entries = nxFile.getEntries();
    auto itend = entries.end();
    size_t workspaceCount(0);
    std::string prefix = getPropertyValue("OutputWorkspace");
    WorkspaceGroup_sptr outputGroup(new WorkspaceGroup);


    // here loop over all top level Nexus entries
    // HOWEVER IF IT IS KNOWN THAT MCSTAS NEXUS ONLY EVER HAVE ONE TOP LEVEL ENTRY
    // THIS LOOP CAN BE REMOVED
    for(auto it = entries.begin(); it != itend; ++it)
    {
      std::string name = it->first;
      std::string type = it->second;
      nxFile.openGroup(name, type);
      auto dataEntries = nxFile.getEntries();


      // will assume that each top level entry contain one mcstas
      // generated IDF and any event data entries within this top level
      // entry are data collected for that instrument
      // This code for loading the instrument is for now adjusted code from
      // ExperimentalInfo. 
      Geometry::Instrument_sptr instrument;
      try
      {
        nxFile.openGroup("instrument", "NXinstrument");
        std::string instrumentXML;
        nxFile.openGroup("instrument_xml", "NXnote");
        nxFile.readData("data", instrumentXML );
        nxFile.closeGroup();
        nxFile.closeGroup();

        Geometry::InstrumentDefinitionParser parser;
        std::string instrumentName = "McStas";
        parser.initialize(filename, instrumentName, instrumentXML);
        std::string instrumentNameMangled = parser.getMangledName();

        // Check whether the instrument is already in the InstrumentDataService
        if ( InstrumentDataService::Instance().doesExist(instrumentNameMangled) )
        {
          // If it does, just use the one from the one stored there
          instrument = InstrumentDataService::Instance().retrieve(instrumentNameMangled);
        }
        else
        {
        // Really create the instrument
          instrument = parser.parseXML(NULL);
          // Add to data service for later retrieval
          InstrumentDataService::Instance().add(instrumentNameMangled, instrument);
        }
      }
      catch(...)
      {
        throw std::runtime_error("Could not find the instrument description in the Nexus file: " + filename + ". Cannot load McStas data!");
      }  


      // here loop over all 2nd level entries
      for(auto eit = dataEntries.begin(); eit != dataEntries.end(); ++eit)
      {
        std::string dataName = eit->first;
        std::string dataType = eit->second;
        if( dataName == "content_nxs" || dataType != "NXdata" ) continue;
        g_log.debug() << "Opening " << dataName << "   " << dataType << std::endl;


        // read the data you need from this nexus entry
        nxFile.openGroup(dataName, dataType);
        std::vector<double> data;

        // Find the Neutron_ID tag from McStas event data
        // Each event detector has the nexus attribute: 
        // @long_name = data ' Intensity Position Position Neutron_ID Velocity Time_Of_Flight Monitor (Square)'
        // if Neutron_ID present we have event data

        auto nxdataEntries = nxFile.getEntries();

        for(auto nit = nxdataEntries.begin(); nit != nxdataEntries.end(); ++nit)
        {
          if(nit->second == "NXparameters") continue;
          nxFile.openData(nit->first);
          if(nxFile.hasAttr("long_name") )
          {
            std::string nameAttrValue;
            nxFile.getAttr("long_name", nameAttrValue);

            std::string str         = nameAttrValue;
            std::string str2        = "Neutron_ID";
            std::size_t found       = str.find(str2);

            if (found!=std::string::npos)
            {
              nxFile.openData("data");
              nxFile.getData(data);
            }
          }
          nxFile.closeData();
        }

        nxFile.closeGroup(); // close event data 


        // create and prepare an event workspace ready to receive the mcstas events
        EventWorkspace_sptr eventWS(new EventWorkspace());
        // initialize, where create up front number of eventlists = number of detectors
        eventWS->initialize(instrument->getNumberDetectors(),1,1);
        // Set the units
        eventWS->getAxis(0)->unit() = UnitFactory::Instance().create("TOF");
        eventWS->setYUnit("Counts");
        // set the instrument
        eventWS->setInstrument(instrument);
        // assign detector ID to eventlists
        std::vector<detid_t> detIDs = instrument->getDetectorIDs();
        for (auto i = 0; i < instrument->getNumberDetectors(); i++)
        {
          eventWS->getEventList(i).addDetectorID(detIDs[i]);
          // spectrum number are treated as equal to detector IDs for McStas data
          eventWS->getEventList(i).setSpectrumNo(detIDs[i]);  
        }
        // the one is here for the moment for backward compatibility
        eventWS->rebuildSpectraMapping(true);


        // Need to take into account that the nexus readData method reads a multi-column data entry
        // into a vector  
        // The number of data column for each neutron is here hardcoded to (p, x,  y,  n, id, t)
        // Thus  we have
        // column  0 : p 	neutron wight
        // column  1 : x 	x coordinate
        // column  2 : y 	y coordinate
        // column  3 : n 	accumulated number of neutrons
        // column  4 : id 	pixel id
        // column  5 : t 	time


        size_t numberOfDataColumn = 6;
        // The number of neutrons 
        size_t nNeutrons = data.size() / numberOfDataColumn;

        // to store shortest and longest recorded TOF
        double shortestTOF; 
        double longestTOF;

        // populate workspace with McStas events          
        detid2index_map* detIDtoWSindex_map =	eventWS->getDetectorIDToWorkspaceIndexMap(true); 
        for (size_t in = 0; in < nNeutrons; in++)
        {   
          const int detectorID = static_cast<int>(data[4+numberOfDataColumn*in]);
          const double detector_time =  data[5+numberOfDataColumn*in] * 1.0e6;  // convert to microseconds
          if ( in == 0 )
          {
            shortestTOF = detector_time;
            longestTOF = detector_time;
          }
          else
          {
            if ( detector_time < shortestTOF )
              shortestTOF = detector_time;
            if ( detector_time > longestTOF )
              longestTOF = detector_time;
          }

          size_t workspaceIndex = (*detIDtoWSindex_map)[detectorID]; 
          int64_t pulse_time = 0;
          //eventWS->getEventList(workspaceIndex) += TofEvent(detector_time,pulse_time);
          //eventWS->getEventList(workspaceIndex) += TofEvent(detector_time);
          eventWS->getEventList(workspaceIndex) += WeightedEvent(detector_time, pulse_time, data[numberOfDataColumn*in], 1.0);
        }		      


        // Create a default TOF-vector for histogramming, for now just 2 bins
        // 2 bins is the standard. However for McStas simulation data it may make sense to 
        // increase this number for better initial visual effect
        Kernel::cow_ptr<MantidVec> axis;
        MantidVec& xRef = axis.access();
        xRef.resize(2,0.0);
        if ( nNeutrons > 0)
        {
          xRef[0] = shortestTOF - 1; //Just to make sure the bins hold it all
          xRef[1] = longestTOF + 1;
        }
        // Set the binning axis
        eventWS->setAllX(axis);

        outputGroup->addWorkspace(eventWS);


      }  // finish loop over 2nd level nexus entries

      nxFile.closeGroup(); // close a top level entry



    } // finished going through entries   

    setProperty("OutputWorkspace", outputGroup);
  }
  


  /**
   * Return the confidence with with this algorithm can load the file
   * @param descriptor A descriptor for the file
   * @returns An integer specifying the confidence level. 0 indicates it will not be used
   */
  int LoadMcStasEventNexus::confidence(Kernel::HDFDescriptor & descriptor) const
  {
    UNUSED_ARG(descriptor)
    // Not implemented yet therefore return no confidence
	  int confidence(0);
	  return confidence;
  }

} // namespace DataHandling
} // namespace Mantid
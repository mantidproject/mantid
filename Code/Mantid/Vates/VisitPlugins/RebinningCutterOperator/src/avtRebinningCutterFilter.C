/*****************************************************************************
 *
 * Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
 * Produced at the Lawrence Livermore National Laboratory
 * LLNL-CODE-442911
 * All rights reserved.
 *
 * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
 * full copyright notice is contained in the file COPYRIGHT located at the root
 * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
 *
 * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of  source code must  retain the above  copyright notice,
 *    this list of conditions and the disclaimer below.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
 * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
 * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
 * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
 * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
 * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
 * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 *****************************************************************************/

// ************************************************************************* //
//  File: avtRebinningCutterFilter.C
// ************************************************************************* //

#include <avtRebinningCutterFilter.h>
#include <DebugStream.h>
#include <vtkVisItClipper.h>
#include <vtkCharArray.h>
#include <vtkFieldData.h>
#include <vtkDataSet.h>
#include <vtkCellData.h>
#include <avtExtents.h>
#include <avtDatasetVerifier.h>
#include "MantidMDAlgorithms/PlaneImplicitFunction.h"
#include "MantidMDAlgorithms/BoxImplicitFunction.h"
#include "MantidMDAlgorithms/NullImplicitFunction.h"
#include "MantidVisitPresenters/RebinningCutterXMLDefinitions.h"
#include "MantidVisitPresenters/vtkStructuredGridFactory.h"
#include "MantidVisitPresenters/vtkThresholdingUnstructuredGridFactory.h"
#include "MantidVisitPresenters/vtkProxyFactory.h"
#include "boost/functional/hash.hpp"
#include <sstream>
#include "VisITProgressAction.h"

using namespace Mantid::VATES;

// ****************************************************************************
//  Method: avtRebinningCutterFilter constructor
//
//  Programmer: spu92482 -- generated by xml2avt
//  Creation:   Fri Sep 24 18:04:29 PST 2010
//
// ****************************************************************************

avtRebinningCutterFilter::avtRebinningCutterFilter() :
  m_presenter()
{
}

// ****************************************************************************
//  Method: avtRebinningCutterFilter destructor
//
//  Programmer: spu92482 -- generated by xml2avt
//  Creation:   Fri Sep 24 18:04:29 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtRebinningCutterFilter::~avtRebinningCutterFilter()
{

}

// ****************************************************************************
//  Method:  avtRebinningCutterFilter::Create
//
//  Programmer: spu92482 -- generated by xml2avt
//  Creation:   Fri Sep 24 18:04:29 PST 2010
//
// ****************************************************************************

avtFilter *
avtRebinningCutterFilter::Create()
{
  avtRebinningCutterFilter* filter = new avtRebinningCutterFilter();
  return filter;
}

// ****************************************************************************
//  Method:      avtRebinningCutterFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: spu92482 -- generated by xml2avt
//  Creation:   Fri Sep 24 18:04:29 PST 2010
//
// ****************************************************************************

void avtRebinningCutterFilter::SetAtts(const AttributeGroup *a)
{
  atts = *(const RebinningCutterAttributes*) a;
}

// ****************************************************************************
//  Method: avtRebinningCutterFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtRebinningCutterFilter with the given
//      parameters would result in an equivalent avtRebinningCutterFilter.
//
//  Programmer: spu92482 -- generated by xml2avt
//  Creation:   Fri Sep 24 18:04:29 PST 2010
//
// ****************************************************************************

bool avtRebinningCutterFilter::Equivalent(const AttributeGroup *a)
{
  return (atts == *(RebinningCutterAttributes*) a);
}

Mantid::VATES::Dimension_sptr avtRebinningCutterFilter::getDimensionX(vtkDataSet* in_ds) const
{

  if (atts.GetIsSetUp())
  {
    return Mantid::VATES::createDimension(atts.GetDimensionXML()[0]);
  }
  else
  {
    return m_presenter.getXDimensionFromDS(in_ds);
  }

}

Mantid::VATES::Dimension_sptr avtRebinningCutterFilter::getDimensionY(vtkDataSet* in_ds) const
{
  if (atts.GetIsSetUp())
  {
    return Mantid::VATES::createDimension(atts.GetDimensionXML()[1]);
  }
  else
  {
    return m_presenter.getYDimensionFromDS(in_ds);
  }
}

Mantid::VATES::Dimension_sptr avtRebinningCutterFilter::getDimensionZ(vtkDataSet* in_ds) const
{
  if (atts.GetIsSetUp())
  {
    return Mantid::VATES::createDimension(atts.GetDimensionXML()[2]);
  }
  else
  {
    return m_presenter.getZDimensionFromDS(in_ds);
  }
}

Mantid::VATES::Dimension_sptr avtRebinningCutterFilter::getDimensiont(vtkDataSet* in_ds) const
{
    return m_presenter.getTDimensionFromDS(in_ds);
}

std::string avtRebinningCutterFilter::createHash() const
{
  size_t seed = 1;
  boost::hash_combine(seed, atts.GetOriginX());
  boost::hash_combine(seed, atts.GetOriginY());
  boost::hash_combine(seed, atts.GetOriginZ());
  boost::hash_combine(seed, atts.GetNormalX());
  boost::hash_combine(seed, atts.GetNormalY());
  boost::hash_combine(seed, atts.GetNormalZ());
  boost::hash_combine(seed, atts.GetWidth());
  boost::hash_combine(seed, atts.GetHeight());
  boost::hash_combine(seed, atts.GetDepth());
  boost::hash_combine(seed, atts.GetStructured());
  boost::hash_combine(seed, atts.GetDimensionXML());
  std::stringstream sstream;
  sstream << seed;
  return sstream.str();
}

bool avtRebinningCutterFilter::anyPlaneApplied() const
{
  return ((atts.GetNormalX() != 0) || (atts.GetNormalY() != 0) || (atts.GetNormalZ() != 0));
}

boost::shared_ptr<Mantid::API::ImplicitFunction> avtRebinningCutterFilter::constructPlane() const
{
  using namespace Mantid::MDAlgorithms;
  Mantid::API::ImplicitFunction* appliedFunction;
  if (atts.GetIsSetUp() && anyPlaneApplied())
  {
    NormalParameter normal(atts.GetNormalX(), atts.GetNormalY(), atts.GetNormalZ());
    OriginParameter origin(atts.GetOriginX(), atts.GetOriginY(), atts.GetOriginZ());
    UpParameter up(atts.GetUpX(), atts.GetUpY(), atts.GetUpZ());
    WidthParameter width(atts.GetWidth());
    appliedFunction = new PlaneImplicitFunction(normal, origin, up, width);
  }
  else
  {
    appliedFunction = new NullImplicitFunction;
  }
  return boost::shared_ptr<Mantid::API::ImplicitFunction>(appliedFunction);
}

boost::shared_ptr<Mantid::API::ImplicitFunction> avtRebinningCutterFilter::constructBox(
    Dimension_sptr spDimX, Dimension_sptr spDimY, Dimension_sptr spDimZ) const
{
  using namespace Mantid::MDAlgorithms;
  BoxImplicitFunction* boxFunction;
  if (atts.GetIsSetUp())
  {
    //Create domain parameters.
    OriginParameter originParam = OriginParameter(atts.GetOriginX(), atts.GetOriginY(),
        atts.GetOriginZ());
    WidthParameter widthParam = WidthParameter(atts.GetWidth());
    HeightParameter heightParam = HeightParameter(atts.GetHeight());
    DepthParameter depthParam = DepthParameter(atts.GetDepth());

    //Create the box. This is specific to this type of presenter and this type of filter. Other rebinning filters may use planes etc.
    boxFunction = new BoxImplicitFunction(widthParam, heightParam, depthParam, originParam);
  }
  else
  {
    //Have to use dimension knowledge to construct box.
    double originX = (spDimX->getMaximum() + spDimX->getMinimum()) / 2;
    double originY = (spDimY->getMaximum() + spDimY->getMinimum()) / 2;
    double originZ = (spDimZ->getMaximum() + spDimZ->getMinimum()) / 2;
    double width = spDimX->getMaximum() - spDimX->getMinimum();
    double height = spDimY->getMaximum() - spDimY->getMinimum();
    double depth = spDimZ->getMaximum() - spDimZ->getMinimum();

    //Create domain parameters.
    OriginParameter originParam = OriginParameter(originX, originY, originZ);
    WidthParameter widthParam = WidthParameter(width);
    HeightParameter heightParam = HeightParameter(height);
    DepthParameter depthParam = DepthParameter(depth);

    //Create the box. This is specific to this type of presenter and this type of filter. Other rebinning filters may use planes etc.
    boxFunction = new BoxImplicitFunction(widthParam, heightParam, depthParam, originParam);
  }
  return boost::shared_ptr<Mantid::API::ImplicitFunction>(boxFunction);
}

vtkDataSetFactory_sptr avtRebinningCutterFilter::createDataSetFactory(
    Mantid::MDDataObjects::MDWorkspace_sptr spRebinnedWs) const
{
  //Interogate attributes to determine user selection.
  using Mantid::MDDataObjects::MDImage;
  vtkDataSetFactory* pvtkDataSetFactory;
  if (atts.GetStructured())
  {
    pvtkDataSetFactory = new vtkStructuredGridFactory<MDImage> (spRebinnedWs->get_spMDImage(),
        XMLDefinitions::signalName, m_timestep);
  }
  else
  {
    pvtkDataSetFactory = new vtkThresholdingUnstructuredGridFactory<MDImage> (
        spRebinnedWs->get_spMDImage(), XMLDefinitions::signalName, m_timestep);
  }
  return vtkDataSetFactory_sptr(pvtkDataSetFactory);
}

avtContract_p avtRebinningCutterFilter::ModifyContract(avtContract_p incontract)
{
  this->m_timestep = incontract->GetDataRequest()->GetTimestep();
  return incontract;
}

RebinningIterationAction avtRebinningCutterFilter::decideIterationAction()
{
  vtkDataSet* cachedOutput = static_cast<vtkDataSet*> (FetchArbitraryVTKObject(DATA_DEPENDENCE,
    this->createHash().c_str(), 0, 1, "VTK_DATASET"));

  void_ref_ptr ptr = FetchArbitraryRefPtr(DATA_DEPENDENCE,"timestep",0, 1, "INT" );

  RebinningIterationAction action;
  if(cachedOutput == NULL)
  {
    action = RecalculateAll;
  }
  else
  {
    int* oldtime = (int*)(*ptr);
    if(*oldtime == m_timestep)
    {
      action = UseCache; // Use cache since there has been no change.
    }
    else
    {
      action = RecalculateVisualDataSetOnly; //Use original MDImage, but determine a new slice.
    }
  }
  return action;
}

void deleteTimeMarker(void* timeMarkerVoid)
{
  int* cachedmarker = (int*)timeMarkerVoid;
  delete cachedmarker;
}

void avtRebinningCutterFilter::Execute()
{
  using namespace Mantid::VATES;
  using namespace Mantid::Geometry;
  using namespace Mantid::MDDataObjects;
  using namespace Mantid::MDAlgorithms;

  using Mantid::VATES::DimensionVec;
  using Mantid::VATES::Dimension_sptr;

  avtDataTree_p tree = GetInputDataTree();
  int nLeaves;
  vtkDataSet **leaves = tree->GetAllLeaves(nLeaves);
  vtkDataSet *in_ds = leaves[0];

  Dimension_sptr spDimX = getDimensionX(in_ds);
  Dimension_sptr spDimY = getDimensionY(in_ds);
  Dimension_sptr spDimZ = getDimensionZ(in_ds);
  Dimension_sptr spDimt = getDimensiont(in_ds);

  DimensionVec dimensionsVec(4);
  dimensionsVec[0]=spDimX;
  dimensionsVec[1]=spDimY;
  dimensionsVec[2]=spDimZ;
  dimensionsVec[3]=spDimt;

  //Create the composite holder.
  CompositeImplicitFunction* compFunction = new CompositeImplicitFunction;
  compFunction->addFunction(constructBox(spDimX, spDimY, spDimZ));
  compFunction->addFunction(constructPlane());

  // Construct reduction knowledge.
   m_presenter.constructReductionKnowledge(dimensionsVec, spDimX, spDimY, spDimZ, spDimt,
      compFunction, in_ds);

    //The action determines the level of caching available for optimisations.
  RebinningIterationAction action = decideIterationAction();


  VisITProgressAction updatehandler(this);

   //Acutally perform rebinning or specified action.
   MDWorkspace_sptr spRebinnedWs = m_presenter.applyRebinningAction(action, updatehandler);

  /// Create the dataset factory from the user selection.
  vtkDataSet *output_ds;
  if (UseCache == action)
  {
    vtkDataSet* cachedOutput = static_cast<vtkDataSet*> (FetchArbitraryVTKObject(DATA_DEPENDENCE,
        this->createHash().c_str(), 0, 1, "VTK_DATASET"));
    //Use existing visualisation image.
    vtkDataSetFactory_sptr spvtkDataSetFactory(new vtkProxyFactory(cachedOutput));
    output_ds = m_presenter.createVisualDataSet(spvtkDataSetFactory);
    output_ds->Register(NULL);
  }
 else
 {
    /// Use the dataset factory to draw an image and to persist metadata.
    StoreArbitraryRefPtr(DATA_DEPENDENCE, "timestep", 0, 1, "INT", void_ref_ptr(new int(m_timestep), deleteTimeMarker));

    vtkDataSetFactory_sptr spvtkDataSetFactory = createDataSetFactory(spRebinnedWs);
    output_ds = m_presenter.createVisualDataSet(spvtkDataSetFactory);

    StoreArbitraryVTKObject(DATA_DEPENDENCE, this->createHash().c_str(), 0, 1, "VTK_DATASET",
        output_ds);
  }


  output_ds->GetCellData()->SetActiveScalars(XMLDefinitions::signalName.c_str());
  avtDataTree* newTree = new avtDataTree(output_ds, 0);
  SetOutputDataTree(newTree);
  double newrange[2] =
  { FLT_MAX, -FLT_MAX };
  double oldrange[2] =
  { FLT_MAX, -FLT_MAX };
  GetDataRange(output_ds, newrange, XMLDefinitions::signalName.c_str(), false);
  GetDataRange(in_ds, oldrange, XMLDefinitions::signalName.c_str(), false);
  avtDataAttributes &dataAtts = GetOutput()->GetInfo().GetAttributes();
  dataAtts.GetThisProcsOriginalDataExtents(XMLDefinitions::signalName.c_str())->Set(oldrange);
  dataAtts.GetThisProcsActualDataExtents(XMLDefinitions::signalName.c_str())->Set(newrange);

  //Persist the execution output geometry so that it can be dermined later in VisIT gui.
  MapNode geometryXMLNode;
  geometryXMLNode[XMLDefinitions::geometryNodeName] = m_presenter.getWorkspaceGeometry();
  MapNode functionXMLNode;
  functionXMLNode[XMLDefinitions::functionNodeName] = m_presenter.getFunction()->toXMLString();

  dataAtts.AddPlotInformation(XMLDefinitions::geometryOperatorInfo, geometryXMLNode);
  dataAtts.AddPlotInformation(XMLDefinitions::functionOperatorInfo, functionXMLNode);

  dataAtts.SetXLabel(spDimX->getDimensionId());
  dataAtts.SetYLabel(spDimY->getDimensionId());
  dataAtts.SetZLabel(spDimZ->getDimensionId());

  avtDatasetVerifier v;
  vector<int> domains;
  domains.push_back(0);
  v.VerifyDatasets(1, &output_ds, domains);

}

void avtRebinningCutterFilter::UpdateDataObjectInfo(void)
{
  avtDataAttributes &dataAtts = GetOutput()->GetInfo().GetAttributes();
  int dim = 3;
  dataAtts.SetTopologicalDimension(dim);
  dataAtts.SetSpatialDimension(dim);
}

void avtRebinningCutterFilter::UpdateAlgorithmProgress(int progressPercent)
{
  this->UpdateProgress(1, progressPercent);
}





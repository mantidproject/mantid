//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------
#include <malloc/malloc.h>
#include <sys/sysctl.h>
#include <mach/mach_host.h>

namespace Mantid
{
namespace API
{

void MemoryManagerImpl::init()
{
  // Nothing to do here at present
}

MemoryInfo MemoryManagerImpl::getMemoryInfo()
{
  MemoryInfo mi;
  
  // Get the total RAM of the system
  uint64_t totalmem;
  size_t len = sizeof(totalmem);
  // Gives system memory in bytes
  int err = sysctlbyname("hw.memsize",&totalmem,&len,NULL,0);
  if (err) g_log.warning("Unable to obtain memory of system");
  mi.totalMemory = totalmem / 1024;

  mach_port_t port = mach_host_self();
  // Need to find out the system page size for next part
  vm_size_t pageSize;
  host_page_size(port, &pageSize);

  // Now get the amount of free memory (=free+inactive memory)
  vm_statistics vmStats;
  mach_msg_type_number_t count;
  count = sizeof(vm_statistics) / sizeof(natural_t);
  err = host_statistics(port, HOST_VM_INFO, (host_info_t)&vmStats, &count);
  if (err) g_log.warning("Unable to obtain memory statistics");
  mi.availMemory = pageSize * ( vmStats.free_count + vmStats.inactive_count ) / 1024;

  // Now add in reserved but unused memory as reported by malloc
  const size_t unusedReserved = mstats().bytes_free / 1024;
  g_log.debug() << "Mac - Adding reserved but unused memory of " << unusedReserved << " KB\n";
  mi.availMemory += unusedReserved;
  
  mi.freeRatio = static_cast<int>(100.0*mi.availMemory/mi.totalMemory);
  g_log.debug() << "Percentage of memory taken to be available for use (incl. cache): "
      << mi.freeRatio << "%.\n";
  return mi;
}

} // namespace API
} // namespace Mantid

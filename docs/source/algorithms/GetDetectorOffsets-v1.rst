.. algorithm::

.. summary::

.. relatedalgorithms::

.. properties::

Description
-----------

This algorithm requires a workspace containing a cross-correlation, generated by the :ref:`algm-CrossCorrelate` algorithm which should contain a single peak and where the x-axis contains spectral offsets, in number of bins.

The algorithm iterates over each spectrum in the input workspace containing the cross-correlation spectra and fits a PeakFunction (default is a :ref:`Gaussian <func-Gaussian>` function) with :ref:`linear background <func-LinearBackground>` to the cross-correlation spectra.
Remember: the peak shape is used for fitting the cross-correlation spectrum rather than the Bragg peaks in the original data.

Converting peak position to offset
##################################
The fit is used to calculate the centre of the fitted peak.
In the equations below, the found centre of the cross-correlation peak is refered to as :math:`CCPeakCentre`.
The other parameters in the equations,
:math:`Step` is the ``Step`` property,
:math:`DReference` is the ``DReference`` property,
and :math:`DIdeal` is the ``DIdeal`` property.
Using the fitted peak center, there are 3 options for calculating offset, depending on the choice for the ``OffsetMode``
input parameter:

``OffsetMode="Relative"`` (offset relative to reference position):

:math:`offset = -CCPeakCentre*Step/(DReference+CCPeakCentre*Step)`

This requires a narrow integration band in :ref:`algm-CrossCorrelate` with linear binning of the input data and a known ``DReference``.

``OffsetMode="Absolute"`` (offset relative to ideal position):

:math:`offset = -CCPeakCentre*Step/(DReference+CCPeakCentre*Step) + (DIdeal - DReference) / DReference`

This requires a narrow integration band in :ref:`algm-CrossCorrelate` with linear binning of the input data and a known ``DReference``.

``OffsetMode="Signed"`` (offset in raw number of bins):

:math:`offset = -CCPeakCentre`

This is then written into a :ref:`.cal file <CalFile>` for every detector
that contributes to that spectrum. All of the entries in the cal file
are initially set to both be included, but also to all group into a
single group on :ref:`algm-DiffractionFocussing`. The
:ref:`algm-CreateCalFileByNames` algorithm can be used to
alter the grouping in the cal file.

Estimating the CC-spectrum fit parameters
#########################################

The starting value for the fit is that the linear background is zero.

The peak center is found in two steps.
First is the x-value of the highest point in the whole cross-correlation spectrum.
Then it is observed again by subtracting the background (which is zero) then finding the highest point again within the neighborhood of the original data.

The height is the background subtracted y-value of the heightest point as described earlier.

The full-width-half-maximum is :math:`2 \sigma \sqrt{2 ln(2)}` where :math:`\sigma=10` if ``EstimateFWHM=False``.
When ``True``, the value is estimated by integrating the background subtracted area under the window and dividing by the height.

**Problems can arise** for fitting if the cross-correlation peak is broad or the background is high and/or with significant slope.
Since a broad peak can be estimated as a very broad peak with a relatively high background, the peak can be easily misfit.
Similarly, since the starting value for the background is zero, a heavily sloping background will interfere with determining a starting value for the peak position.
Also note that if the input cross-correlation has been calculated over too large a d-spacing range it can contain "harmonics" in addition to the fundamental peak and this will obviously confuse the peak fitting algorithm.

Usage
-----

.. testcode::

  import os

  # Create a workspace with a Gaussian peak in the centre.
  ws = CreateSampleWorkspace(Function='User Defined',UserDefinedFunction='name=Gaussian,Height=1,PeakCentre=10,Sigma=1',XMin=0,XMax=20,BinWidth=0.1)
  ws.getAxis(0).setUnit( 'dSpacing' )

  # Generate a file path to save the .cal file at.
  calFilePath = os.path.expanduser( '~/MantidUsageExample_CalFile.cal' )

  # Run the algorithm
  msk = GetDetectorOffsets(ws,0.001,10.0,0, 10, calFilePath)

  # Read the saved .cal file back in
  f = open( calFilePath, 'r' )
  file = f.read().split('\n')
  f.close()

  # Print out first 10 lines of the file
  print("{} ...".format(file[0][:55]))
  for line in file[1:10]:
      print(line)

Output
######

.. testoutput::

    # Calibration file for instrument basic_rect written on ...
    # Format: number    UDET         offset    select    group
            0            ...     ...       1       1
            1            ...     ...       1       1
            2            ...     ...       1       1
            3            ...     ...       1       1
            4            ...     ...       1       1
            5            ...     ...       1       1
            6            ...     ...       1       1
            7            ...     ...       1       1


.. testcleanup::

  os.remove( calFilePath )

.. categories::

.. sourcelink::


.. algorithm::

.. summary::

.. alias::

.. properties::

Description
-----------

This algorithm computes some crystallographic data set quality indicators that are based
on counting reflections according to their Miller indices HKL. Intensity information is not
required for these indicators, so that the algorithm can also be used with predicted data
(for example generated by :ref:`algm-PredictPeaks`).

According to the specified lattice centering and the resolution boundaries, a set of
theoretically measurable reflections is generated. How the reflections are mapped to
a set of :math:`N_{theor.}` unique reflections depends on the supplied point group. Then the
:math:`N_{observed}` actually observed peaks from the input workspace are assigned to their
respective unique reflection, yielding :math:`N_{unique}` observed unique reflections.

From this assignment it is possible to calculate the following indicators:

  * Unique reflections: :math:`N_{unique}`
  * Completeness: :math:`\frac{N_{unique}}{N_{theor.}}`
  * Redundancy: :math:`\frac{N_{observed}}{N_{unique}}`
  * Multiply observed reflections: :math:`\frac{N_{unique} | N^{hkl}_{observed} > 1}{N_{unique}}`

Furthermore, the algorithm optionally produces a list of missing reflections. In this list,
each missing unique reflection is expanded to all symmetry equivalents according to the point
group. For example, if the reflection family :math:`\{001\}` was missing
with point group :math:`\bar{1}`, the list would contain :math:`(001)` and :math:`(00\bar{1})`.

The reason for expanding the unique reflections is to make the list more useful as an input
to :ref:`algm-PredictPeaks` again.

.. note::

    This algorithm has some overlap with :ref:`algm-SortHKL`, which computes some of the indicators this
    algorithm calculates, but in addition also evaluates intensity information. SortHKL only works with
    peaks that carry intensity data while this algorithm also works without intensities.

Usage
-----

The usage example uses the same data as the usage test in :ref:`algm-SortHKL`, but produces slightly different
data, because some intensities in the input file are 0, so these reflections are ignored by :ref:`algm-SortHKL`:

.. testcode:: CountReflectionsExample

    # Load example peak data and find cell
    peaks = LoadIsawPeaks(Filename=r'Peaks5637.integrate')

    FindUBUsingFFT(peaks, MinD=0.25, MaxD=10, Tolerance=0.2)
    SelectCellWithForm(peaks, FormNumber=9, Apply=True, Tolerance=0.15)
    OptimizeLatticeForCellType(peaks, CellType='Hexagonal', Apply=True, Tolerance=0.2)

    # Run the SortHKL algorithm
    unique, completeness, redundancy, multiple = CountReflections(peaks, PointGroup='-3m1',
                                                                  LatticeCentering='Robv', MinDSpacing=0.205,
                                                                  MaxDSpacing=2.08, MissingReflectionsWorkspace='')

    print('Data set statistics:')
    print('             Peaks: {0}'.format(peaks.getNumberPeaks()))
    print('            Unique: {0}'.format(unique))
    print('      Completeness: {0}%'.format(round(completeness * 100, 2)))
    print('        Redundancy: {0}'.format(round(redundancy, 2)))
    print(' Multiply observed: {0}%'.format(round(multiple*100, 2)))

Output:

.. testoutput:: CountReflectionsExample

    Data set statistics:
                 Peaks: 434
                Unique: 358
          Completeness: 9.57%
            Redundancy: 1.21
     Multiply observed: 20.67%

The resulting completeness is slightly higher than in the SortHKL case, but for actual statistics it might be
better to remove the zero intensity peaks from the workspace prior to running the algorithm.

.. categories::

.. sourcelink::

